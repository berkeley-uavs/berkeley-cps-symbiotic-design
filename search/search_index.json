{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"sym-cps \u00b6 Symbiotic Design for Cyber Physical Systems Project description available here Documentation available here Local Installation \u00b6 System Requirements \u00b6 pdm Access to this repo . Quick start \u00b6 Clone the two repos and their submodules in the same folder git clone --recurse-submodules https://github.com/uc-berkeley-data-discovery-2022/berkeley-cps-symbiotic-design.git & \\ git clone https://github.com/uc-berkeley-data-discovery-2022/challenge_data.git Navigate to berkeley-cps-symbiotic-design folder and install dependencies cd berkeley-cps-symbiotic-design & \\ pdm install Configure AWS \u00b6 Download the aws-cvpn-config.ovpn configuration file from the challenge_data repo repo and use it to connect to the AWS VPN. Here are the instructions for Linux , MacOS and Windows . Create the folder ../challenge_data/aws if it does not exist already. (Optional) notify your IDE to exclude the aws folder from being indexed. For example in PyCharm do Right Click on aws - Mark directory as - Excluded Mount the shared folder in ../challenge_data/aws . Instructions here . Make sure you are connected via the VPN before mounting the shared drive. Suggestion: from the root folder of the repo, you can try one of the following commands, according to your OS and preferences sudo mount -t nfs 10.0.137.113:/fsx/ ../challenge_data/aws sudo mount_nfs -o resvport 10.0.137.113:/fsx/ ../challenge_data/aws sudo mount -o resvport -t nfs 10.0.137.113:/fsx/ ../challenge_data/aws After have successfully installed the dependencies and activated the conda environment. Launch the following command from the root of the repo sudo pdm run suam-config install --no-symlink --input = ./data/broker.conf.yaml Docker Installation \u00b6 System Requirements \u00b6 Docker Access to this repo . Quick start \u00b6 Clone the two repos and their submodules in the same folder git clone --recurse-submodules https://github.com/uc-berkeley-data-discovery-2022/berkeley-cps-symbiotic-design.git & \\ git clone https://github.com/uc-berkeley-data-discovery-2022/challenge_data.git Navigate to berkeley-cps-symbiotic-design folder and launch docker script cd berkeley-cps-symbiotic-design & \\ ./docker_run.sh bash The output file will automatically appear in the challenge_data/output folder. Also, any change you make to the files in berkeley-cps-symbiotic-design will be immediately available inside the docker container. You can launch the docker container in the background with ./docker_run.sh Remote deployment from IDE \u00b6 The docker image contains an ssh server that you can connect from your IDE and run your code/debug directly inside docker without the need of installing any dependencies. Launch: ./docker_run.sh to launch the docker image as a new container running in background. Then connect to the python interpreter via SSH on port 9922 of localhost as explained below: PyCharm \u00b6 Go to: Preference > Build, Execution\u2026 > Deployment Add new SFTP . Give a name, e.g. : docker-sym-cps . Add a new SSH configuration: Host: localhost Port: 9922 Username: root Password: password Root path: /root Mappings: Local path \u2018 /berkeley-cps-symbiotic-design\u2019 Deployment path \u2018/ide\u2019 Got to: Preferences > Project\u2026 > Python Interpreter > Add Interpreter > On SSH and select Existing Connection the SSH connection previously created, then select the \u201cSystem Interpreter\u201d as Python runtime configuration, i.e. the interpreter at /usr/bin/python3\u2019. \u201cSync folders\u201d insert \u2192/root/ide` On Python Interpreter , click on Show all and select the Remote Python interpreter that you have just created. On the top right of the window clock on Show Interpreter Paths , and add a new path /root/host/__pypackages__/3.10/lib . Run \u00b6 Launch Python scripts from command line \u00b6 When running a python script from command line, insert pdm run before. For example: pdm run python src/sym_cps/examples/library.py Working with IDEs \u00b6 With PEP 582, dependencies will be installed into pypackages directory under the project root. With PEP 582 enabled globally, you can also use the project interpreter to run scripts directly. Check pdm documentation on PEP 582. PYCHARM Add __pypackages__/3.10/lib and src folders to your PYTHONPATH. With PyCharm you can simple right click on the folders and select Mark Directory as - Source folder . VSCODE To configure VSCode to support PEP 582, open .vscode/settings.json (create one if it does not exist) and add the following entries: { \"python.autoComplete.extraPaths\" : [ \"__pypackages__/3.10/lib\" ], \"python.analysis.extraPaths\" : [ \"__pypackages__/3.10/lib\" ] } Useful scripts \u00b6 Uninstall all dependencies and clean up the repository from temporary files make uninstall Load library and seed designs and export them in the output folder pdm run init Export all seed designs in the output folder pdm run export-designs Load and export custom design where \"custom_design_file\" is the file name of the json file in the data/custom_designs folder, for example: pdm run custom-design \"working/test_quad_abstraction_3\" Examples \u00b6 Check the example folder and look at the code of the python files to get familiar with the API. Here's some example you can launch. Populate the library of components from the data folder pdm run python src/sym_cps/examples/library.py Extracts the seed designs pdm run python src/sym_cps/examples/designs.py Create a new design from scratch. First choosing and topology and then concretize it. pdm run python src/sym_cps/examples/topology.py Evaluate designs from command line specifying the path of the design_swri,json in <design-file> : sudo pdm run suam-client direct2cad.process-design --design = <design-file> --results = ../challenge_data/aws/results For example: pdm run suam-client direct2cad.process-design --design = ../challenge_data/output/designs/TestQuad/design_swri.json --results = ../challenge_data/aws/results Evaluate designs from python pdm run python src/sym_cps/examples/evaluation.py Web interface \u00b6 Run the back-end by executing backend/app.py Install react dependencies via npm by running: npm install --legacy-peer-deps inside the frontend folder. Then run the front-end: npm run start Troubleshooting \u00b6 Installation process \u00b6 If you have problems with the environment you can clean up the files and folders created by pdm and conda by running make uninstall Then try installation process again. pdm install Submodules \u00b6 Make sure the submodules are correctly imported and updated git submodule init git submodule update -- Make sure that eval_pipeline folder is not empty. If the submodule was not pulled correctly you can simply clone this repo and copy its content inside eval_pipeline folder. Apple Silicon \u00b6 For Mac M1 users, if you have architecture problems (i.e. some packages are not available for arm), you can try simulating x86_64 architecture and install the dependencies again. env /usr/bin/arch -x86_64 /bin/zsh However, all the dependencies right now should support arm and you should not change architecture. To run a x86 terminal by default in VSCode, add the following to your settings.json \"terminal.integrated.profiles.osx\" : { \"x86 bash\" : { \"path\" : \"/usr/bin/arch\" , \"args\" : [ \"-arch\" , \"x86_64\" , \"/bin/bash\" ] }}, \"terminal.integrated.defaultProfile.osx\" : \"x86 bash\" To run a x86 terminal by default in PyCharm, go to Preferences/Tools/Terminal and set the shell path to be: env /usr/bin/arch -x86_64 /bin/zsh --login Features and Credits \u00b6 Fully typed with annotations and checked with mypy, PEP561 compatible","title":"Overview"},{"location":"#sym-cps","text":"Symbiotic Design for Cyber Physical Systems Project description available here Documentation available here","title":"sym-cps"},{"location":"#local-installation","text":"","title":"Local Installation"},{"location":"#system-requirements","text":"pdm Access to this repo .","title":"System Requirements"},{"location":"#quick-start","text":"Clone the two repos and their submodules in the same folder git clone --recurse-submodules https://github.com/uc-berkeley-data-discovery-2022/berkeley-cps-symbiotic-design.git & \\ git clone https://github.com/uc-berkeley-data-discovery-2022/challenge_data.git Navigate to berkeley-cps-symbiotic-design folder and install dependencies cd berkeley-cps-symbiotic-design & \\ pdm install","title":"Quick start"},{"location":"#configure-aws","text":"Download the aws-cvpn-config.ovpn configuration file from the challenge_data repo repo and use it to connect to the AWS VPN. Here are the instructions for Linux , MacOS and Windows . Create the folder ../challenge_data/aws if it does not exist already. (Optional) notify your IDE to exclude the aws folder from being indexed. For example in PyCharm do Right Click on aws - Mark directory as - Excluded Mount the shared folder in ../challenge_data/aws . Instructions here . Make sure you are connected via the VPN before mounting the shared drive. Suggestion: from the root folder of the repo, you can try one of the following commands, according to your OS and preferences sudo mount -t nfs 10.0.137.113:/fsx/ ../challenge_data/aws sudo mount_nfs -o resvport 10.0.137.113:/fsx/ ../challenge_data/aws sudo mount -o resvport -t nfs 10.0.137.113:/fsx/ ../challenge_data/aws After have successfully installed the dependencies and activated the conda environment. Launch the following command from the root of the repo sudo pdm run suam-config install --no-symlink --input = ./data/broker.conf.yaml","title":"Configure AWS"},{"location":"#docker-installation","text":"","title":"Docker Installation"},{"location":"#system-requirements_1","text":"Docker Access to this repo .","title":"System Requirements"},{"location":"#quick-start_1","text":"Clone the two repos and their submodules in the same folder git clone --recurse-submodules https://github.com/uc-berkeley-data-discovery-2022/berkeley-cps-symbiotic-design.git & \\ git clone https://github.com/uc-berkeley-data-discovery-2022/challenge_data.git Navigate to berkeley-cps-symbiotic-design folder and launch docker script cd berkeley-cps-symbiotic-design & \\ ./docker_run.sh bash The output file will automatically appear in the challenge_data/output folder. Also, any change you make to the files in berkeley-cps-symbiotic-design will be immediately available inside the docker container. You can launch the docker container in the background with ./docker_run.sh","title":"Quick start"},{"location":"#remote-deployment-from-ide","text":"The docker image contains an ssh server that you can connect from your IDE and run your code/debug directly inside docker without the need of installing any dependencies. Launch: ./docker_run.sh to launch the docker image as a new container running in background. Then connect to the python interpreter via SSH on port 9922 of localhost as explained below:","title":"Remote deployment from IDE"},{"location":"#pycharm","text":"Go to: Preference > Build, Execution\u2026 > Deployment Add new SFTP . Give a name, e.g. : docker-sym-cps . Add a new SSH configuration: Host: localhost Port: 9922 Username: root Password: password Root path: /root Mappings: Local path \u2018 /berkeley-cps-symbiotic-design\u2019 Deployment path \u2018/ide\u2019 Got to: Preferences > Project\u2026 > Python Interpreter > Add Interpreter > On SSH and select Existing Connection the SSH connection previously created, then select the \u201cSystem Interpreter\u201d as Python runtime configuration, i.e. the interpreter at /usr/bin/python3\u2019. \u201cSync folders\u201d insert \u2192/root/ide` On Python Interpreter , click on Show all and select the Remote Python interpreter that you have just created. On the top right of the window clock on Show Interpreter Paths , and add a new path /root/host/__pypackages__/3.10/lib .","title":"PyCharm"},{"location":"#run","text":"","title":"Run"},{"location":"#launch-python-scripts-from-command-line","text":"When running a python script from command line, insert pdm run before. For example: pdm run python src/sym_cps/examples/library.py","title":"Launch Python scripts from command line"},{"location":"#working-with-ides","text":"With PEP 582, dependencies will be installed into pypackages directory under the project root. With PEP 582 enabled globally, you can also use the project interpreter to run scripts directly. Check pdm documentation on PEP 582. PYCHARM Add __pypackages__/3.10/lib and src folders to your PYTHONPATH. With PyCharm you can simple right click on the folders and select Mark Directory as - Source folder . VSCODE To configure VSCode to support PEP 582, open .vscode/settings.json (create one if it does not exist) and add the following entries: { \"python.autoComplete.extraPaths\" : [ \"__pypackages__/3.10/lib\" ], \"python.analysis.extraPaths\" : [ \"__pypackages__/3.10/lib\" ] }","title":"Working with IDEs"},{"location":"#useful-scripts","text":"Uninstall all dependencies and clean up the repository from temporary files make uninstall Load library and seed designs and export them in the output folder pdm run init Export all seed designs in the output folder pdm run export-designs Load and export custom design where \"custom_design_file\" is the file name of the json file in the data/custom_designs folder, for example: pdm run custom-design \"working/test_quad_abstraction_3\"","title":"Useful scripts"},{"location":"#examples","text":"Check the example folder and look at the code of the python files to get familiar with the API. Here's some example you can launch. Populate the library of components from the data folder pdm run python src/sym_cps/examples/library.py Extracts the seed designs pdm run python src/sym_cps/examples/designs.py Create a new design from scratch. First choosing and topology and then concretize it. pdm run python src/sym_cps/examples/topology.py Evaluate designs from command line specifying the path of the design_swri,json in <design-file> : sudo pdm run suam-client direct2cad.process-design --design = <design-file> --results = ../challenge_data/aws/results For example: pdm run suam-client direct2cad.process-design --design = ../challenge_data/output/designs/TestQuad/design_swri.json --results = ../challenge_data/aws/results Evaluate designs from python pdm run python src/sym_cps/examples/evaluation.py","title":"Examples"},{"location":"#web-interface","text":"Run the back-end by executing backend/app.py Install react dependencies via npm by running: npm install --legacy-peer-deps inside the frontend folder. Then run the front-end: npm run start","title":"Web interface"},{"location":"#troubleshooting","text":"","title":"Troubleshooting"},{"location":"#installation-process","text":"If you have problems with the environment you can clean up the files and folders created by pdm and conda by running make uninstall Then try installation process again. pdm install","title":"Installation process"},{"location":"#submodules","text":"Make sure the submodules are correctly imported and updated git submodule init git submodule update -- Make sure that eval_pipeline folder is not empty. If the submodule was not pulled correctly you can simply clone this repo and copy its content inside eval_pipeline folder.","title":"Submodules"},{"location":"#apple-silicon","text":"For Mac M1 users, if you have architecture problems (i.e. some packages are not available for arm), you can try simulating x86_64 architecture and install the dependencies again. env /usr/bin/arch -x86_64 /bin/zsh However, all the dependencies right now should support arm and you should not change architecture. To run a x86 terminal by default in VSCode, add the following to your settings.json \"terminal.integrated.profiles.osx\" : { \"x86 bash\" : { \"path\" : \"/usr/bin/arch\" , \"args\" : [ \"-arch\" , \"x86_64\" , \"/bin/bash\" ] }}, \"terminal.integrated.defaultProfile.osx\" : \"x86 bash\" To run a x86 terminal by default in PyCharm, go to Preferences/Tools/Terminal and set the shell path to be: env /usr/bin/arch -x86_64 /bin/zsh --login","title":"Apple Silicon"},{"location":"#features-and-credits","text":"Fully typed with annotations and checked with mypy, PEP561 compatible","title":"Features and Credits"},{"location":"changelog/","text":"Changelog \u00b6 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"contributing/","text":"Contributing \u00b6 Contributions are welcome, and they are greatly appreciated! Tasks \u00b6 This project uses duty to run tasks. A Makefile is also provided. Once the project is installed ( make setup ), run make help to see all available tasks Development \u00b6 We use pdm to manage the dependencies. Use pdm add to install new packages. Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) if you updated the documentation or the project dependencies: run make docs-serve go to http://localhost:8000 and check that everything looks good Activate Pre-Commit Hooks pre-commit install","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated!","title":"Contributing"},{"location":"contributing/#tasks","text":"This project uses duty to run tasks. A Makefile is also provided. Once the project is installed ( make setup ), run make help to see all available tasks","title":"Tasks"},{"location":"contributing/#development","text":"We use pdm to manage the dependencies. Use pdm add to install new packages. Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) if you updated the documentation or the project dependencies: run make docs-serve go to http://localhost:8000 and check that everything looks good Activate Pre-Commit Hooks pre-commit install","title":"Development"},{"location":"credits/","text":"These projects were used to build sym-cps . Thank you! python | pdm | copier-pdm Runtime dependencies \u00b6 Project Summary Version (accepted) Version (last resolved) License bayesian-optimization Bayesian Optimization package @ git+https://github.com/fmfn/BayesianOptimization 1.3.1 MIT License bidict The bidirectional mapping library for Python. >=0.21.0 0.22.0 MPL 2.0 click Composable command line interface toolkit >=8.0 8.1.3 BSD-3-Clause colorama Cross-platform colored terminal text. ; platform_system == \"Windows\" 0.4.6 BSD License contourpy Python library for calculating contours of 2D quadrilateral grids >=1.0.1 1.0.6 BSD-3-Clause cycler Composable style cycles >=0.10 0.11.0 BSD dill serialize all of python >=0.3.5.1 0.3.6 BSD-3-Clause dnspython DNS toolkit >=1.15.0 2.2.1 ISC dynaconf The dynamic configurator for your Python Project >=3.1.11 3.1.11 MIT editables Editable installations >=0.3 0.3 MIT eval-pipeline evaluation pipeline @ file:///${PROJECT_ROOT}/eval_pipeline unknown ? eventlet Highly concurrent networking library >=0.33.1 0.33.1 MIT License flask A simple framework for building complex web applications. >=2.2.2 2.2.2 BSD-3-Clause flask-socketio Socket.IO integration for Flask applications >=5.3.1 5.3.1 MIT License fonttools Tools to manipulate font files >=4.22.0 4.38.0 MIT gprof2dot Generate a dot graph from the output of several profilers. >=2022.7.29 2022.7.29 LGPL graphviz Simple Python interface for Graphviz >=0.20.1 0.20.1 MIT greenlet Lightweight in-process concurrent programming >=0.3 2.0.0 MIT License igraph High performance graph data structures and algorithms ==0.10.2 0.10.2 GNU General Public License (GPL) itsdangerous Safely pass data to untrusted environments and back. >=2.0 2.1.2 BSD-3-Clause jinja2 A very fast and expressive template engine. >=3.0 3.1.2 BSD-3-Clause joblib Lightweight pipelining with Python functions >=1.0.0 1.2.0 BSD kiwisolver A fast implementation of the Cassowary constraint solver >=1.0.1 1.4.4 BSD License markupsafe Safely add untrusted strings to HTML/XML markup. >=2.0 2.1.1 BSD-3-Clause matplotlib Python plotting package >=3.6.1 3.6.1 PSF numpy NumPy is the fundamental package for array computing with Python. >=1.9.0 1.23.4 BSD packaging Core utilities for Python packages >=20.0 21.3 BSD-2-Clause or Apache-2.0 pillow Python Imaging Library (Fork) >=6.2.0 9.3.0 HPND pydot Python interface to Graphviz's Dot >=1.4.2 1.4.2 MIT pyparsing pyparsing module - Classes and methods to define and execute parsing grammars >=2.2.1 3.0.9 MIT License python-dateutil Extensions to the standard Python datetime module >=2.7 2.8.2 Dual License python-engineio Engine.IO server and client for Python >=4.3.0 4.3.4 MIT License python-igraph High performance graph data structures and algorithms (legacy package) >=0.10.2 0.10.2 GNU General Public License (GPL) python-socketio Socket.IO server and client for Python >=5.0.2 5.7.2 MIT License scikit-learn A set of python modules for machine learning and data mining >=1.1.2 1.1.3 new BSD scipy Fundamental algorithms for scientific computing in Python >=1.9.3 1.9.3 BSD License six Python 2 and 3 compatibility utilities >=1.10.0 1.16.0 MIT texttable module for creating simple ASCII tables >=1.6.2 1.6.4 MIT threadpoolctl threadpoolctl >=2.0.0 3.1.0 BSD-3-Clause werkzeug The comprehensive WSGI web application library. >=2.2.2 2.2.2 BSD-3-Clause Development dependencies \u00b6 Project Summary Version (accepted) Version (last resolved) License ansimarkup Produce colored terminal text with an xml-like markup ~=1.4 1.5.0 Revised BSD License astor Read/rewrite/write Python ASTs >=0.8 0.8.1 BSD-3-Clause attrs Classes Without Boilerplate >=19.2.0 22.1.0 MIT autoflake Removes unused imports and unused variables >=1.4 1.7.7 MIT bandit Security oriented static analyser for python code. >=1.7.3 1.7.4 Apache-2.0 license black The uncompromising code formatter. >=21.10b0 22.10.0 MIT License certifi Python package for providing Mozilla's CA Bundle. >=2017.4.17 2022.9.24 MPL-2.0 charset-normalizer The Real First Universal Charset Detector. Open, modern and actively maintained alternative to Chardet. <3,>=2 2.1.1 MIT click Composable command line interface toolkit >=8.0.0 8.1.3 BSD-3-Clause colorama Cross-platform colored terminal text. ; platform_system == \"Windows\" 0.4.6 BSD License coverage Code coverage measurement for Python [toml]>=5.2.1 6.5.0 Apache 2.0 darglint A utility for ensuring Google-style docstrings stay up to date with the source code. >=1.8 1.8.1 MIT dparse A parser for Python dependency files >=0.6.2 0.6.2 MIT license duty A simple task runner. >=0.7 0.7.0 Other/Proprietary License exceptiongroup Backport of PEP 654 (exception groups) >=1.0.0rc8; python_version < \"3.11\" 1.0.0 MIT License execnet execnet: rapid multi-Python deployment >=1.1 1.9.0 MIT failprint Run a command, print its output only if it fails. ~=0.8 0.8.0 Other/Proprietary License flake8 the modular source code checker: pep8 pyflakes and co <4 3.9.2 MIT flake8-bandit Automated security testing with bandit and flake8. >=2.1 3.0.0 MIT flake8-black flake8 plugin to call black as a code style validator >=0.2 0.3.3 MIT flake8-bugbear A plugin for flake8 finding likely bugs and design problems in your program. Contains warnings that don't belong in pyflakes and pycodestyle. >=21.9 22.10.27 MIT flake8-builtins Check for python builtins being used as variables or parameters. >=1.5 2.0.1 GPL version 2 flake8-comprehensions A flake8 plugin to help you write better list/set/dict comprehensions. >=3.7 3.10.1 MIT flake8-docstrings Extension for flake8 which uses pydocstyle to check docstrings >=1.6 1.6.0 MIT License flake8-plugin-utils The package provides base classes and utils for flake8 plugin writing <2.0.0,>=1.3.2 1.3.2 MIT flake8-polyfill Polyfill package for Flake8 plugins 1.0.2 MIT flake8-pytest-style A flake8 plugin checking common style issues or inconsistencies with pytest-based tests. >=1.5 1.6.0 MIT flake8-string-format string format checker, plugin for flake8 >=0.3 0.3.0 MIT License flake8-tidy-imports A flake8 plugin that helps you write tidier imports. >=4.5 4.8.0 MIT flake8-variables-names A flake8 extension that helps to make more readable variables names >=0.0 0.0.5 MIT ghp-import Copy your docs directly to the gh-pages branch. >=1.0 2.1.0 Apache Software License git-changelog Automatic Changelog generator using Jinja2 templates. >=0.4 0.6.0 ISC gitdb Git Object Database <5,>=4.0.1 4.0.9 BSD License gitpython GitPython is a python library used to interact with Git repositories >=1.0.1 3.1.29 BSD griffe Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API. >=0.11.1 0.23.0 ISC idna Internationalized Domain Names in Applications (IDNA) <4,>=2.5 3.4 BSD License iniconfig iniconfig: brain-dead simple config-ini parsing 1.1.1 MIT License isort A Python utility / library to sort Python imports. >=5.10 5.10.1 MIT jinja2 A very fast and expressive template engine. <4,>=2.11 3.1.2 BSD-3-Clause markdown Python implementation of Markdown. <4.0.0,>=3.3.3 3.3.7 BSD License markdown-callouts Markdown extension: a classier syntax for admonitions >=0.2 0.3.0 MIT markdown-exec Utilities to execute code blocks in Markdown files. >=0.5 0.7.2 ISC markupsafe Safely add untrusted strings to HTML/XML markup. >=2.0 2.1.1 BSD-3-Clause mccabe McCabe checker, plugin for flake8 <0.7.0,>=0.6.0 0.6.1 Expat license mergedeep A deep merge function for \ud83d\udc0d. >=1.3.4 1.3.4 MIT License mkdocs Project documentation with Markdown. >=1.3 1.4.2 BSD License mkdocs-coverage MkDocs plugin to integrate your coverage HTML report into your site. >=0.2 0.2.5 ISC License (ISCL) mkdocs-gen-files MkDocs plugin to programmatically generate documentation pages during the build >=0.3 0.4.0 MIT mkdocs-literate-nav MkDocs plugin to specify the navigation in Markdown instead of YAML >=0.4 0.5.0 MIT mkdocs-material Documentation that simply works >=7.3 8.5.7 MIT License mkdocs-material-extensions Extension pack for Python Markdown and MkDocs Material. >=1.0.3 1.1 MIT License mkdocs-section-index MkDocs plugin to allow clickable sections that lead to an index page >=0.3 0.3.4 MIT mkdocstrings Automatic documentation from sources, for MkDocs. [python]>=0.18 0.19.0 ISC License (ISCL) mkdocstrings-python A Python handler for mkdocstrings. >=0.5.2 0.7.1 ISC mypy Optional static typing for Python >=0.910 0.982 MIT License mypy-extensions Experimental type system extensions for programs checked with the mypy typechecker. >=0.4.3 0.4.3 MIT License packaging Core utilities for Python packages >=20.5 21.3 BSD-2-Clause or Apache-2.0 pathspec Utility library for gitignore style pattern matching of file paths. >=0.9.0 0.10.1 MPL 2.0 pbr Python Build Reasonableness !=2.1.0,>=2.0.0 5.11.0 Apache Software License pep8-naming Check PEP-8 naming conventions, plugin for flake8 >=0.12 0.13.2 Expat license platformdirs A small Python module for determining appropriate platform-specific dirs, e.g. a \"user data dir\". >=2 2.5.2 MIT License pluggy plugin and hook calling mechanisms for python <2.0,>=0.12 1.0.0 MIT ptyprocess Run a subprocess in a pseudo terminal ~=0.6; sys_platform != \"win32\" 0.7.0 ISC License (ISCL) pycodestyle Python style guide checker <2.8.0,>=2.7.0 2.7.0 Expat license pydocstyle Python docstring style checker >=2.1 6.1.1 MIT pyflakes passive checker of Python programs >=1.1.0 2.3.1 MIT pygments Pygments is a syntax highlighting package written in Python. >=2.12 2.13.0 BSD License pymdown-extensions Extension pack for Python Markdown. >=9 9.7 MIT License pyparsing pyparsing module - Classes and methods to define and execute parsing grammars !=3.0.5,>=2.0.2 3.0.9 MIT License pytest pytest: simple powerful testing with Python >=6.2 7.2.0 MIT pytest-cov Pytest plugin for measuring coverage. >=3.0 4.0.0 MIT pytest-randomly Pytest plugin to randomly order tests and control random.seed. >=3.10 3.12.0 MIT pytest-xdist pytest xdist plugin for distributed testing and loop-on-failing modes >=2.4 3.0.2 MIT python-dateutil Extensions to the standard Python datetime module >=2.8.1 2.8.2 Dual License pyyaml YAML parser and emitter for Python >=5.1 6.0 MIT pyyaml-env-tag A custom YAML tag for referencing environment variables in YAML files. >=0.1 0.1 MIT License requests Python HTTP for Humans. >=2.26 2.28.1 Apache 2.0 ruamel.yaml ruamel.yaml is a YAML parser/emitter that supports roundtrip preservation of comments, seq/map flow style, and map key order >=0.17.21 0.17.21 MIT license ruamel.yaml.clib C version of reader, parser and emitter for ruamel.yaml derived from libyaml >=0.2.6; platform_python_implementation == \"CPython\" and python_version < \"3.11\" 0.2.7 MIT safety Checks installed dependencies for known vulnerabilities and licenses. >=2 2.3.1 MIT license semver Python helper for Semantic Versioning (http://semver.org/) ~=2.13 2.13.0 BSD setuptools Easily download, build, install, upgrade, and uninstall Python packages >=19.3 65.5.0 MIT License six Python 2 and 3 compatibility utilities >=1.5 1.16.0 MIT smmap A pure Python implementation of a sliding window memory map manager <6,>=3.0.1 5.0.0 BSD snowballstemmer This package provides 29 stemmers for 28 languages generated from Snowball algorithms. 2.2.0 BSD-3-Clause stevedore Manage dynamic plugins for Python applications >=1.20.0 4.1.0 Apache Software License toml Python Library for Tom's Obvious, Minimal Language >=0.10 0.10.2 MIT tomli A lil' TOML parser >=2.0.1; python_version < \"3.11\" 2.0.1 MIT License types-markdown Typing stubs for Markdown >=3.3 3.4.2.1 Apache-2.0 license types-toml Typing stubs for toml >=0.10 0.10.8 Apache-2.0 license typing-extensions Backported and Experimental Type Hints for Python 3.7+ >=3.10 4.4.0 Python Software Foundation License urllib3 HTTP library with thread-safe connection pooling, file post, and more. <1.27,>=1.21.1 1.26.12 MIT watchdog Filesystem events monitoring >=2.0 2.1.9 Apache License 2.0 wps-light The strictest and most opinionated python linter ever (lighter fork). >=0.15 0.16.1 MIT","title":"Credits"},{"location":"license/","text":"ISC License Copyright (c) 2021, LOGiCS Team Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies. THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.","title":"License"},{"location":"reference/SUMMARY/","text":"backend app operations rating shared paths sym_cps classifier cli control database tools update_database evaluation cli tools examples build_uav control custom_design design_swri designs evaluation library parameter topology topology_3 grammar tools topology hci optimizers concrete_opt control_opt control_opt_base control_opt_bayes control_opt_grid control_opt_interface fdm_data fdm_interface fdm_ret optimizer params_opt optimizer param_opt_problem tools optimization bayesian_opt_visualizer bayesian_optimizer cem_optimizer nm_optimizer optimizer_base problem_base test_optimization test_bayesian_opt util exceptions history surrogate visualize topo_opt representation design concrete elements component connection design_parameters parameter tools topology library elements c_connector c_parameter c_property c_type library_component tools analyze connectors dictionaries export design_swri ids parameters_analysis parsers learn_from_designs parse parsing_designs parsing_library temp_objects shared designs library objects paths tools io persistance strings update_library","title":"SUMMARY"},{"location":"reference/backend/","text":"","title":"backend"},{"location":"reference/backend/app/","text":"check_if_session_exist ( session_id ) \u00b6 Check if a session is free and if the user can enter it. Parameters: Name Type Description Default session_id str the id of the wanted session. required Source code in backend/app.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 @socketio . on ( \"session-existing\" ) def check_if_session_exist ( session_id : str ) -> None : \"\"\"Check if a session is free and if the user can enter it. Arguments: session_id: the id of the wanted session. \"\"\" tab_id = str ( request . args . get ( \"tabId\" )) cookie = str ( request . args . get ( \"cookie\" )) print ( \"check if following session exists : \" + session_id ) dir_path , dir_names , filenames = next ( walk ( storage_path )) found = False sessions_folder = f \"s_\" + session_id for dir_name in dir_names : if dir_name == sessions_folder : found = True if session_id == \"default\" or session_id == \"contracts\" : found = False if found : if session_id in users and cookie != cookies [ session_id ]: found = False print ( f \"users : { users } \" ) emit ( \"receive-answer\" , found , room = users [ str ( request . args . get ( \"id\" ))][ tab_id ]) connected () \u00b6 Establish the connection between the front and the back while checking that the session is not already in use. Source code in backend/app.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @socketio . on ( \"connect\" ) def connected () -> None : \"\"\"Establish the connection between the front and the back while checking that the session is not already in use.\"\"\" print ( \"Connected\" ) print ( f 'ID { request . args . get ( \"id\" ) } ' ) lock = threading . Lock () lock . acquire () session_id = str ( request . args . get ( \"id\" )) cookie = str ( request . args . get ( \"cookie\" )) tab_id = str ( request . args . get ( \"tabId\" )) if session_id in users : # Check if this session is already open if cookie != cookies [ session_id ]: emit ( \"is-connected\" , False , room = request . sid ) return else : users [ session_id ] = {} users [ session_id ][ tab_id ] = request . sid cookies [ session_id ] = cookie now = time . localtime ( time . time ()) emit ( \"send-message\" , strftime ( \"%H:%M:%S\" , now ) + f \" Connected to session { request . args . get ( 'id' ) } \" , room = request . sid ) emit ( \"is-connected\" , True , room = request . sid ) lock . release () create_design ( data ) \u00b6 Create the design and the mealy according to the strategy indicated Parameters: Name Type Description Default data Dict A dictionary that contains all the information about the synthesis that will be created. required Source code in backend/app.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 @socketio . on ( \"create-design\" ) def create_design ( data : Dict ) -> None : \"\"\"Create the design and the mealy according to the strategy indicated Arguments: data: A dictionary that contains all the information about the synthesis that will be created. \"\"\" print ( f \"create-design received with { data } \" ) try : json_content = Rating . generate_design ( data , request . args . get ( \"id\" )) send_message_to_user ( f \"The mealy has been created using { data [ 'strategy' ] } method\" , request . sid , \"success\" ) emit ( \"design-created\" , json_content , room = request . sid ) except Exception as e : emit ( \"design-created\" , False , room = request . sid ) emit ( \"send-notification\" , { \"content\" : \"The mealy creation has failed. See the console for more information\" , \"crometypes\" : \"error\" }, room = request . sid , ) emit ( \"send-message\" , f \"Mealy \\\" { data [ 'name' ] } \\\" can't be created. Error : { str ( e ) } \" , room = request . sid ) disconnected () \u00b6 It disconnects the user of the session he was attached to. Source code in backend/app.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 @socketio . on ( \"disconnect\" ) def disconnected () -> None : \"\"\"It disconnects the user of the session he was attached to.\"\"\" print ( \"Disconnected\" ) print ( request . args ) print ( f 'ID { request . args . get ( \"id\" ) } ' ) session_id = str ( request . args . get ( \"id\" )) tab_id = str ( request . args . get ( \"tabId\" )) if session_id in users and tab_id in users [ session_id ]: now = time . localtime ( time . time ()) emit ( \"send-message\" , f \" { strftime ( '%H:%M:%S' , now ) } Session { request . args . get ( 'id' ) } disconnected\" , room = request . sid , ) del users [ session_id ][ tab_id ] send_message_to_user ( content , room_id , crometype ) \u00b6 Simplified version to send a notification and a message to a user. Parameters: Name Type Description Default content str The content of the message. required room_id str Where to send the notification and the message. required crometype str The type of notification to send. required Source code in backend/app.py 122 123 124 125 126 127 128 129 130 131 132 def send_message_to_user ( content : str , room_id : str , crometype : str ) -> None : \"\"\"Simplified version to send a notification and a message to a user. Arguments: content: The content of the message. room_id: Where to send the notification and the message. crometype: The type of notification to send. \"\"\" now = time . localtime ( time . time ()) emit ( \"send-notification\" , { \"crometypes\" : crometype , \"content\" : content }, room = room_id ) emit ( \"send-message\" , f \" { strftime ( '%H:%M:%S' , now ) } - { content } \" , room = room_id )","title":"app"},{"location":"reference/backend/app/#backend.app.check_if_session_exist","text":"Check if a session is free and if the user can enter it. Parameters: Name Type Description Default session_id str the id of the wanted session. required Source code in backend/app.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 @socketio . on ( \"session-existing\" ) def check_if_session_exist ( session_id : str ) -> None : \"\"\"Check if a session is free and if the user can enter it. Arguments: session_id: the id of the wanted session. \"\"\" tab_id = str ( request . args . get ( \"tabId\" )) cookie = str ( request . args . get ( \"cookie\" )) print ( \"check if following session exists : \" + session_id ) dir_path , dir_names , filenames = next ( walk ( storage_path )) found = False sessions_folder = f \"s_\" + session_id for dir_name in dir_names : if dir_name == sessions_folder : found = True if session_id == \"default\" or session_id == \"contracts\" : found = False if found : if session_id in users and cookie != cookies [ session_id ]: found = False print ( f \"users : { users } \" ) emit ( \"receive-answer\" , found , room = users [ str ( request . args . get ( \"id\" ))][ tab_id ])","title":"check_if_session_exist()"},{"location":"reference/backend/app/#backend.app.connected","text":"Establish the connection between the front and the back while checking that the session is not already in use. Source code in backend/app.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @socketio . on ( \"connect\" ) def connected () -> None : \"\"\"Establish the connection between the front and the back while checking that the session is not already in use.\"\"\" print ( \"Connected\" ) print ( f 'ID { request . args . get ( \"id\" ) } ' ) lock = threading . Lock () lock . acquire () session_id = str ( request . args . get ( \"id\" )) cookie = str ( request . args . get ( \"cookie\" )) tab_id = str ( request . args . get ( \"tabId\" )) if session_id in users : # Check if this session is already open if cookie != cookies [ session_id ]: emit ( \"is-connected\" , False , room = request . sid ) return else : users [ session_id ] = {} users [ session_id ][ tab_id ] = request . sid cookies [ session_id ] = cookie now = time . localtime ( time . time ()) emit ( \"send-message\" , strftime ( \"%H:%M:%S\" , now ) + f \" Connected to session { request . args . get ( 'id' ) } \" , room = request . sid ) emit ( \"is-connected\" , True , room = request . sid ) lock . release ()","title":"connected()"},{"location":"reference/backend/app/#backend.app.create_design","text":"Create the design and the mealy according to the strategy indicated Parameters: Name Type Description Default data Dict A dictionary that contains all the information about the synthesis that will be created. required Source code in backend/app.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 @socketio . on ( \"create-design\" ) def create_design ( data : Dict ) -> None : \"\"\"Create the design and the mealy according to the strategy indicated Arguments: data: A dictionary that contains all the information about the synthesis that will be created. \"\"\" print ( f \"create-design received with { data } \" ) try : json_content = Rating . generate_design ( data , request . args . get ( \"id\" )) send_message_to_user ( f \"The mealy has been created using { data [ 'strategy' ] } method\" , request . sid , \"success\" ) emit ( \"design-created\" , json_content , room = request . sid ) except Exception as e : emit ( \"design-created\" , False , room = request . sid ) emit ( \"send-notification\" , { \"content\" : \"The mealy creation has failed. See the console for more information\" , \"crometypes\" : \"error\" }, room = request . sid , ) emit ( \"send-message\" , f \"Mealy \\\" { data [ 'name' ] } \\\" can't be created. Error : { str ( e ) } \" , room = request . sid )","title":"create_design()"},{"location":"reference/backend/app/#backend.app.disconnected","text":"It disconnects the user of the session he was attached to. Source code in backend/app.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 @socketio . on ( \"disconnect\" ) def disconnected () -> None : \"\"\"It disconnects the user of the session he was attached to.\"\"\" print ( \"Disconnected\" ) print ( request . args ) print ( f 'ID { request . args . get ( \"id\" ) } ' ) session_id = str ( request . args . get ( \"id\" )) tab_id = str ( request . args . get ( \"tabId\" )) if session_id in users and tab_id in users [ session_id ]: now = time . localtime ( time . time ()) emit ( \"send-message\" , f \" { strftime ( '%H:%M:%S' , now ) } Session { request . args . get ( 'id' ) } disconnected\" , room = request . sid , ) del users [ session_id ][ tab_id ]","title":"disconnected()"},{"location":"reference/backend/app/#backend.app.send_message_to_user","text":"Simplified version to send a notification and a message to a user. Parameters: Name Type Description Default content str The content of the message. required room_id str Where to send the notification and the message. required crometype str The type of notification to send. required Source code in backend/app.py 122 123 124 125 126 127 128 129 130 131 132 def send_message_to_user ( content : str , room_id : str , crometype : str ) -> None : \"\"\"Simplified version to send a notification and a message to a user. Arguments: content: The content of the message. room_id: Where to send the notification and the message. crometype: The type of notification to send. \"\"\" now = time . localtime ( time . time ()) emit ( \"send-notification\" , { \"crometypes\" : crometype , \"content\" : content }, room = room_id ) emit ( \"send-message\" , f \" { strftime ( '%H:%M:%S' , now ) } - { content } \" , room = room_id )","title":"send_message_to_user()"},{"location":"reference/backend/operations/","text":"","title":"operations"},{"location":"reference/backend/operations/rating/","text":"Rating \u00b6 Class that has all the useful functions to synthesis a design. Source code in backend/operations/rating.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Rating : \"\"\"Class that has all the useful functions to synthesis a design.\"\"\" @staticmethod def generate_design ( data : dict , session_id : str ) -> str : \"\"\"Create a design from a synthesis. Arguments: session_id: The id of the session where the design is saved. data: A dictionary that contains all the information of the design generation. Returns: The mealy machine that is/are the representation of the design. \"\"\" full_name = data [ \"name\" ] if data [ \"strategy\" ] == \"strategy_random\" : from backend.app import topo_opt d_topology : DTopology = topo_opt . generate_topology ( name = full_name , strategy = TopologyStrategy . random_strategy ) print ( \"****D_TOPOLOGY****\" ) print ( d_topology ) d_topology . export ( ExportType . TXT ) d_topology . export ( ExportType . DOT ) d_topology . export ( ExportType . DOT ) \"\"\"TODO: SEND THE DOT (GRAPHVIZ) TO THE FRONT END AND VISUALIZE IT https://github.com/magjac/graphviz-visual-editor https://github.com/DomParfitt/graphviz-react https://www.npmjs.com/package/graphviz-react .... etc.. \"\"\" return \"...GRAPHVIZ DOT GRAPH....\" generate_design ( data , session_id ) staticmethod \u00b6 Create a design from a synthesis. Parameters: Name Type Description Default session_id str The id of the session where the design is saved. required data dict A dictionary that contains all the information of the design generation. required Returns: Type Description str The mealy machine that is/are the representation of the design. Source code in backend/operations/rating.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 @staticmethod def generate_design ( data : dict , session_id : str ) -> str : \"\"\"Create a design from a synthesis. Arguments: session_id: The id of the session where the design is saved. data: A dictionary that contains all the information of the design generation. Returns: The mealy machine that is/are the representation of the design. \"\"\" full_name = data [ \"name\" ] if data [ \"strategy\" ] == \"strategy_random\" : from backend.app import topo_opt d_topology : DTopology = topo_opt . generate_topology ( name = full_name , strategy = TopologyStrategy . random_strategy ) print ( \"****D_TOPOLOGY****\" ) print ( d_topology ) d_topology . export ( ExportType . TXT ) d_topology . export ( ExportType . DOT ) d_topology . export ( ExportType . DOT ) \"\"\"TODO: SEND THE DOT (GRAPHVIZ) TO THE FRONT END AND VISUALIZE IT https://github.com/magjac/graphviz-visual-editor https://github.com/DomParfitt/graphviz-react https://www.npmjs.com/package/graphviz-react .... etc.. \"\"\" return \"...GRAPHVIZ DOT GRAPH....\"","title":"rating"},{"location":"reference/backend/operations/rating/#backend.operations.rating.Rating","text":"Class that has all the useful functions to synthesis a design. Source code in backend/operations/rating.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Rating : \"\"\"Class that has all the useful functions to synthesis a design.\"\"\" @staticmethod def generate_design ( data : dict , session_id : str ) -> str : \"\"\"Create a design from a synthesis. Arguments: session_id: The id of the session where the design is saved. data: A dictionary that contains all the information of the design generation. Returns: The mealy machine that is/are the representation of the design. \"\"\" full_name = data [ \"name\" ] if data [ \"strategy\" ] == \"strategy_random\" : from backend.app import topo_opt d_topology : DTopology = topo_opt . generate_topology ( name = full_name , strategy = TopologyStrategy . random_strategy ) print ( \"****D_TOPOLOGY****\" ) print ( d_topology ) d_topology . export ( ExportType . TXT ) d_topology . export ( ExportType . DOT ) d_topology . export ( ExportType . DOT ) \"\"\"TODO: SEND THE DOT (GRAPHVIZ) TO THE FRONT END AND VISUALIZE IT https://github.com/magjac/graphviz-visual-editor https://github.com/DomParfitt/graphviz-react https://www.npmjs.com/package/graphviz-react .... etc.. \"\"\" return \"...GRAPHVIZ DOT GRAPH....\"","title":"Rating"},{"location":"reference/backend/operations/rating/#backend.operations.rating.Rating.generate_design","text":"Create a design from a synthesis. Parameters: Name Type Description Default session_id str The id of the session where the design is saved. required data dict A dictionary that contains all the information of the design generation. required Returns: Type Description str The mealy machine that is/are the representation of the design. Source code in backend/operations/rating.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 @staticmethod def generate_design ( data : dict , session_id : str ) -> str : \"\"\"Create a design from a synthesis. Arguments: session_id: The id of the session where the design is saved. data: A dictionary that contains all the information of the design generation. Returns: The mealy machine that is/are the representation of the design. \"\"\" full_name = data [ \"name\" ] if data [ \"strategy\" ] == \"strategy_random\" : from backend.app import topo_opt d_topology : DTopology = topo_opt . generate_topology ( name = full_name , strategy = TopologyStrategy . random_strategy ) print ( \"****D_TOPOLOGY****\" ) print ( d_topology ) d_topology . export ( ExportType . TXT ) d_topology . export ( ExportType . DOT ) d_topology . export ( ExportType . DOT ) \"\"\"TODO: SEND THE DOT (GRAPHVIZ) TO THE FRONT END AND VISUALIZE IT https://github.com/magjac/graphviz-visual-editor https://github.com/DomParfitt/graphviz-react https://www.npmjs.com/package/graphviz-react .... etc.. \"\"\" return \"...GRAPHVIZ DOT GRAPH....\"","title":"generate_design()"},{"location":"reference/backend/shared/","text":"","title":"shared"},{"location":"reference/backend/shared/paths/","text":"","title":"paths"},{"location":"reference/sym_cps/","text":"sym_cps package. Develop AI-based approaches to enable correct-by-construction design of Cyber Physical Systems","title":"sym_cps"},{"location":"reference/sym_cps/cli/","text":"Module that contains the command line application.","title":"cli"},{"location":"reference/sym_cps/classifier/","text":"","title":"classifier"},{"location":"reference/sym_cps/control/","text":"","title":"control"},{"location":"reference/sym_cps/database/","text":"","title":"database"},{"location":"reference/sym_cps/database/tools/","text":"","title":"tools"},{"location":"reference/sym_cps/database/tools/update_database/","text":"","title":"update_database"},{"location":"reference/sym_cps/evaluation/","text":"File adapted from: https://github.com/LOGiCS-Project/swri-simple-uam-example evaluate_design ( design_json_path , metadata = None , timeout = 800 , info_only = False , control_opt = False ) \u00b6 Evaluate a design_swri.json provided at location 'design_json_path' Metadata to include with the operation, becomes part of metadata.json in the result. Source code in sym_cps/evaluation/__init__.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def evaluate_design ( design_json_path : Path , metadata : Path | dict | None = None , timeout : int = 800 , info_only : bool = False , control_opt : bool = False , ): \"\"\"Evaluate a design_swri.json provided at location 'design_json_path' Metadata to include with the operation, becomes part of metadata.json in the result. \"\"\" print ( f \"Input file: { design_json_path } \" ) # Load the design from file print ( \"Loading Design\" ) design = load_design ( design_json_path ) # Load the metadata from file print ( \"Loading Metadata (if provided)\" ) metadata = load_metadata ( metadata ) # Send the design to worker print ( \"Sending Design to Broker\" ) if info_only : print ( \"Generating info...\" ) msg = direct2cad . gen_info_files . send ( design , metadata = metadata ) else : print ( \"Processing design...\" ) msg = direct2cad . process_design . send ( design , metadata = metadata ) print ( \"Waiting for results...\" ) result_path = polling_results ( msg , timeout ) print ( f \"Command completed. Results can be found at: { result_path } \" ) # Obtain information from the result foleder if not info_only : return extract_results ( result_path , control_opt = control_opt ) # return extract_results(\"/Users/shengjungyu/shengjungyu/Research/UC_Berkeley/Research/LOGiCS/workspace/berkeley-cps-symbiotic-design/output/aws/results/process_design-2022-10-07-fhudp1f5qz.zip\", control_opt = control_opt) else : return None","title":"evaluation"},{"location":"reference/sym_cps/evaluation/#sym_cps.evaluation.evaluate_design","text":"Evaluate a design_swri.json provided at location 'design_json_path' Metadata to include with the operation, becomes part of metadata.json in the result. Source code in sym_cps/evaluation/__init__.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def evaluate_design ( design_json_path : Path , metadata : Path | dict | None = None , timeout : int = 800 , info_only : bool = False , control_opt : bool = False , ): \"\"\"Evaluate a design_swri.json provided at location 'design_json_path' Metadata to include with the operation, becomes part of metadata.json in the result. \"\"\" print ( f \"Input file: { design_json_path } \" ) # Load the design from file print ( \"Loading Design\" ) design = load_design ( design_json_path ) # Load the metadata from file print ( \"Loading Metadata (if provided)\" ) metadata = load_metadata ( metadata ) # Send the design to worker print ( \"Sending Design to Broker\" ) if info_only : print ( \"Generating info...\" ) msg = direct2cad . gen_info_files . send ( design , metadata = metadata ) else : print ( \"Processing design...\" ) msg = direct2cad . process_design . send ( design , metadata = metadata ) print ( \"Waiting for results...\" ) result_path = polling_results ( msg , timeout ) print ( f \"Command completed. Results can be found at: { result_path } \" ) # Obtain information from the result foleder if not info_only : return extract_results ( result_path , control_opt = control_opt ) # return extract_results(\"/Users/shengjungyu/shengjungyu/Research/UC_Berkeley/Research/LOGiCS/workspace/berkeley-cps-symbiotic-design/output/aws/results/process_design-2022-10-07-fhudp1f5qz.zip\", control_opt = control_opt) else : return None","title":"evaluate_design()"},{"location":"reference/sym_cps/evaluation/cli/","text":"File adapted from: https://github.com/LOGiCS-Project/swri-simple-uam-example get_args () \u00b6 Creates a parser and returns the arguments for this utility. Source code in sym_cps/evaluation/cli.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def get_args (): \"\"\" Creates a parser and returns the arguments for this utility. \"\"\" parser = argparse . ArgumentParser ( description = \"Process a design\" ) parser . add_argument ( \"-results_dir\" , type = Path , help = \"The directory that will be checked when looking for new results.\" , ) parser . add_argument ( \"-design_file\" , type = Path , help = \"The design file to process\" , ) parser . add_argument ( \"-m\" , \"--metadata\" , default = None , help = \"Metadata to include with the operation, becomes part of metadata.json in the result.\" , ) parser . add_argument ( \"-c\" , \"--command\" , choices = [ \"info\" , \"process\" ], default = \"info\" , help = \"Which command to perform: 'info' = gen info files, 'process' = process design.\" , ) parser . add_argument ( \"-w\" , \"--watch\" , choices = [ \"best\" , \"backend\" , \"polling\" ], default = \"best\" , help = \"How to wait for results, via backend, polling, or best available.\" , ) parser . add_argument ( \"-t\" , \"--timeout\" , type = int , default = 600 , help = \"Timeout, in seconds, before giving up on the command.\" , ) return parser . parse_args ()","title":"cli"},{"location":"reference/sym_cps/evaluation/cli/#sym_cps.evaluation.cli.get_args","text":"Creates a parser and returns the arguments for this utility. Source code in sym_cps/evaluation/cli.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def get_args (): \"\"\" Creates a parser and returns the arguments for this utility. \"\"\" parser = argparse . ArgumentParser ( description = \"Process a design\" ) parser . add_argument ( \"-results_dir\" , type = Path , help = \"The directory that will be checked when looking for new results.\" , ) parser . add_argument ( \"-design_file\" , type = Path , help = \"The design file to process\" , ) parser . add_argument ( \"-m\" , \"--metadata\" , default = None , help = \"Metadata to include with the operation, becomes part of metadata.json in the result.\" , ) parser . add_argument ( \"-c\" , \"--command\" , choices = [ \"info\" , \"process\" ], default = \"info\" , help = \"Which command to perform: 'info' = gen info files, 'process' = process design.\" , ) parser . add_argument ( \"-w\" , \"--watch\" , choices = [ \"best\" , \"backend\" , \"polling\" ], default = \"best\" , help = \"How to wait for results, via backend, polling, or best available.\" , ) parser . add_argument ( \"-t\" , \"--timeout\" , type = int , default = 600 , help = \"Timeout, in seconds, before giving up on the command.\" , ) return parser . parse_args ()","title":"get_args()"},{"location":"reference/sym_cps/evaluation/tools/","text":"File adapted from: https://github.com/LOGiCS-Project/swri-simple-uam-example get_result_archive_path ( result , results_dir ) \u00b6 Get the name of the specific result archive from the backend produced result. Parameters: Name Type Description Default result object The result object returned by wait_on_result required results_dir Path The directory in which all the results will appear. required Source code in sym_cps/evaluation/tools.py 87 88 89 90 91 92 93 94 95 96 97 98 99 def get_result_archive_path ( result : object , results_dir : Path ) -> Path : \"\"\" Get the name of the specific result archive from the backend produced result. Arguments: result: The result object returned by `wait_on_result` results_dir: The directory in which all the results will appear. \"\"\" raw_path = Path ( result [ \"result_archive\" ]) return results_dir / raw_path . name get_zip_metadata ( zip_file ) \u00b6 Returns the contents of the zip's metadata.json, if it has one. Parameters: Name Type Description Default zip_file Path The part to the zip we're opening. required Source code in sym_cps/evaluation/tools.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def get_zip_metadata ( zip_file : Path ) -> Optional [ object ]: \"\"\" Returns the contents of the zip's metadata.json, if it has one. Arguments: zip_file: The part to the zip we're opening. \"\"\" # Open Zip file with zipfile . ZipFile ( zip_file ) as zip : meta_file = zipfile . Path ( zip ) / \"metadata.json\" # Check if `metadata.json` exists if not meta_file . exists () and meta_file . is_file (): print ( f \"Zip ' { str ( zip_file ) } ' has no metadata.json\" ) return None # If yes, decode its contents with meta_file . open ( \"r\" ) as meta : return json . load ( meta ) load_design ( design_file ) \u00b6 Loads a design from file. Parameters: Name Type Description Default design_file Path Path to the design file required Source code in sym_cps/evaluation/tools.py 17 18 19 20 21 22 23 24 25 def load_design ( design_file : Path ) -> object : \"\"\" Loads a design from file. Arguments: design_file: Path to the design file \"\"\" with Path ( design_file ) . open ( \"r\" ) as fp : return json . load ( fp ) load_metadata ( metadata_file ) \u00b6 Loads metadata from file. This can be any arbitrary dictionary and its contents will appear in the result archive's metadata.json. Useful for keeping track of where each call comes from in a larger optimization process. Parameters: Name Type Description Default metadata_file Union [ Path , str , None] Path to the metadata file required Source code in sym_cps/evaluation/tools.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def load_metadata ( metadata_file : Union [ Path , str , None ]) -> dict : \"\"\" Loads metadata from file. This can be any arbitrary dictionary and its contents will appear in the result archive's metadata.json. Useful for keeping track of where each call comes from in a larger optimization process. Arguments: metadata_file: Path to the metadata file \"\"\" if not metadata_file : return dict () if isinstance ( metadata_file , dict ): return metadata_file with Path ( metadata_file ) . open ( \"r\" ) as fp : meta = json . load ( fp ) if not isinstance ( meta , dict ): raise RuntimeError ( \"Metadata must be JSON serializable dictionary.\" ) return meta match_msg_to_zip ( msg , zip_file ) \u00b6 Checks whether the given message produced the given zip archive. Parameters: Name Type Description Default msg dramatiq . Message The dramatiq message we're checking against required zip_file Path The path to the zip we're verifying required Source code in sym_cps/evaluation/tools.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 def match_msg_to_zip ( msg : dramatiq . Message , zip_file : Path ) -> bool : \"\"\" Checks whether the given message produced the given zip archive. Arguments: msg: The dramatiq message we're checking against zip_file: The path to the zip we're verifying \"\"\" msg_id = msg . message_id metadata = get_zip_metadata ( zip_file ) return metadata and ( \"message_info\" in metadata ) and msg_id == metadata [ \"message_info\" ][ \"message_id\" ] wait_on_result ( msg , interval = 10 , timeout = 600 ) \u00b6 Uses the dramatiq backend mechanism to wait on a result from a worker. EXAMPLE ONLY: DO NOT USE IN PRODUCTION Parameters: Name Type Description Default msg dramatiq . Message The message from the dramatiq send call. required interval int The time, in seconds, to wait between each check of the backend. 10 timeout int The total time, in seconds, to wait for a result before giving up. 600 Source code in sym_cps/evaluation/tools.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def wait_on_result ( msg : dramatiq . Message , interval : int = 10 , timeout : int = 600 ) -> object : \"\"\" Uses the dramatiq backend mechanism to wait on a result from a worker. EXAMPLE ONLY: DO NOT USE IN PRODUCTION Arguments: msg: The message from the dramatiq send call. interval: The time, in seconds, to wait between each check of the backend. timeout: The total time, in seconds, to wait for a result before giving up. \"\"\" elapsed = 0 result = None # Loop until result found while not result : # Try to get Result try : print ( f \"Checking for result @ { elapsed } s\" ) result = msg . get_result ( block = False ) # If no result yet except dramatiq . results . ResultMissing as err : # Check if we're timed out if elapsed >= timeout : raise RuntimeError ( f \"No result found by { elapsed } s\" ) # Else wait another interval elapsed += interval time . sleep ( interval ) return result watch_results_dir ( msg , results_dir , interval = 10 , timeout = 600 ) \u00b6 Checks directory every interval to see if any of the zip files match the provided message. EXAMPLE ONLY: DO NOT USE IN PRODUCTION Parameters: Name Type Description Default msg dramatiq . Message The message we sent to the broker required results_dir Path dir to look for results archive in required interval int delay between each check of the results_dir 10 timeout int time to search for archive before giving up 600 Source code in sym_cps/evaluation/tools.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 def watch_results_dir ( msg : dramatiq . Message , results_dir : Path , interval : int = 10 , timeout : int = 600 ) -> Path : \"\"\" Checks directory every interval to see if any of the zip files match the provided message. EXAMPLE ONLY: DO NOT USE IN PRODUCTION Arguments: msg: The message we sent to the broker results_dir: dir to look for results archive in interval: delay between each check of the results_dir timeout: time to search for archive before giving up \"\"\" elapsed = 0 seen = dict () # Wait till we're out of time or have a result while elapsed <= timeout : print ( f \"Checking for result @ { elapsed } s\" ) for zip_file in results_dir . iterdir (): # Check if file is a valid zip valid_zip = zip_file . is_file () valid_zip = valid_zip and \".zip\" == zip_file . suffix valid_zip = valid_zip and zip_file not in seen # Skip further checks if not zip if not valid_zip : continue # return file if match found, else mark as seen. print ( f \"Checking zip file: { str ( zip_file ) } \" ) if match_msg_to_zip ( msg , zip_file ): return zip_file else : seen [ zip_file ] = True # Using seen as set # Wait for next interval elapsed += interval time . sleep ( interval ) raise RuntimeError ( f \"No result found by { elapsed } s\" )","title":"tools"},{"location":"reference/sym_cps/evaluation/tools/#sym_cps.evaluation.tools.get_result_archive_path","text":"Get the name of the specific result archive from the backend produced result. Parameters: Name Type Description Default result object The result object returned by wait_on_result required results_dir Path The directory in which all the results will appear. required Source code in sym_cps/evaluation/tools.py 87 88 89 90 91 92 93 94 95 96 97 98 99 def get_result_archive_path ( result : object , results_dir : Path ) -> Path : \"\"\" Get the name of the specific result archive from the backend produced result. Arguments: result: The result object returned by `wait_on_result` results_dir: The directory in which all the results will appear. \"\"\" raw_path = Path ( result [ \"result_archive\" ]) return results_dir / raw_path . name","title":"get_result_archive_path()"},{"location":"reference/sym_cps/evaluation/tools/#sym_cps.evaluation.tools.get_zip_metadata","text":"Returns the contents of the zip's metadata.json, if it has one. Parameters: Name Type Description Default zip_file Path The part to the zip we're opening. required Source code in sym_cps/evaluation/tools.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def get_zip_metadata ( zip_file : Path ) -> Optional [ object ]: \"\"\" Returns the contents of the zip's metadata.json, if it has one. Arguments: zip_file: The part to the zip we're opening. \"\"\" # Open Zip file with zipfile . ZipFile ( zip_file ) as zip : meta_file = zipfile . Path ( zip ) / \"metadata.json\" # Check if `metadata.json` exists if not meta_file . exists () and meta_file . is_file (): print ( f \"Zip ' { str ( zip_file ) } ' has no metadata.json\" ) return None # If yes, decode its contents with meta_file . open ( \"r\" ) as meta : return json . load ( meta )","title":"get_zip_metadata()"},{"location":"reference/sym_cps/evaluation/tools/#sym_cps.evaluation.tools.load_design","text":"Loads a design from file. Parameters: Name Type Description Default design_file Path Path to the design file required Source code in sym_cps/evaluation/tools.py 17 18 19 20 21 22 23 24 25 def load_design ( design_file : Path ) -> object : \"\"\" Loads a design from file. Arguments: design_file: Path to the design file \"\"\" with Path ( design_file ) . open ( \"r\" ) as fp : return json . load ( fp )","title":"load_design()"},{"location":"reference/sym_cps/evaluation/tools/#sym_cps.evaluation.tools.load_metadata","text":"Loads metadata from file. This can be any arbitrary dictionary and its contents will appear in the result archive's metadata.json. Useful for keeping track of where each call comes from in a larger optimization process. Parameters: Name Type Description Default metadata_file Union [ Path , str , None] Path to the metadata file required Source code in sym_cps/evaluation/tools.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def load_metadata ( metadata_file : Union [ Path , str , None ]) -> dict : \"\"\" Loads metadata from file. This can be any arbitrary dictionary and its contents will appear in the result archive's metadata.json. Useful for keeping track of where each call comes from in a larger optimization process. Arguments: metadata_file: Path to the metadata file \"\"\" if not metadata_file : return dict () if isinstance ( metadata_file , dict ): return metadata_file with Path ( metadata_file ) . open ( \"r\" ) as fp : meta = json . load ( fp ) if not isinstance ( meta , dict ): raise RuntimeError ( \"Metadata must be JSON serializable dictionary.\" ) return meta","title":"load_metadata()"},{"location":"reference/sym_cps/evaluation/tools/#sym_cps.evaluation.tools.match_msg_to_zip","text":"Checks whether the given message produced the given zip archive. Parameters: Name Type Description Default msg dramatiq . Message The dramatiq message we're checking against required zip_file Path The path to the zip we're verifying required Source code in sym_cps/evaluation/tools.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 def match_msg_to_zip ( msg : dramatiq . Message , zip_file : Path ) -> bool : \"\"\" Checks whether the given message produced the given zip archive. Arguments: msg: The dramatiq message we're checking against zip_file: The path to the zip we're verifying \"\"\" msg_id = msg . message_id metadata = get_zip_metadata ( zip_file ) return metadata and ( \"message_info\" in metadata ) and msg_id == metadata [ \"message_info\" ][ \"message_id\" ]","title":"match_msg_to_zip()"},{"location":"reference/sym_cps/evaluation/tools/#sym_cps.evaluation.tools.wait_on_result","text":"Uses the dramatiq backend mechanism to wait on a result from a worker. EXAMPLE ONLY: DO NOT USE IN PRODUCTION Parameters: Name Type Description Default msg dramatiq . Message The message from the dramatiq send call. required interval int The time, in seconds, to wait between each check of the backend. 10 timeout int The total time, in seconds, to wait for a result before giving up. 600 Source code in sym_cps/evaluation/tools.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def wait_on_result ( msg : dramatiq . Message , interval : int = 10 , timeout : int = 600 ) -> object : \"\"\" Uses the dramatiq backend mechanism to wait on a result from a worker. EXAMPLE ONLY: DO NOT USE IN PRODUCTION Arguments: msg: The message from the dramatiq send call. interval: The time, in seconds, to wait between each check of the backend. timeout: The total time, in seconds, to wait for a result before giving up. \"\"\" elapsed = 0 result = None # Loop until result found while not result : # Try to get Result try : print ( f \"Checking for result @ { elapsed } s\" ) result = msg . get_result ( block = False ) # If no result yet except dramatiq . results . ResultMissing as err : # Check if we're timed out if elapsed >= timeout : raise RuntimeError ( f \"No result found by { elapsed } s\" ) # Else wait another interval elapsed += interval time . sleep ( interval ) return result","title":"wait_on_result()"},{"location":"reference/sym_cps/evaluation/tools/#sym_cps.evaluation.tools.watch_results_dir","text":"Checks directory every interval to see if any of the zip files match the provided message. EXAMPLE ONLY: DO NOT USE IN PRODUCTION Parameters: Name Type Description Default msg dramatiq . Message The message we sent to the broker required results_dir Path dir to look for results archive in required interval int delay between each check of the results_dir 10 timeout int time to search for archive before giving up 600 Source code in sym_cps/evaluation/tools.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 def watch_results_dir ( msg : dramatiq . Message , results_dir : Path , interval : int = 10 , timeout : int = 600 ) -> Path : \"\"\" Checks directory every interval to see if any of the zip files match the provided message. EXAMPLE ONLY: DO NOT USE IN PRODUCTION Arguments: msg: The message we sent to the broker results_dir: dir to look for results archive in interval: delay between each check of the results_dir timeout: time to search for archive before giving up \"\"\" elapsed = 0 seen = dict () # Wait till we're out of time or have a result while elapsed <= timeout : print ( f \"Checking for result @ { elapsed } s\" ) for zip_file in results_dir . iterdir (): # Check if file is a valid zip valid_zip = zip_file . is_file () valid_zip = valid_zip and \".zip\" == zip_file . suffix valid_zip = valid_zip and zip_file not in seen # Skip further checks if not zip if not valid_zip : continue # return file if match found, else mark as seen. print ( f \"Checking zip file: { str ( zip_file ) } \" ) if match_msg_to_zip ( msg , zip_file ): return zip_file else : seen [ zip_file ] = True # Using seen as set # Wait for next interval elapsed += interval time . sleep ( interval ) raise RuntimeError ( f \"No result found by { elapsed } s\" )","title":"watch_results_dir()"},{"location":"reference/sym_cps/examples/","text":"","title":"examples"},{"location":"reference/sym_cps/examples/build_uav/","text":"","title":"build_uav"},{"location":"reference/sym_cps/examples/control/","text":"control_opt ( design_name = 'TestQuad' , designs_dat_file = 'designs.dat' ) \u00b6 Get a design concrete Source code in sym_cps/examples/control.py 18 19 20 21 22 23 24 def control_opt ( design_name : str = \"TestQuad\" , designs_dat_file : str = \"designs.dat\" ): \"\"\"Get a design concrete\"\"\" design_concrete : DConcrete = designs [ design_name ][ 0 ] \"\"\"Call the optimizer\"\"\" result : DConcrete = cont_opt . optimize ( d_concrete = design_concrete )","title":"control"},{"location":"reference/sym_cps/examples/control/#sym_cps.examples.control.control_opt","text":"Get a design concrete Source code in sym_cps/examples/control.py 18 19 20 21 22 23 24 def control_opt ( design_name : str = \"TestQuad\" , designs_dat_file : str = \"designs.dat\" ): \"\"\"Get a design concrete\"\"\" design_concrete : DConcrete = designs [ design_name ][ 0 ] \"\"\"Call the optimizer\"\"\" result : DConcrete = cont_opt . optimize ( d_concrete = design_concrete )","title":"control_opt()"},{"location":"reference/sym_cps/examples/custom_design/","text":"","title":"custom_design"},{"location":"reference/sym_cps/examples/design_swri/","text":"Generate design swri files for all designs in the library","title":"design_swri"},{"location":"reference/sym_cps/examples/designs/","text":"export_design_json ( design_name = 'Trowel' , designs_dat_file = 'designs.dat' ) \u00b6 Produce the json file representing the design Source code in sym_cps/examples/designs.py 13 14 15 16 17 18 19 20 21 22 23 24 def export_design_json ( design_name : str = \"Trowel\" , designs_dat_file : str = \"designs.dat\" ): \"\"\"Produce the json file representing the design\"\"\" designs : dict [ str , tuple [ DConcrete , DTopology ]] = load ( designs_dat_file ) # type: ignore d_concrete = designs [ design_name ][ 0 ] save_to_file ( str ( json . dumps ( d_concrete . to_design_swri )), file_name = f \"design_swri.json\" , absolute_folder_path = designs_folder / d_concrete . name , ) print ( f \" { design_name } exported to json\" ) load_design_json ( design_name = 'Trowel' , library_dat_file = 'library.dat' ) \u00b6 Load a design from json format Source code in sym_cps/examples/designs.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def load_design_json ( design_name : str = \"Trowel\" , library_dat_file : str = \"library.dat\" ): \"\"\"Load a design from json format\"\"\" \"\"\"BUG: FIXME: Does not work with new designs, e.g. NewAxe\"\"\" c_library : Library = load ( library_dat_file ) # type: ignore design_swri_path = designs_folder / design_name / \"design_swri.json\" d_concrete : DConcrete = parse_design_from_design_swri ( path = design_swri_path , library = c_library ) d_topology : DTopology = DTopology . from_concrete ( d_concrete ) print ( d_concrete ) print ( d_topology ) print ( f \" { design_name } imported from json\" )","title":"designs"},{"location":"reference/sym_cps/examples/designs/#sym_cps.examples.designs.export_design_json","text":"Produce the json file representing the design Source code in sym_cps/examples/designs.py 13 14 15 16 17 18 19 20 21 22 23 24 def export_design_json ( design_name : str = \"Trowel\" , designs_dat_file : str = \"designs.dat\" ): \"\"\"Produce the json file representing the design\"\"\" designs : dict [ str , tuple [ DConcrete , DTopology ]] = load ( designs_dat_file ) # type: ignore d_concrete = designs [ design_name ][ 0 ] save_to_file ( str ( json . dumps ( d_concrete . to_design_swri )), file_name = f \"design_swri.json\" , absolute_folder_path = designs_folder / d_concrete . name , ) print ( f \" { design_name } exported to json\" )","title":"export_design_json()"},{"location":"reference/sym_cps/examples/designs/#sym_cps.examples.designs.load_design_json","text":"Load a design from json format Source code in sym_cps/examples/designs.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def load_design_json ( design_name : str = \"Trowel\" , library_dat_file : str = \"library.dat\" ): \"\"\"Load a design from json format\"\"\" \"\"\"BUG: FIXME: Does not work with new designs, e.g. NewAxe\"\"\" c_library : Library = load ( library_dat_file ) # type: ignore design_swri_path = designs_folder / design_name / \"design_swri.json\" d_concrete : DConcrete = parse_design_from_design_swri ( path = design_swri_path , library = c_library ) d_topology : DTopology = DTopology . from_concrete ( d_concrete ) print ( d_concrete ) print ( d_topology ) print ( f \" { design_name } imported from json\" )","title":"load_design_json()"},{"location":"reference/sym_cps/examples/evaluation/","text":"","title":"evaluation"},{"location":"reference/sym_cps/examples/library/","text":"export_library ( library_txt_file = 'library.txt' , library_dat_file = 'library.dat' , designs_dat_file = 'designs.dat' ) \u00b6 Export library and seed designs to text files Source code in sym_cps/examples/library.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def export_library ( library_txt_file : str = \"library.txt\" , library_dat_file : str = \"library.dat\" , designs_dat_file : str = \"designs.dat\" ): \"\"\"Export library and seed designs to text files\"\"\" c_library : Library = load ( library_dat_file ) # type: ignore save_to_file ( str ( c_library ), file_name = library_txt_file , absolute_folder_path = library_folder ) \"\"\"In the following we can see some of the 'temporary objects' that have been build while building the components and designs libraries. We will save them to a text file in the output folder\"\"\" # Maps component type to all the LibraryComponent objects belonging to the type save_to_file ( repr_dictionary ( c_library . components_in_type ), \"all_components_in_type.txt\" , folder_name = \"library\" ) # Maps each component type to a set of components type which it can be connected to\"\"\" connectable_components_types : dict [ CType , set [ CType ]] = {} for ctype in c_library . component_types . values (): connectable_components_types [ ctype ] = set ( ctype . compatible_with . values ()) save_to_file ( repr_dictionary ( connectable_components_types ), \"connectable_components_types.txt\" , folder_name = \"library\" ) # Maps connector_id to its LibraryConnector object\"\"\" save_to_file ( repr_dictionary ( c_library . connectors ), \"all_connectors.txt\" , folder_name = \"library\" ) # Maps connector to a set of 'compatible' connectors it can be connected to\"\"\" connectable_connectors : dict [ CConnector , set [ CConnector ]] = {} for connector in c_library . connectors . values (): connectable_connectors [ connector ] = set ( connector . compatible_with . values ()) save_to_file ( repr_dictionary ( connectable_connectors ), \"connectable_connectors.txt\" , folder_name = \"library\" ) # all_parameters_upper_bounds: dict[str, float] = {} # Maps parameter_id to its upper bounds\"\"\" save_to_file ( repr_dictionary ( all_parameters_upper_bounds ), \"all_parameters_upper_bounds.txt\" , folder_name = \"library\" ) # all_parameters_lower_bounds: dict[str, float] = {} # Maps parameter_id to its lower bounds\"\"\" save_to_file ( repr_dictionary ( all_parameters_lower_bounds ), \"all_parameters_lower_bounds.txt\" , folder_name = \"library\" ) # all_parameters: dict[str, CParameterType] = {} # Maps parameter_id to CParameterType object\"\"\" save_to_file ( repr_dictionary ( c_library . parameters ), \"all_parameters.txt\" , folder_name = \"library\" ) # Maps parameter_id to a set of component types it belongs to\"\"\" parameter_to_components_types : dict [ str , set [ str ]] = {} for para_id , parameter in c_library . parameters . items (): if para_id not in parameter_to_components_types . keys (): parameter_to_components_types [ para_id ] = set () parameter_to_components_types [ para_id ] . add ( parameter . belongs_to ) save_to_file ( repr_dictionary ( parameter_to_components_types ), \"parameter_to_components_types.txt\" , folder_name = \"library\" ) designs : dict [ str , tuple [ DConcrete , DTopology ]] = load ( designs_dat_file ) # type: ignore for ( d_concrete , d_topology ) in designs . values (): d_concrete . export_all () d_topology . export_all ()","title":"library"},{"location":"reference/sym_cps/examples/library/#sym_cps.examples.library.export_library","text":"Export library and seed designs to text files Source code in sym_cps/examples/library.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def export_library ( library_txt_file : str = \"library.txt\" , library_dat_file : str = \"library.dat\" , designs_dat_file : str = \"designs.dat\" ): \"\"\"Export library and seed designs to text files\"\"\" c_library : Library = load ( library_dat_file ) # type: ignore save_to_file ( str ( c_library ), file_name = library_txt_file , absolute_folder_path = library_folder ) \"\"\"In the following we can see some of the 'temporary objects' that have been build while building the components and designs libraries. We will save them to a text file in the output folder\"\"\" # Maps component type to all the LibraryComponent objects belonging to the type save_to_file ( repr_dictionary ( c_library . components_in_type ), \"all_components_in_type.txt\" , folder_name = \"library\" ) # Maps each component type to a set of components type which it can be connected to\"\"\" connectable_components_types : dict [ CType , set [ CType ]] = {} for ctype in c_library . component_types . values (): connectable_components_types [ ctype ] = set ( ctype . compatible_with . values ()) save_to_file ( repr_dictionary ( connectable_components_types ), \"connectable_components_types.txt\" , folder_name = \"library\" ) # Maps connector_id to its LibraryConnector object\"\"\" save_to_file ( repr_dictionary ( c_library . connectors ), \"all_connectors.txt\" , folder_name = \"library\" ) # Maps connector to a set of 'compatible' connectors it can be connected to\"\"\" connectable_connectors : dict [ CConnector , set [ CConnector ]] = {} for connector in c_library . connectors . values (): connectable_connectors [ connector ] = set ( connector . compatible_with . values ()) save_to_file ( repr_dictionary ( connectable_connectors ), \"connectable_connectors.txt\" , folder_name = \"library\" ) # all_parameters_upper_bounds: dict[str, float] = {} # Maps parameter_id to its upper bounds\"\"\" save_to_file ( repr_dictionary ( all_parameters_upper_bounds ), \"all_parameters_upper_bounds.txt\" , folder_name = \"library\" ) # all_parameters_lower_bounds: dict[str, float] = {} # Maps parameter_id to its lower bounds\"\"\" save_to_file ( repr_dictionary ( all_parameters_lower_bounds ), \"all_parameters_lower_bounds.txt\" , folder_name = \"library\" ) # all_parameters: dict[str, CParameterType] = {} # Maps parameter_id to CParameterType object\"\"\" save_to_file ( repr_dictionary ( c_library . parameters ), \"all_parameters.txt\" , folder_name = \"library\" ) # Maps parameter_id to a set of component types it belongs to\"\"\" parameter_to_components_types : dict [ str , set [ str ]] = {} for para_id , parameter in c_library . parameters . items (): if para_id not in parameter_to_components_types . keys (): parameter_to_components_types [ para_id ] = set () parameter_to_components_types [ para_id ] . add ( parameter . belongs_to ) save_to_file ( repr_dictionary ( parameter_to_components_types ), \"parameter_to_components_types.txt\" , folder_name = \"library\" ) designs : dict [ str , tuple [ DConcrete , DTopology ]] = load ( designs_dat_file ) # type: ignore for ( d_concrete , d_topology ) in designs . values (): d_concrete . export_all () d_topology . export_all ()","title":"export_library()"},{"location":"reference/sym_cps/examples/parameter/","text":"parameter_opt ( design_name = 'TestQuad' , designs_dat_file = 'designs.dat' ) \u00b6 Get a design concrete Source code in sym_cps/examples/parameter.py 16 17 18 19 20 21 22 23 24 25 26 def parameter_opt ( design_name : str = \"TestQuad\" , designs_dat_file : str = \"designs.dat\" ): \"\"\"Get a design concrete\"\"\" design_concrete : DConcrete = designs [ design_name ][ 0 ] \"\"\"Call the optimizer\"\"\" result : DConcrete = para_opt . optimize ( d_concrete = design_concrete , strategy = ParametersStrategy . bayesian_strategy , constraints = ParametersConstraint . design_parameter , )","title":"parameter"},{"location":"reference/sym_cps/examples/parameter/#sym_cps.examples.parameter.parameter_opt","text":"Get a design concrete Source code in sym_cps/examples/parameter.py 16 17 18 19 20 21 22 23 24 25 26 def parameter_opt ( design_name : str = \"TestQuad\" , designs_dat_file : str = \"designs.dat\" ): \"\"\"Get a design concrete\"\"\" design_concrete : DConcrete = designs [ design_name ][ 0 ] \"\"\"Call the optimizer\"\"\" result : DConcrete = para_opt . optimize ( d_concrete = design_concrete , strategy = ParametersStrategy . bayesian_strategy , constraints = ParametersConstraint . design_parameter , )","title":"parameter_opt()"},{"location":"reference/sym_cps/examples/topology/","text":"random_topology ( design_name = 'Trowel' , designs_dat_file = 'designs.dat' ) \u00b6 Generate Topology DTopology, random strategy Source code in sym_cps/examples/topology.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 def random_topology ( design_name : str = \"Trowel\" , designs_dat_file : str = \"designs.dat\" ): \"\"\"Generate Topology DTopology, random strategy\"\"\" d_topology : DTopology = topo_opt . generate_topology ( name = \"RandomDesign\" , strategy = TopologyStrategy . random_strategy ) print ( \"****D_TOPOLOGY****\" ) print ( d_topology ) d_topology . export ( ExportType . TXT ) d_topology . export ( ExportType . DOT ) \"\"\"Refine DTopology to DConcrete, random strategy\"\"\" d_concrete : DConcrete = concr_opt . concretize_topology ( d_topology = d_topology , strategy = ConcreteStrategy . random_strategy ) print ( \" \\n ****D_CONCRETE****\" ) print ( d_concrete ) d_concrete . export ( ExportType . TXT ) d_concrete . export ( ExportType . DOT ) d_concrete . export ( ExportType . JSON ) d_concrete . export ( ExportType . PDF )","title":"topology"},{"location":"reference/sym_cps/examples/topology/#sym_cps.examples.topology.random_topology","text":"Generate Topology DTopology, random strategy Source code in sym_cps/examples/topology.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 def random_topology ( design_name : str = \"Trowel\" , designs_dat_file : str = \"designs.dat\" ): \"\"\"Generate Topology DTopology, random strategy\"\"\" d_topology : DTopology = topo_opt . generate_topology ( name = \"RandomDesign\" , strategy = TopologyStrategy . random_strategy ) print ( \"****D_TOPOLOGY****\" ) print ( d_topology ) d_topology . export ( ExportType . TXT ) d_topology . export ( ExportType . DOT ) \"\"\"Refine DTopology to DConcrete, random strategy\"\"\" d_concrete : DConcrete = concr_opt . concretize_topology ( d_topology = d_topology , strategy = ConcreteStrategy . random_strategy ) print ( \" \\n ****D_CONCRETE****\" ) print ( d_concrete ) d_concrete . export ( ExportType . TXT ) d_concrete . export ( ExportType . DOT ) d_concrete . export ( ExportType . JSON ) d_concrete . export ( ExportType . PDF )","title":"random_topology()"},{"location":"reference/sym_cps/examples/topology_3/","text":"","title":"topology_3"},{"location":"reference/sym_cps/grammar/","text":"","title":"grammar"},{"location":"reference/sym_cps/grammar/tools/","text":"","title":"tools"},{"location":"reference/sym_cps/grammar/topology/","text":"abstraction_levels_features = { 1 : {}, 2 : { AbstractionFeatures . USE_DEFAULT_PARAMETERS }, 3 : { AbstractionFeatures . USE_DEFAULT_PARAMETERS , AbstractionFeatures . AVOID_REDUNDANT_CONNECTIONS }, 4 : { AbstractionFeatures . AVOID_REDUNDANT_CONNECTIONS , AbstractionFeatures . USE_DEFAULT_PARAMETERS , AbstractionFeatures . USE_STRUCTURES }} module-attribute \u00b6 Todo implement condition 'AVOID_REDUNDANT_CONNECTIONS' A connection is redundant, i.e. Tube - Wing - TOP == Wing - Tube - Bottom Check \"connectors_compoennts_mapping.json\" and avoid redundancies","title":"topology"},{"location":"reference/sym_cps/grammar/topology/#sym_cps.grammar.topology.abstraction_levels_features","text":"Todo implement condition 'AVOID_REDUNDANT_CONNECTIONS' A connection is redundant, i.e. Tube - Wing - TOP == Wing - Tube - Bottom Check \"connectors_compoennts_mapping.json\" and avoid redundancies","title":"abstraction_levels_features"},{"location":"reference/sym_cps/hci/","text":"","title":"hci"},{"location":"reference/sym_cps/optimizers/","text":"","title":"optimizers"},{"location":"reference/sym_cps/optimizers/concrete_opt/","text":"Test ConcreteStrategy \u00b6 Bases: Enum Test Class Source code in sym_cps/optimizers/concrete_opt/__init__.py 16 17 18 19 20 21 class ConcreteStrategy ( Enum ): \"\"\" Test Class \"\"\" random_strategy = auto ()","title":"concrete_opt"},{"location":"reference/sym_cps/optimizers/concrete_opt/#sym_cps.optimizers.concrete_opt.ConcreteStrategy","text":"Bases: Enum Test Class Source code in sym_cps/optimizers/concrete_opt/__init__.py 16 17 18 19 20 21 class ConcreteStrategy ( Enum ): \"\"\" Test Class \"\"\" random_strategy = auto ()","title":"ConcreteStrategy"},{"location":"reference/sym_cps/optimizers/control_opt/","text":"","title":"control_opt"},{"location":"reference/sym_cps/optimizers/control_opt/control_opt_base/","text":"","title":"control_opt_base"},{"location":"reference/sym_cps/optimizers/control_opt/control_opt_bayes/","text":"","title":"control_opt_bayes"},{"location":"reference/sym_cps/optimizers/control_opt/control_opt_grid/","text":"","title":"control_opt_grid"},{"location":"reference/sym_cps/optimizers/control_opt/control_opt_interface/","text":"","title":"control_opt_interface"},{"location":"reference/sym_cps/optimizers/control_opt/fdm_data/","text":"","title":"fdm_data"},{"location":"reference/sym_cps/optimizers/control_opt/fdm_interface/","text":"FDMInterface \u00b6 Bases: object Source code in sym_cps/optimizers/control_opt/fdm_interface.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 class FDMInterface ( object ): def __init__ ( self , fdm_path = None , table_path = None , tmp_path = None ): self . _fdm_path = fdm_path if fdm_path is None : # self._fdm_path = r\"D:\\JWork\\Agents\\workspace\\UAM_Workflows\\FlightDynamics\\new_fdm.exe\" self . _fdm_path = fdm_bin_folder / \"new_fdm.exe\" self . _table_path = table_path if table_path is None : # self._table_path = r\"D:\\JWork\\Agents\\workspace\\UAM_Workflows\\Tables\\PropData\" self . _table_path = fdm_root_folder / \"Tables\" / \"PropData\" self . _tmp_path = tmp_path if tmp_path is None : # self._tmp_path = os.path.join(os.path.dirname(__file__), \"..\", \"fdm\") # self._tmp_path = os.path.join(os.path.dirname(__file__), \"..\", \"fdm\") self . _tmp_path = fdm_tmp_folder def execute_from_data ( self , fdm_data , fdm_args = None ): \"\"\"execute the fdm with the data. If fdm_args is provided, data will be changed\"\"\" if fdm_args is not None : self . set_fdm_Data ( fdm_data , fdm_args ) # print(fdm_data.data) inp_file_path = os . path . join ( self . _tmp_path , \"tmp.inp\" ) out_file_path = os . path . join ( self . _tmp_path , \"tmp.out\" ) fdm_data . write_input ( inp_file_path ) return self . executeFDM ( inp_file_path , out_file_path ) def execute_from_file ( self , file_name , fdm_args ): fdm_data = FDMData ( self . _table_path , file_name ) self . set_fdm_Data ( fdm_data , fdm_args ) return self . execute_from_data ( fdm_data ) def set_fdm_Data ( self , fdm_data , fdm_args ): # set the arguments into the data for arg_name , val in fdm_args . args . items (): if arg_name in fdm_data . data . keys (): fdm_data . data [ arg_name ] = val else : print ( arg_name , fdm_data . data . keys ()) raise Exception ( f \"Cannot set new argument in the fdm data: { arg_name } \" ) def executeFDM ( self , inp_path , out_path ): cmd = \" {} < {} > {} \" . format ( self . _fdm_path , inp_path , out_path ) # print(cmd) status = os . system ( cmd ) if status != 0 : print ( \"FDM execution error!\" ) raise Exception () return FDMResult ( out_path ) def getFDMArgs ( self , ** kwargs ): return FDMArgs ( ** kwargs ) def read_fdm_input ( self , file_path ): return FDMData ( self . _table_path , file_path ) execute_from_data ( fdm_data , fdm_args = None ) \u00b6 execute the fdm with the data. If fdm_args is provided, data will be changed Source code in sym_cps/optimizers/control_opt/fdm_interface.py 26 27 28 29 30 31 32 33 34 35 def execute_from_data ( self , fdm_data , fdm_args = None ): \"\"\"execute the fdm with the data. If fdm_args is provided, data will be changed\"\"\" if fdm_args is not None : self . set_fdm_Data ( fdm_data , fdm_args ) # print(fdm_data.data) inp_file_path = os . path . join ( self . _tmp_path , \"tmp.inp\" ) out_file_path = os . path . join ( self . _tmp_path , \"tmp.out\" ) fdm_data . write_input ( inp_file_path ) return self . executeFDM ( inp_file_path , out_file_path )","title":"fdm_interface"},{"location":"reference/sym_cps/optimizers/control_opt/fdm_interface/#sym_cps.optimizers.control_opt.fdm_interface.FDMInterface","text":"Bases: object Source code in sym_cps/optimizers/control_opt/fdm_interface.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 class FDMInterface ( object ): def __init__ ( self , fdm_path = None , table_path = None , tmp_path = None ): self . _fdm_path = fdm_path if fdm_path is None : # self._fdm_path = r\"D:\\JWork\\Agents\\workspace\\UAM_Workflows\\FlightDynamics\\new_fdm.exe\" self . _fdm_path = fdm_bin_folder / \"new_fdm.exe\" self . _table_path = table_path if table_path is None : # self._table_path = r\"D:\\JWork\\Agents\\workspace\\UAM_Workflows\\Tables\\PropData\" self . _table_path = fdm_root_folder / \"Tables\" / \"PropData\" self . _tmp_path = tmp_path if tmp_path is None : # self._tmp_path = os.path.join(os.path.dirname(__file__), \"..\", \"fdm\") # self._tmp_path = os.path.join(os.path.dirname(__file__), \"..\", \"fdm\") self . _tmp_path = fdm_tmp_folder def execute_from_data ( self , fdm_data , fdm_args = None ): \"\"\"execute the fdm with the data. If fdm_args is provided, data will be changed\"\"\" if fdm_args is not None : self . set_fdm_Data ( fdm_data , fdm_args ) # print(fdm_data.data) inp_file_path = os . path . join ( self . _tmp_path , \"tmp.inp\" ) out_file_path = os . path . join ( self . _tmp_path , \"tmp.out\" ) fdm_data . write_input ( inp_file_path ) return self . executeFDM ( inp_file_path , out_file_path ) def execute_from_file ( self , file_name , fdm_args ): fdm_data = FDMData ( self . _table_path , file_name ) self . set_fdm_Data ( fdm_data , fdm_args ) return self . execute_from_data ( fdm_data ) def set_fdm_Data ( self , fdm_data , fdm_args ): # set the arguments into the data for arg_name , val in fdm_args . args . items (): if arg_name in fdm_data . data . keys (): fdm_data . data [ arg_name ] = val else : print ( arg_name , fdm_data . data . keys ()) raise Exception ( f \"Cannot set new argument in the fdm data: { arg_name } \" ) def executeFDM ( self , inp_path , out_path ): cmd = \" {} < {} > {} \" . format ( self . _fdm_path , inp_path , out_path ) # print(cmd) status = os . system ( cmd ) if status != 0 : print ( \"FDM execution error!\" ) raise Exception () return FDMResult ( out_path ) def getFDMArgs ( self , ** kwargs ): return FDMArgs ( ** kwargs ) def read_fdm_input ( self , file_path ): return FDMData ( self . _table_path , file_path )","title":"FDMInterface"},{"location":"reference/sym_cps/optimizers/control_opt/fdm_interface/#sym_cps.optimizers.control_opt.fdm_interface.FDMInterface.execute_from_data","text":"execute the fdm with the data. If fdm_args is provided, data will be changed Source code in sym_cps/optimizers/control_opt/fdm_interface.py 26 27 28 29 30 31 32 33 34 35 def execute_from_data ( self , fdm_data , fdm_args = None ): \"\"\"execute the fdm with the data. If fdm_args is provided, data will be changed\"\"\" if fdm_args is not None : self . set_fdm_Data ( fdm_data , fdm_args ) # print(fdm_data.data) inp_file_path = os . path . join ( self . _tmp_path , \"tmp.inp\" ) out_file_path = os . path . join ( self . _tmp_path , \"tmp.out\" ) fdm_data . write_input ( inp_file_path ) return self . executeFDM ( inp_file_path , out_file_path )","title":"execute_from_data()"},{"location":"reference/sym_cps/optimizers/control_opt/fdm_ret/","text":"","title":"fdm_ret"},{"location":"reference/sym_cps/optimizers/control_opt/optimizer/","text":"","title":"optimizer"},{"location":"reference/sym_cps/optimizers/params_opt/","text":"ParameterOptimizationProblem \u00b6 Bases: ProblemBase Defines the optimization problem for parameter optimization All parameter optimization strategy receives the problem as input. Source code in sym_cps/optimizers/params_opt/param_opt_problem.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 class ParameterOptimizationProblem ( ProblemBase ): \"\"\"Defines the optimization problem for parameter optimization All parameter optimization strategy receives the problem as input. \"\"\" def __init__ ( self , d_concrete : DConcrete , strategy : ParametersStrategy , constraint : ParametersConstraint ): super () . __init__ () self . _d_concrete = d_concrete self . _strategyType = strategy self . _constraintType = constraint self . _bounds = None self . _params = None self . _init_params = None # get bounds, parameters self . _params , self . _opt_array = self . _vectorize_d_concrete ( d_concrete = self . _d_concrete ) # set the attribute from the ProblemBase self . _bounds = self . _get_bounds ( self . _params ) self . set_obj_dim ( 1 ) # 4 objective : four tests supported self . set_con_dim ( 1 ) # 1 constraint: the design is valid (can have FDM output) or not def set_parameters ( self , parameters : npt . ArrayLike ) -> None : \"\"\"Set the d concrete using the param_val as the value for each design parameter\"\"\" if len ( self . _params ) != parameters . shape [ 0 ]: print ( f \"Mismatched parameter size: { len ( self . _params ) } and { parameters . shape } \" ) raise Exception () for param , val in zip ( self . _params , parameters ): param . value = val def evaluate ( self , parameters : npt . ArrayLike ) -> tuple [ list [ float ], list [ bool ]]: # set the parameters self . set_parameters ( parameters ) # export to design_swri self . _d_concrete . export ( ExportType . JSON ) # call the pipeline for evaluation design_json_path = designs_folder / self . _d_concrete . name / \"design_swri.json\" # obj_vals, con_vals = evaluate_design( # design_json_path=design_json_path, # metadata={\"extra_info\": \"full evaluation example\"}, # timeout=800, # control_opt=True # ) obj_vals = np . array ([ - np . sum ( parameters ** 2 )]) con_vals = np . array ([ parameters [ 0 ] > parameters [ 1 ] and parameters [ 1 ] ** 2 - parameters [ 2 ] > 1 ]) print ( \"Warning, it is still not connected to evaluation pipeline!!!\" ) # TODO: Return obj_vals and con_vals return obj_vals , con_vals def obj_dominate ( self , obj1 : npt . ArrayLike , obj2 : npt . ArrayLike ): \"\"\"Compare multi-objective\"\"\" return obj1 [ 0 ] > obj2 [ 0 ] def _vectorize_d_concrete ( self , d_concrete : DConcrete ) -> tuple [ list [ Parameter | DesignParameter ], list [ float ]]: \"\"\" Create two arrays to help vectorize the parameters and facilitate mapping back the values to the design The first element in the tuple is the list of parameter object that can be set by calling .value The second element in the tuple is the array of the parameter values for optimization \"\"\" # create vector for optimization if self . _constraintType == ParametersConstraint . design_parameter : params = list ( d_concrete . design_parameters . values ()) param_val_array = [ param . value for param in params ] elif self . _constraintType == ParametersConstraint . component_parameter : params = [] for component in d_concrete . components : params . extend ( component . parameters . values ()) param_val_array = [ param . value for param in params ] # debug # for param, val in zip(params, param_val_array): # print(param.id, val) return params , param_val_array def _get_bounds ( self , d_params : list [ DesignParameter ]) -> list [ tuple [ float , float ]]: bounds = [] for d_param in d_params : min_val = None max_val = None for param in d_param . parameters : try : param_min = param . min except : param_min = None try : param_max = param . max except : param_max = None if min_val is None : min_val = param_min elif param_min is None : pass elif min_val > param_min : min_val = param . min if max_val is None : max_val = param_max elif param_max is None : pass elif max_val < param_max : max_val = param_max if min_val is None : min_val = - 10000 if max_val is None : max_val = 10000 bounds . append (( min_val , max_val )) return bounds obj_dominate ( obj1 , obj2 ) \u00b6 Compare multi-objective Source code in sym_cps/optimizers/params_opt/param_opt_problem.py 76 77 78 def obj_dominate ( self , obj1 : npt . ArrayLike , obj2 : npt . ArrayLike ): \"\"\"Compare multi-objective\"\"\" return obj1 [ 0 ] > obj2 [ 0 ] set_parameters ( parameters ) \u00b6 Set the d concrete using the param_val as the value for each design parameter Source code in sym_cps/optimizers/params_opt/param_opt_problem.py 46 47 48 49 50 51 52 def set_parameters ( self , parameters : npt . ArrayLike ) -> None : \"\"\"Set the d concrete using the param_val as the value for each design parameter\"\"\" if len ( self . _params ) != parameters . shape [ 0 ]: print ( f \"Mismatched parameter size: { len ( self . _params ) } and { parameters . shape } \" ) raise Exception () for param , val in zip ( self . _params , parameters ): param . value = val ParametersOptimizer \u00b6 Bases: Optimizer Source code in sym_cps/optimizers/params_opt/optimizer.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 class ParametersOptimizer ( Optimizer ): def _vectorize ( self , d_concrete : DConcrete , strategy : ParametersStrategy , constraints : ParametersConstraint ) -> tuple [ list [ Parameter | DesignParameter ], list [ float ]]: \"\"\" Create twos array to help vectorize the parameters and facilitate mapping back the values to the design The first element in the tuple is the list of parameter object that can be set by calling .value The second element in the tuple is the array of the parameter values for optimization \"\"\" if strategy == ParametersStrategy . bayesian_strategy : # create vector for optimization if constraints == ParametersConstraint . design_parameter : params = list ( d_concrete . design_parameters . values ()) param_val_array = [ param . value for param in params ] elif constraints == ParametersConstraint . component_parameter : params = [] for component in d_concrete . components : params . extend ( component . parameters . values ()) param_val_array = [ param . value for param in params ] # debug # for param, val in zip(params, param_val_array): # print(param.id, val) return params , param_val_array def _get_bounds ( self , d_params : list [ DesignParameter ]) -> list [ tuple [ float , float ]]: bounds = [] for d_param in d_params : min_val = None max_val = None for param in d_param . parameters : try : if min_val is None : min_val = param . min if max_val is None : max_val = param . max if min_val > param . min : min_val = param . min if max_val < param . max : max_val = param . max except : # not specified value in corpus min_val = - 10000 max_val = 10000 bounds . append (( min_val , max_val )) return bounds def optimize ( self , d_concrete : DConcrete , strategy : ParametersStrategy , constraints : ParametersConstraint ) -> DConcrete : d_concrete . name += \"_opt\" problem = ParameterOptimizationProblem ( d_concrete = d_concrete , strategy = strategy , constraint = constraints ) # debug for param , val in zip ( problem . _params , problem . _opt_array ): print ( param . id , val ) print ( problem . _bounds ) if strategy == ParametersStrategy . bayesian_strategy : print ( \"Optimizing Parameters using Bayesian Optimization!\" ) length_scale = [( ub - lb ) / 2 for ( lb , ub ) in problem . bounds ] kernel = Matern ( nu = 2.5 , length_scale = length_scale , length_scale_bounds = \"fixed\" ) kwarg = {} kwarg [ \"plot_debug\" ] = False kwarg [ \"plot_freq\" ] = 100 kwarg [ \"consider_constraint\" ] = False kwarg [ \"explore_num_samples\" ] = 50 kwarg [ \"explore_num_warm_up\" ] = 2000 kwarg [ \"kernel\" ] = kernel kwarg [ \"acquisition_function\" ] = \"GP-UCB\" optimizer = BayesianOptimizer ( problem = problem , debug_level = 2 , ** kwarg ) # optimizer = NMOptimizer(problem=problem, **kwarg) x_max_valid , y_max_valid = optimizer . optimize ()","title":"params_opt"},{"location":"reference/sym_cps/optimizers/params_opt/#sym_cps.optimizers.params_opt.ParameterOptimizationProblem","text":"Bases: ProblemBase Defines the optimization problem for parameter optimization All parameter optimization strategy receives the problem as input. Source code in sym_cps/optimizers/params_opt/param_opt_problem.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 class ParameterOptimizationProblem ( ProblemBase ): \"\"\"Defines the optimization problem for parameter optimization All parameter optimization strategy receives the problem as input. \"\"\" def __init__ ( self , d_concrete : DConcrete , strategy : ParametersStrategy , constraint : ParametersConstraint ): super () . __init__ () self . _d_concrete = d_concrete self . _strategyType = strategy self . _constraintType = constraint self . _bounds = None self . _params = None self . _init_params = None # get bounds, parameters self . _params , self . _opt_array = self . _vectorize_d_concrete ( d_concrete = self . _d_concrete ) # set the attribute from the ProblemBase self . _bounds = self . _get_bounds ( self . _params ) self . set_obj_dim ( 1 ) # 4 objective : four tests supported self . set_con_dim ( 1 ) # 1 constraint: the design is valid (can have FDM output) or not def set_parameters ( self , parameters : npt . ArrayLike ) -> None : \"\"\"Set the d concrete using the param_val as the value for each design parameter\"\"\" if len ( self . _params ) != parameters . shape [ 0 ]: print ( f \"Mismatched parameter size: { len ( self . _params ) } and { parameters . shape } \" ) raise Exception () for param , val in zip ( self . _params , parameters ): param . value = val def evaluate ( self , parameters : npt . ArrayLike ) -> tuple [ list [ float ], list [ bool ]]: # set the parameters self . set_parameters ( parameters ) # export to design_swri self . _d_concrete . export ( ExportType . JSON ) # call the pipeline for evaluation design_json_path = designs_folder / self . _d_concrete . name / \"design_swri.json\" # obj_vals, con_vals = evaluate_design( # design_json_path=design_json_path, # metadata={\"extra_info\": \"full evaluation example\"}, # timeout=800, # control_opt=True # ) obj_vals = np . array ([ - np . sum ( parameters ** 2 )]) con_vals = np . array ([ parameters [ 0 ] > parameters [ 1 ] and parameters [ 1 ] ** 2 - parameters [ 2 ] > 1 ]) print ( \"Warning, it is still not connected to evaluation pipeline!!!\" ) # TODO: Return obj_vals and con_vals return obj_vals , con_vals def obj_dominate ( self , obj1 : npt . ArrayLike , obj2 : npt . ArrayLike ): \"\"\"Compare multi-objective\"\"\" return obj1 [ 0 ] > obj2 [ 0 ] def _vectorize_d_concrete ( self , d_concrete : DConcrete ) -> tuple [ list [ Parameter | DesignParameter ], list [ float ]]: \"\"\" Create two arrays to help vectorize the parameters and facilitate mapping back the values to the design The first element in the tuple is the list of parameter object that can be set by calling .value The second element in the tuple is the array of the parameter values for optimization \"\"\" # create vector for optimization if self . _constraintType == ParametersConstraint . design_parameter : params = list ( d_concrete . design_parameters . values ()) param_val_array = [ param . value for param in params ] elif self . _constraintType == ParametersConstraint . component_parameter : params = [] for component in d_concrete . components : params . extend ( component . parameters . values ()) param_val_array = [ param . value for param in params ] # debug # for param, val in zip(params, param_val_array): # print(param.id, val) return params , param_val_array def _get_bounds ( self , d_params : list [ DesignParameter ]) -> list [ tuple [ float , float ]]: bounds = [] for d_param in d_params : min_val = None max_val = None for param in d_param . parameters : try : param_min = param . min except : param_min = None try : param_max = param . max except : param_max = None if min_val is None : min_val = param_min elif param_min is None : pass elif min_val > param_min : min_val = param . min if max_val is None : max_val = param_max elif param_max is None : pass elif max_val < param_max : max_val = param_max if min_val is None : min_val = - 10000 if max_val is None : max_val = 10000 bounds . append (( min_val , max_val )) return bounds","title":"ParameterOptimizationProblem"},{"location":"reference/sym_cps/optimizers/params_opt/#sym_cps.optimizers.params_opt.param_opt_problem.ParameterOptimizationProblem.obj_dominate","text":"Compare multi-objective Source code in sym_cps/optimizers/params_opt/param_opt_problem.py 76 77 78 def obj_dominate ( self , obj1 : npt . ArrayLike , obj2 : npt . ArrayLike ): \"\"\"Compare multi-objective\"\"\" return obj1 [ 0 ] > obj2 [ 0 ]","title":"obj_dominate()"},{"location":"reference/sym_cps/optimizers/params_opt/#sym_cps.optimizers.params_opt.param_opt_problem.ParameterOptimizationProblem.set_parameters","text":"Set the d concrete using the param_val as the value for each design parameter Source code in sym_cps/optimizers/params_opt/param_opt_problem.py 46 47 48 49 50 51 52 def set_parameters ( self , parameters : npt . ArrayLike ) -> None : \"\"\"Set the d concrete using the param_val as the value for each design parameter\"\"\" if len ( self . _params ) != parameters . shape [ 0 ]: print ( f \"Mismatched parameter size: { len ( self . _params ) } and { parameters . shape } \" ) raise Exception () for param , val in zip ( self . _params , parameters ): param . value = val","title":"set_parameters()"},{"location":"reference/sym_cps/optimizers/params_opt/#sym_cps.optimizers.params_opt.ParametersOptimizer","text":"Bases: Optimizer Source code in sym_cps/optimizers/params_opt/optimizer.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 class ParametersOptimizer ( Optimizer ): def _vectorize ( self , d_concrete : DConcrete , strategy : ParametersStrategy , constraints : ParametersConstraint ) -> tuple [ list [ Parameter | DesignParameter ], list [ float ]]: \"\"\" Create twos array to help vectorize the parameters and facilitate mapping back the values to the design The first element in the tuple is the list of parameter object that can be set by calling .value The second element in the tuple is the array of the parameter values for optimization \"\"\" if strategy == ParametersStrategy . bayesian_strategy : # create vector for optimization if constraints == ParametersConstraint . design_parameter : params = list ( d_concrete . design_parameters . values ()) param_val_array = [ param . value for param in params ] elif constraints == ParametersConstraint . component_parameter : params = [] for component in d_concrete . components : params . extend ( component . parameters . values ()) param_val_array = [ param . value for param in params ] # debug # for param, val in zip(params, param_val_array): # print(param.id, val) return params , param_val_array def _get_bounds ( self , d_params : list [ DesignParameter ]) -> list [ tuple [ float , float ]]: bounds = [] for d_param in d_params : min_val = None max_val = None for param in d_param . parameters : try : if min_val is None : min_val = param . min if max_val is None : max_val = param . max if min_val > param . min : min_val = param . min if max_val < param . max : max_val = param . max except : # not specified value in corpus min_val = - 10000 max_val = 10000 bounds . append (( min_val , max_val )) return bounds def optimize ( self , d_concrete : DConcrete , strategy : ParametersStrategy , constraints : ParametersConstraint ) -> DConcrete : d_concrete . name += \"_opt\" problem = ParameterOptimizationProblem ( d_concrete = d_concrete , strategy = strategy , constraint = constraints ) # debug for param , val in zip ( problem . _params , problem . _opt_array ): print ( param . id , val ) print ( problem . _bounds ) if strategy == ParametersStrategy . bayesian_strategy : print ( \"Optimizing Parameters using Bayesian Optimization!\" ) length_scale = [( ub - lb ) / 2 for ( lb , ub ) in problem . bounds ] kernel = Matern ( nu = 2.5 , length_scale = length_scale , length_scale_bounds = \"fixed\" ) kwarg = {} kwarg [ \"plot_debug\" ] = False kwarg [ \"plot_freq\" ] = 100 kwarg [ \"consider_constraint\" ] = False kwarg [ \"explore_num_samples\" ] = 50 kwarg [ \"explore_num_warm_up\" ] = 2000 kwarg [ \"kernel\" ] = kernel kwarg [ \"acquisition_function\" ] = \"GP-UCB\" optimizer = BayesianOptimizer ( problem = problem , debug_level = 2 , ** kwarg ) # optimizer = NMOptimizer(problem=problem, **kwarg) x_max_valid , y_max_valid = optimizer . optimize ()","title":"ParametersOptimizer"},{"location":"reference/sym_cps/optimizers/params_opt/optimizer/","text":"ParametersOptimizer \u00b6 Bases: Optimizer Source code in sym_cps/optimizers/params_opt/optimizer.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 class ParametersOptimizer ( Optimizer ): def _vectorize ( self , d_concrete : DConcrete , strategy : ParametersStrategy , constraints : ParametersConstraint ) -> tuple [ list [ Parameter | DesignParameter ], list [ float ]]: \"\"\" Create twos array to help vectorize the parameters and facilitate mapping back the values to the design The first element in the tuple is the list of parameter object that can be set by calling .value The second element in the tuple is the array of the parameter values for optimization \"\"\" if strategy == ParametersStrategy . bayesian_strategy : # create vector for optimization if constraints == ParametersConstraint . design_parameter : params = list ( d_concrete . design_parameters . values ()) param_val_array = [ param . value for param in params ] elif constraints == ParametersConstraint . component_parameter : params = [] for component in d_concrete . components : params . extend ( component . parameters . values ()) param_val_array = [ param . value for param in params ] # debug # for param, val in zip(params, param_val_array): # print(param.id, val) return params , param_val_array def _get_bounds ( self , d_params : list [ DesignParameter ]) -> list [ tuple [ float , float ]]: bounds = [] for d_param in d_params : min_val = None max_val = None for param in d_param . parameters : try : if min_val is None : min_val = param . min if max_val is None : max_val = param . max if min_val > param . min : min_val = param . min if max_val < param . max : max_val = param . max except : # not specified value in corpus min_val = - 10000 max_val = 10000 bounds . append (( min_val , max_val )) return bounds def optimize ( self , d_concrete : DConcrete , strategy : ParametersStrategy , constraints : ParametersConstraint ) -> DConcrete : d_concrete . name += \"_opt\" problem = ParameterOptimizationProblem ( d_concrete = d_concrete , strategy = strategy , constraint = constraints ) # debug for param , val in zip ( problem . _params , problem . _opt_array ): print ( param . id , val ) print ( problem . _bounds ) if strategy == ParametersStrategy . bayesian_strategy : print ( \"Optimizing Parameters using Bayesian Optimization!\" ) length_scale = [( ub - lb ) / 2 for ( lb , ub ) in problem . bounds ] kernel = Matern ( nu = 2.5 , length_scale = length_scale , length_scale_bounds = \"fixed\" ) kwarg = {} kwarg [ \"plot_debug\" ] = False kwarg [ \"plot_freq\" ] = 100 kwarg [ \"consider_constraint\" ] = False kwarg [ \"explore_num_samples\" ] = 50 kwarg [ \"explore_num_warm_up\" ] = 2000 kwarg [ \"kernel\" ] = kernel kwarg [ \"acquisition_function\" ] = \"GP-UCB\" optimizer = BayesianOptimizer ( problem = problem , debug_level = 2 , ** kwarg ) # optimizer = NMOptimizer(problem=problem, **kwarg) x_max_valid , y_max_valid = optimizer . optimize ()","title":"optimizer"},{"location":"reference/sym_cps/optimizers/params_opt/optimizer/#sym_cps.optimizers.params_opt.optimizer.ParametersOptimizer","text":"Bases: Optimizer Source code in sym_cps/optimizers/params_opt/optimizer.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 class ParametersOptimizer ( Optimizer ): def _vectorize ( self , d_concrete : DConcrete , strategy : ParametersStrategy , constraints : ParametersConstraint ) -> tuple [ list [ Parameter | DesignParameter ], list [ float ]]: \"\"\" Create twos array to help vectorize the parameters and facilitate mapping back the values to the design The first element in the tuple is the list of parameter object that can be set by calling .value The second element in the tuple is the array of the parameter values for optimization \"\"\" if strategy == ParametersStrategy . bayesian_strategy : # create vector for optimization if constraints == ParametersConstraint . design_parameter : params = list ( d_concrete . design_parameters . values ()) param_val_array = [ param . value for param in params ] elif constraints == ParametersConstraint . component_parameter : params = [] for component in d_concrete . components : params . extend ( component . parameters . values ()) param_val_array = [ param . value for param in params ] # debug # for param, val in zip(params, param_val_array): # print(param.id, val) return params , param_val_array def _get_bounds ( self , d_params : list [ DesignParameter ]) -> list [ tuple [ float , float ]]: bounds = [] for d_param in d_params : min_val = None max_val = None for param in d_param . parameters : try : if min_val is None : min_val = param . min if max_val is None : max_val = param . max if min_val > param . min : min_val = param . min if max_val < param . max : max_val = param . max except : # not specified value in corpus min_val = - 10000 max_val = 10000 bounds . append (( min_val , max_val )) return bounds def optimize ( self , d_concrete : DConcrete , strategy : ParametersStrategy , constraints : ParametersConstraint ) -> DConcrete : d_concrete . name += \"_opt\" problem = ParameterOptimizationProblem ( d_concrete = d_concrete , strategy = strategy , constraint = constraints ) # debug for param , val in zip ( problem . _params , problem . _opt_array ): print ( param . id , val ) print ( problem . _bounds ) if strategy == ParametersStrategy . bayesian_strategy : print ( \"Optimizing Parameters using Bayesian Optimization!\" ) length_scale = [( ub - lb ) / 2 for ( lb , ub ) in problem . bounds ] kernel = Matern ( nu = 2.5 , length_scale = length_scale , length_scale_bounds = \"fixed\" ) kwarg = {} kwarg [ \"plot_debug\" ] = False kwarg [ \"plot_freq\" ] = 100 kwarg [ \"consider_constraint\" ] = False kwarg [ \"explore_num_samples\" ] = 50 kwarg [ \"explore_num_warm_up\" ] = 2000 kwarg [ \"kernel\" ] = kernel kwarg [ \"acquisition_function\" ] = \"GP-UCB\" optimizer = BayesianOptimizer ( problem = problem , debug_level = 2 , ** kwarg ) # optimizer = NMOptimizer(problem=problem, **kwarg) x_max_valid , y_max_valid = optimizer . optimize ()","title":"ParametersOptimizer"},{"location":"reference/sym_cps/optimizers/params_opt/param_opt_problem/","text":"ParameterOptimizationProblem \u00b6 Bases: ProblemBase Defines the optimization problem for parameter optimization All parameter optimization strategy receives the problem as input. Source code in sym_cps/optimizers/params_opt/param_opt_problem.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 class ParameterOptimizationProblem ( ProblemBase ): \"\"\"Defines the optimization problem for parameter optimization All parameter optimization strategy receives the problem as input. \"\"\" def __init__ ( self , d_concrete : DConcrete , strategy : ParametersStrategy , constraint : ParametersConstraint ): super () . __init__ () self . _d_concrete = d_concrete self . _strategyType = strategy self . _constraintType = constraint self . _bounds = None self . _params = None self . _init_params = None # get bounds, parameters self . _params , self . _opt_array = self . _vectorize_d_concrete ( d_concrete = self . _d_concrete ) # set the attribute from the ProblemBase self . _bounds = self . _get_bounds ( self . _params ) self . set_obj_dim ( 1 ) # 4 objective : four tests supported self . set_con_dim ( 1 ) # 1 constraint: the design is valid (can have FDM output) or not def set_parameters ( self , parameters : npt . ArrayLike ) -> None : \"\"\"Set the d concrete using the param_val as the value for each design parameter\"\"\" if len ( self . _params ) != parameters . shape [ 0 ]: print ( f \"Mismatched parameter size: { len ( self . _params ) } and { parameters . shape } \" ) raise Exception () for param , val in zip ( self . _params , parameters ): param . value = val def evaluate ( self , parameters : npt . ArrayLike ) -> tuple [ list [ float ], list [ bool ]]: # set the parameters self . set_parameters ( parameters ) # export to design_swri self . _d_concrete . export ( ExportType . JSON ) # call the pipeline for evaluation design_json_path = designs_folder / self . _d_concrete . name / \"design_swri.json\" # obj_vals, con_vals = evaluate_design( # design_json_path=design_json_path, # metadata={\"extra_info\": \"full evaluation example\"}, # timeout=800, # control_opt=True # ) obj_vals = np . array ([ - np . sum ( parameters ** 2 )]) con_vals = np . array ([ parameters [ 0 ] > parameters [ 1 ] and parameters [ 1 ] ** 2 - parameters [ 2 ] > 1 ]) print ( \"Warning, it is still not connected to evaluation pipeline!!!\" ) # TODO: Return obj_vals and con_vals return obj_vals , con_vals def obj_dominate ( self , obj1 : npt . ArrayLike , obj2 : npt . ArrayLike ): \"\"\"Compare multi-objective\"\"\" return obj1 [ 0 ] > obj2 [ 0 ] def _vectorize_d_concrete ( self , d_concrete : DConcrete ) -> tuple [ list [ Parameter | DesignParameter ], list [ float ]]: \"\"\" Create two arrays to help vectorize the parameters and facilitate mapping back the values to the design The first element in the tuple is the list of parameter object that can be set by calling .value The second element in the tuple is the array of the parameter values for optimization \"\"\" # create vector for optimization if self . _constraintType == ParametersConstraint . design_parameter : params = list ( d_concrete . design_parameters . values ()) param_val_array = [ param . value for param in params ] elif self . _constraintType == ParametersConstraint . component_parameter : params = [] for component in d_concrete . components : params . extend ( component . parameters . values ()) param_val_array = [ param . value for param in params ] # debug # for param, val in zip(params, param_val_array): # print(param.id, val) return params , param_val_array def _get_bounds ( self , d_params : list [ DesignParameter ]) -> list [ tuple [ float , float ]]: bounds = [] for d_param in d_params : min_val = None max_val = None for param in d_param . parameters : try : param_min = param . min except : param_min = None try : param_max = param . max except : param_max = None if min_val is None : min_val = param_min elif param_min is None : pass elif min_val > param_min : min_val = param . min if max_val is None : max_val = param_max elif param_max is None : pass elif max_val < param_max : max_val = param_max if min_val is None : min_val = - 10000 if max_val is None : max_val = 10000 bounds . append (( min_val , max_val )) return bounds obj_dominate ( obj1 , obj2 ) \u00b6 Compare multi-objective Source code in sym_cps/optimizers/params_opt/param_opt_problem.py 76 77 78 def obj_dominate ( self , obj1 : npt . ArrayLike , obj2 : npt . ArrayLike ): \"\"\"Compare multi-objective\"\"\" return obj1 [ 0 ] > obj2 [ 0 ] set_parameters ( parameters ) \u00b6 Set the d concrete using the param_val as the value for each design parameter Source code in sym_cps/optimizers/params_opt/param_opt_problem.py 46 47 48 49 50 51 52 def set_parameters ( self , parameters : npt . ArrayLike ) -> None : \"\"\"Set the d concrete using the param_val as the value for each design parameter\"\"\" if len ( self . _params ) != parameters . shape [ 0 ]: print ( f \"Mismatched parameter size: { len ( self . _params ) } and { parameters . shape } \" ) raise Exception () for param , val in zip ( self . _params , parameters ): param . value = val","title":"param_opt_problem"},{"location":"reference/sym_cps/optimizers/params_opt/param_opt_problem/#sym_cps.optimizers.params_opt.param_opt_problem.ParameterOptimizationProblem","text":"Bases: ProblemBase Defines the optimization problem for parameter optimization All parameter optimization strategy receives the problem as input. Source code in sym_cps/optimizers/params_opt/param_opt_problem.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 class ParameterOptimizationProblem ( ProblemBase ): \"\"\"Defines the optimization problem for parameter optimization All parameter optimization strategy receives the problem as input. \"\"\" def __init__ ( self , d_concrete : DConcrete , strategy : ParametersStrategy , constraint : ParametersConstraint ): super () . __init__ () self . _d_concrete = d_concrete self . _strategyType = strategy self . _constraintType = constraint self . _bounds = None self . _params = None self . _init_params = None # get bounds, parameters self . _params , self . _opt_array = self . _vectorize_d_concrete ( d_concrete = self . _d_concrete ) # set the attribute from the ProblemBase self . _bounds = self . _get_bounds ( self . _params ) self . set_obj_dim ( 1 ) # 4 objective : four tests supported self . set_con_dim ( 1 ) # 1 constraint: the design is valid (can have FDM output) or not def set_parameters ( self , parameters : npt . ArrayLike ) -> None : \"\"\"Set the d concrete using the param_val as the value for each design parameter\"\"\" if len ( self . _params ) != parameters . shape [ 0 ]: print ( f \"Mismatched parameter size: { len ( self . _params ) } and { parameters . shape } \" ) raise Exception () for param , val in zip ( self . _params , parameters ): param . value = val def evaluate ( self , parameters : npt . ArrayLike ) -> tuple [ list [ float ], list [ bool ]]: # set the parameters self . set_parameters ( parameters ) # export to design_swri self . _d_concrete . export ( ExportType . JSON ) # call the pipeline for evaluation design_json_path = designs_folder / self . _d_concrete . name / \"design_swri.json\" # obj_vals, con_vals = evaluate_design( # design_json_path=design_json_path, # metadata={\"extra_info\": \"full evaluation example\"}, # timeout=800, # control_opt=True # ) obj_vals = np . array ([ - np . sum ( parameters ** 2 )]) con_vals = np . array ([ parameters [ 0 ] > parameters [ 1 ] and parameters [ 1 ] ** 2 - parameters [ 2 ] > 1 ]) print ( \"Warning, it is still not connected to evaluation pipeline!!!\" ) # TODO: Return obj_vals and con_vals return obj_vals , con_vals def obj_dominate ( self , obj1 : npt . ArrayLike , obj2 : npt . ArrayLike ): \"\"\"Compare multi-objective\"\"\" return obj1 [ 0 ] > obj2 [ 0 ] def _vectorize_d_concrete ( self , d_concrete : DConcrete ) -> tuple [ list [ Parameter | DesignParameter ], list [ float ]]: \"\"\" Create two arrays to help vectorize the parameters and facilitate mapping back the values to the design The first element in the tuple is the list of parameter object that can be set by calling .value The second element in the tuple is the array of the parameter values for optimization \"\"\" # create vector for optimization if self . _constraintType == ParametersConstraint . design_parameter : params = list ( d_concrete . design_parameters . values ()) param_val_array = [ param . value for param in params ] elif self . _constraintType == ParametersConstraint . component_parameter : params = [] for component in d_concrete . components : params . extend ( component . parameters . values ()) param_val_array = [ param . value for param in params ] # debug # for param, val in zip(params, param_val_array): # print(param.id, val) return params , param_val_array def _get_bounds ( self , d_params : list [ DesignParameter ]) -> list [ tuple [ float , float ]]: bounds = [] for d_param in d_params : min_val = None max_val = None for param in d_param . parameters : try : param_min = param . min except : param_min = None try : param_max = param . max except : param_max = None if min_val is None : min_val = param_min elif param_min is None : pass elif min_val > param_min : min_val = param . min if max_val is None : max_val = param_max elif param_max is None : pass elif max_val < param_max : max_val = param_max if min_val is None : min_val = - 10000 if max_val is None : max_val = 10000 bounds . append (( min_val , max_val )) return bounds","title":"ParameterOptimizationProblem"},{"location":"reference/sym_cps/optimizers/params_opt/param_opt_problem/#sym_cps.optimizers.params_opt.param_opt_problem.ParameterOptimizationProblem.obj_dominate","text":"Compare multi-objective Source code in sym_cps/optimizers/params_opt/param_opt_problem.py 76 77 78 def obj_dominate ( self , obj1 : npt . ArrayLike , obj2 : npt . ArrayLike ): \"\"\"Compare multi-objective\"\"\" return obj1 [ 0 ] > obj2 [ 0 ]","title":"obj_dominate()"},{"location":"reference/sym_cps/optimizers/params_opt/param_opt_problem/#sym_cps.optimizers.params_opt.param_opt_problem.ParameterOptimizationProblem.set_parameters","text":"Set the d concrete using the param_val as the value for each design parameter Source code in sym_cps/optimizers/params_opt/param_opt_problem.py 46 47 48 49 50 51 52 def set_parameters ( self , parameters : npt . ArrayLike ) -> None : \"\"\"Set the d concrete using the param_val as the value for each design parameter\"\"\" if len ( self . _params ) != parameters . shape [ 0 ]: print ( f \"Mismatched parameter size: { len ( self . _params ) } and { parameters . shape } \" ) raise Exception () for param , val in zip ( self . _params , parameters ): param . value = val","title":"set_parameters()"},{"location":"reference/sym_cps/optimizers/tools/","text":"Put all auxilliary optimizer here (global, local optimizer) and serves as interface to optimizer module","title":"tools"},{"location":"reference/sym_cps/optimizers/tools/optimization/","text":"","title":"optimization"},{"location":"reference/sym_cps/optimizers/tools/optimization/bayesian_opt_visualizer/","text":"","title":"bayesian_opt_visualizer"},{"location":"reference/sym_cps/optimizers/tools/optimization/bayesian_optimizer/","text":"BayesianOptimizer \u00b6 Bases: OptimizerBase Optimization usign Bayesian Optimization Taking a optimization problem, performs black box optimization which combines a classifier Input: problem: A ProblemBase object Source code in sym_cps/optimizers/tools/optimization/bayesian_optimizer.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 class BayesianOptimizer ( OptimizerBase ): \"\"\"Optimization usign Bayesian Optimization Taking a optimization problem, performs black box optimization which combines a classifier Input: problem: A ProblemBase object \"\"\" def __init__ ( self , problem : ProblemBase , debug_level = 1 , ** kwarg ): super () . __init__ ( problem = problem ) self . _visualizer = BayesianOptimizationVisualizer () self . _kernel = Matern ( nu = 2.5 , length_scale = 0.05 , length_scale_bounds = \"fixed\" ) # self._kernel = Matern(nu=2.5, length_scale=5000, length_scale_bounds = \"fixed\") self . _acq_function = self . expected_improvement self . _surrogate_model_obj : SurrogateInterface = ScikitGPR self . _surrogate_model_con : SurrogateInterface = LogisticClassifier self . _xi : float = 0.0 self . _rng = np . random . RandomState ( 1234 ) self . _iteration : int = 1000 self . _num_warn_up_samples : int = 10 self . _explore_num_warm_up : int = 200 self . _explore_num_samples : int = 25 self . _consider_constraint : bool = True self . _plot_debug : bool = False self . _plot_freq : int = 10 self . set_args ( ** kwarg ) if self . _plot_debug : self . _visualizer . initialize_design_space ( self . _problem ) def set_args ( self , ** kwarg ): if \"kernel\" in kwarg . keys (): print ( \"Setting Kernel...\" ) self . _kernel = kwarg [ \"kernel\" ] if \"acquisition_function\" in kwarg . keys (): if kwarg [ \"acquisition_function\" ] == \"GP-UCB\" : print ( \"Use GP-UCB as acquisition function\" ) self . _acq_function = self . upper_confidence_bound elif kwarg [ \"acquisition_function\" ] == \"EI\" : print ( \"Use EI as acquisition function\" ) self . _acq_function = self . expected_improvement else : s = kwarg [ \"acquisition_function\" ] print ( f \"Unknown Acquisition function type { s } \" ) if \"surrogate_model_obj\" in kwarg . keys (): self . _surrogate_model_obj = kwarg [ \"surrogate_model_obj\" ] if \"surrogate_model_con\" in kwarg . keys (): self . _surrogate_model_con = kwarg [ \"surrogate_model_con\" ] if \"random_generator\" in kwarg . keys (): self . _rng = kwarg [ \"random_generator\" ] if \"iteration\" in kwarg . keys (): self . _iteration = kwarg [ \"iteration\" ] if \"num_warn_up_samples\" in kwarg . keys (): print ( f \"Set numbers of warm up samples as { self . _num_warn_up_samples } \" ) self . _num_warn_up_samples = kwarg [ \"num_warn_up_samples\" ] if \"explore_num_warm_up\" in kwarg . keys (): self . _explore_num_warm_up = kwarg [ \"explore_num_warm_up\" ] print ( f \"Set numbers of exploration warm up samples as { self . _explore_num_warm_up } \" ) if \"explore_num_samples\" in kwarg . keys (): self . _explore_num_samples = kwarg [ \"explore_num_samples\" ] print ( f \"Set numbers of exploration samples as { self . _explore_num_samples } \" ) if \"consider_constraint\" in kwarg . keys (): self . _consider_constraint = kwarg [ \"consider_constraint\" ] if \"plot_debug\" in kwarg . keys (): self . _plot_debug = kwarg [ \"plot_debug\" ] if \"plot_freq\" in kwarg . keys (): self . _plot_freq = kwarg [ \"plot_freq\" ] def _get_samples ( self , n_samples ): ubound = np . array ([ u_b for ( _ , u_b ) in self . _problem . bounds ]) lbound = np . array ([ l_b for ( l_b , _ ) in self . _problem . bounds ]) return self . _rng . uniform ( low = lbound , high = ubound , size = ( n_samples , self . _problem . dim )) def optimize ( self , ** kwarg ): \"\"\"This function performs maximization!!\"\"\" if self . _plot_debug : self . _visualizer . plot_objectives () self . _visualizer . plot_finalize () self . _visualizer . plot_constraints () self . _visualizer . plot_finalize () self . set_args ( ** kwarg ) x_max_valid = None y_max_ind_valid = np . full ( self . _problem . obj_dim , - float ( \"inf\" )) # record the best obj value of valid design y_max_valid = np . full ( self . _problem . obj_dim , - float ( \"inf\" )) # record the best obj value of valid design # seed init x_init = np . array ( self . _problem . opt_array ) # warnup with random samples x_sample = self . _get_samples ( n_samples = self . _num_warn_up_samples ) # print(x_init, x_sample) x_sample = np . concatenate (( x_init . reshape ( 1 , - 1 ), x_sample )) # evaluate the random samples for x in x_sample : y , v = self . _evaluate ( parameters = x ) valid = np . all ( v ) if valid or not self . _consider_constraint : y_max_ind_valid = np . maximum ( y , y_max_ind_valid ) if self . _problem . obj_dominate ( y , y_max_valid ): # TODO: handle multi-objective parato front y_max_valid = y x_max_valid = x # print(self._hist.hist_params) # print(self._hist.hist_func) # print(self._hist.hist_valid) # start performing bayesian optimization for i in range ( self . _iteration ): self . debug_print ( 1 , \"iteration\" , i ) obj_model = self . _surrogate_model_obj ( kernel = self . _kernel ) con_model = self . _surrogate_model_con () x_explored = self . _hist . hist_params y_explored = self . _hist . hist_func v_explored = self . _hist . hist_valid obj_model . fit ( x_explored , y_explored ) if self . _consider_constraint : con_model . fit ( x_explored , v_explored ) # apply the surrogate x_min = self . _explore_with_surrogate ( obj_model = obj_model , con_model = con_model , y_best = y_max_ind_valid , index = i ) # evaluate the candidate y , v = self . _evaluate ( parameters = x_min ) valid = np . all ( v ) if valid or not self . _consider_constraint : y_max_ind_valid = np . maximum ( y , y_max_ind_valid ) if self . _problem . obj_dominate ( y , y_max_valid ): # TODO: handle multi-objective parato front y_max_valid = y x_max_valid = x print ( f \"Iteration { i } : x = { x_min } , y = { y } , y_max = { y_max_valid } \" ) return x_max_valid , y_max_valid def _evaluate ( self , parameters : npt . ArrayLike , record : bool = True , idx : int | None = None ) -> tuple [ list [ float ], list [ bool ]]: \"\"\"Evaluates the parameters and returns the objective function value and constraints satisfaction\"\"\" obj_vals , con_vals = self . _problem . evaluate ( parameters ) if idx is not None : obj_vals = obj_vals [ idx ] con_vals = con_vals [ idx ] if record : self . _hist . add_hist ( params = parameters , obj_vals = obj_vals , valid = con_vals ) return obj_vals , con_vals def _explore_with_surrogate ( self , obj_model : SurrogateInterface , con_model : SurrogateInterface , y_best , index ): \"\"\"leverage the surrogate and optimize the acquicistion function\"\"\" # find the maximum of the acquisition function # find minimum of its negative x_min = None y_min = float ( \"inf\" ) def func ( x ): return - self . _acq_function ( obj_model = obj_model , con_model = con_model , x = x , y_best = y_best , index = index ) # func2 = lambda x: -self._acquisition_function_backup(gpr, classifier, x, y_best, xi) # generate starting points for global exploration warn_samples = self . _get_samples ( n_samples = self . _explore_num_warm_up ) # print(warn_samples.shape, self._explore_num_warm_up) res_array = [] # warn up for x0 in warn_samples : test_res = func ( x0 ) res_array . append ( test_res . item ( 0 )) if test_res < y_min : x_min = x0 y_min = test_res idx_array = np . argsort ( res_array ) . flatten () exploring_samples = warn_samples [ idx_array [: self . _explore_num_samples ], :] # print(idx_array[:self._explore_num_samples].shape, idx_array.shape, self._explore_num_samples) # exploring_samples = self._get_samples(n_samples=self._explore_num_samples) # exploring_samples = np.concatenate(warn_samples, exploring_samples) self . debug_print ( 1 , \"Finding exploration points...\" ) for x0 in exploring_samples : # print(\"run\", exploring_samples.shape) # print(\"inner\", x0, -func(x0), gpr.predict(x0.reshape(1, -1), return_std = True), classifier.predict_proba(x0.reshape(1, -1))) res = minimize ( func , x0 = x0 , bounds = self . _problem . bounds , method = \"L-BFGS-B\" ) # print(\"inner\", res.success, res.x, res.fun) if res . fun < y_min : x_min = res . x y_min = res . fun if self . _plot_debug and index % self . _plot_freq == 0 : self . _visualizer . plot_acquisition ( func , x_min ) self . _visualizer . plot_prediction ( obj_model = obj_model , hist = self . _hist , x_next = x_min ) if self . _consider_constraint : self . _visualizer . plot_classification ( con_model = con_model , hist = self . _hist , x_next = x_min ) # plot_acquisition(self._X_gold, func, x_min) # plot_acquisition(self._X_gold, func2, x_min) # print(f\"xmax = {x_min} y_max = {-y_min}, y_best = {y_best}\") # print(x_min, classifier.predict_proba(x_min.reshape(1, -1))) return x_min def expected_improvement ( self , obj_model , con_model , x , y_best , index ): # print(\"EI\") x = x . reshape ( 1 , - 1 ) mean , std = obj_model . predict ( x ) # print(mean, std) if std == 0.0 : return 0 if self . _consider_constraint : proba = con_model . predict ( x ) # print(proba) # proba = classifier.predict_proba(x) # compute the expected improvement den = mean - y_best - self . _xi Z = den / std ei = den * norm . cdf ( Z ) + std * norm . pdf ( Z ) # print(proba, classifier.classes_) # print(\"EI:\", ei) # Consider the probability of invalid inputs if self . _consider_constraint : if proba > 0.2 : return ei * proba else : return 0 else : return ei def upper_confidence_bound ( self , obj_model , con_model , x , y_best , index ): # print(\"UCB\") x = x . reshape ( 1 , - 1 ) mean , std = obj_model . predict ( x ) # print(mean, std) if std == 0.0 : return 0 if self . _consider_constraint : proba = con_model . predict ( x ) # print(proba) # proba = classifier.predict_proba(x) # compute the expected improvement beta = 2 * math . log (( index + 1 ) ** 2 ) ucb = mean + math . sqrt ( beta ) * std # print(proba, classifier.classes_) # print(\"EI:\", ei) # Consider the probability of invalid inputs if self . _consider_constraint : if proba > 0.2 : return ucb * proba else : return 0 else : return ucb optimize ( ** kwarg ) \u00b6 This function performs maximization!! Source code in sym_cps/optimizers/tools/optimization/bayesian_optimizer.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def optimize ( self , ** kwarg ): \"\"\"This function performs maximization!!\"\"\" if self . _plot_debug : self . _visualizer . plot_objectives () self . _visualizer . plot_finalize () self . _visualizer . plot_constraints () self . _visualizer . plot_finalize () self . set_args ( ** kwarg ) x_max_valid = None y_max_ind_valid = np . full ( self . _problem . obj_dim , - float ( \"inf\" )) # record the best obj value of valid design y_max_valid = np . full ( self . _problem . obj_dim , - float ( \"inf\" )) # record the best obj value of valid design # seed init x_init = np . array ( self . _problem . opt_array ) # warnup with random samples x_sample = self . _get_samples ( n_samples = self . _num_warn_up_samples ) # print(x_init, x_sample) x_sample = np . concatenate (( x_init . reshape ( 1 , - 1 ), x_sample )) # evaluate the random samples for x in x_sample : y , v = self . _evaluate ( parameters = x ) valid = np . all ( v ) if valid or not self . _consider_constraint : y_max_ind_valid = np . maximum ( y , y_max_ind_valid ) if self . _problem . obj_dominate ( y , y_max_valid ): # TODO: handle multi-objective parato front y_max_valid = y x_max_valid = x # print(self._hist.hist_params) # print(self._hist.hist_func) # print(self._hist.hist_valid) # start performing bayesian optimization for i in range ( self . _iteration ): self . debug_print ( 1 , \"iteration\" , i ) obj_model = self . _surrogate_model_obj ( kernel = self . _kernel ) con_model = self . _surrogate_model_con () x_explored = self . _hist . hist_params y_explored = self . _hist . hist_func v_explored = self . _hist . hist_valid obj_model . fit ( x_explored , y_explored ) if self . _consider_constraint : con_model . fit ( x_explored , v_explored ) # apply the surrogate x_min = self . _explore_with_surrogate ( obj_model = obj_model , con_model = con_model , y_best = y_max_ind_valid , index = i ) # evaluate the candidate y , v = self . _evaluate ( parameters = x_min ) valid = np . all ( v ) if valid or not self . _consider_constraint : y_max_ind_valid = np . maximum ( y , y_max_ind_valid ) if self . _problem . obj_dominate ( y , y_max_valid ): # TODO: handle multi-objective parato front y_max_valid = y x_max_valid = x print ( f \"Iteration { i } : x = { x_min } , y = { y } , y_max = { y_max_valid } \" ) return x_max_valid , y_max_valid","title":"bayesian_optimizer"},{"location":"reference/sym_cps/optimizers/tools/optimization/bayesian_optimizer/#sym_cps.optimizers.tools.optimization.bayesian_optimizer.BayesianOptimizer","text":"Bases: OptimizerBase Optimization usign Bayesian Optimization Taking a optimization problem, performs black box optimization which combines a classifier Input: problem: A ProblemBase object Source code in sym_cps/optimizers/tools/optimization/bayesian_optimizer.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 class BayesianOptimizer ( OptimizerBase ): \"\"\"Optimization usign Bayesian Optimization Taking a optimization problem, performs black box optimization which combines a classifier Input: problem: A ProblemBase object \"\"\" def __init__ ( self , problem : ProblemBase , debug_level = 1 , ** kwarg ): super () . __init__ ( problem = problem ) self . _visualizer = BayesianOptimizationVisualizer () self . _kernel = Matern ( nu = 2.5 , length_scale = 0.05 , length_scale_bounds = \"fixed\" ) # self._kernel = Matern(nu=2.5, length_scale=5000, length_scale_bounds = \"fixed\") self . _acq_function = self . expected_improvement self . _surrogate_model_obj : SurrogateInterface = ScikitGPR self . _surrogate_model_con : SurrogateInterface = LogisticClassifier self . _xi : float = 0.0 self . _rng = np . random . RandomState ( 1234 ) self . _iteration : int = 1000 self . _num_warn_up_samples : int = 10 self . _explore_num_warm_up : int = 200 self . _explore_num_samples : int = 25 self . _consider_constraint : bool = True self . _plot_debug : bool = False self . _plot_freq : int = 10 self . set_args ( ** kwarg ) if self . _plot_debug : self . _visualizer . initialize_design_space ( self . _problem ) def set_args ( self , ** kwarg ): if \"kernel\" in kwarg . keys (): print ( \"Setting Kernel...\" ) self . _kernel = kwarg [ \"kernel\" ] if \"acquisition_function\" in kwarg . keys (): if kwarg [ \"acquisition_function\" ] == \"GP-UCB\" : print ( \"Use GP-UCB as acquisition function\" ) self . _acq_function = self . upper_confidence_bound elif kwarg [ \"acquisition_function\" ] == \"EI\" : print ( \"Use EI as acquisition function\" ) self . _acq_function = self . expected_improvement else : s = kwarg [ \"acquisition_function\" ] print ( f \"Unknown Acquisition function type { s } \" ) if \"surrogate_model_obj\" in kwarg . keys (): self . _surrogate_model_obj = kwarg [ \"surrogate_model_obj\" ] if \"surrogate_model_con\" in kwarg . keys (): self . _surrogate_model_con = kwarg [ \"surrogate_model_con\" ] if \"random_generator\" in kwarg . keys (): self . _rng = kwarg [ \"random_generator\" ] if \"iteration\" in kwarg . keys (): self . _iteration = kwarg [ \"iteration\" ] if \"num_warn_up_samples\" in kwarg . keys (): print ( f \"Set numbers of warm up samples as { self . _num_warn_up_samples } \" ) self . _num_warn_up_samples = kwarg [ \"num_warn_up_samples\" ] if \"explore_num_warm_up\" in kwarg . keys (): self . _explore_num_warm_up = kwarg [ \"explore_num_warm_up\" ] print ( f \"Set numbers of exploration warm up samples as { self . _explore_num_warm_up } \" ) if \"explore_num_samples\" in kwarg . keys (): self . _explore_num_samples = kwarg [ \"explore_num_samples\" ] print ( f \"Set numbers of exploration samples as { self . _explore_num_samples } \" ) if \"consider_constraint\" in kwarg . keys (): self . _consider_constraint = kwarg [ \"consider_constraint\" ] if \"plot_debug\" in kwarg . keys (): self . _plot_debug = kwarg [ \"plot_debug\" ] if \"plot_freq\" in kwarg . keys (): self . _plot_freq = kwarg [ \"plot_freq\" ] def _get_samples ( self , n_samples ): ubound = np . array ([ u_b for ( _ , u_b ) in self . _problem . bounds ]) lbound = np . array ([ l_b for ( l_b , _ ) in self . _problem . bounds ]) return self . _rng . uniform ( low = lbound , high = ubound , size = ( n_samples , self . _problem . dim )) def optimize ( self , ** kwarg ): \"\"\"This function performs maximization!!\"\"\" if self . _plot_debug : self . _visualizer . plot_objectives () self . _visualizer . plot_finalize () self . _visualizer . plot_constraints () self . _visualizer . plot_finalize () self . set_args ( ** kwarg ) x_max_valid = None y_max_ind_valid = np . full ( self . _problem . obj_dim , - float ( \"inf\" )) # record the best obj value of valid design y_max_valid = np . full ( self . _problem . obj_dim , - float ( \"inf\" )) # record the best obj value of valid design # seed init x_init = np . array ( self . _problem . opt_array ) # warnup with random samples x_sample = self . _get_samples ( n_samples = self . _num_warn_up_samples ) # print(x_init, x_sample) x_sample = np . concatenate (( x_init . reshape ( 1 , - 1 ), x_sample )) # evaluate the random samples for x in x_sample : y , v = self . _evaluate ( parameters = x ) valid = np . all ( v ) if valid or not self . _consider_constraint : y_max_ind_valid = np . maximum ( y , y_max_ind_valid ) if self . _problem . obj_dominate ( y , y_max_valid ): # TODO: handle multi-objective parato front y_max_valid = y x_max_valid = x # print(self._hist.hist_params) # print(self._hist.hist_func) # print(self._hist.hist_valid) # start performing bayesian optimization for i in range ( self . _iteration ): self . debug_print ( 1 , \"iteration\" , i ) obj_model = self . _surrogate_model_obj ( kernel = self . _kernel ) con_model = self . _surrogate_model_con () x_explored = self . _hist . hist_params y_explored = self . _hist . hist_func v_explored = self . _hist . hist_valid obj_model . fit ( x_explored , y_explored ) if self . _consider_constraint : con_model . fit ( x_explored , v_explored ) # apply the surrogate x_min = self . _explore_with_surrogate ( obj_model = obj_model , con_model = con_model , y_best = y_max_ind_valid , index = i ) # evaluate the candidate y , v = self . _evaluate ( parameters = x_min ) valid = np . all ( v ) if valid or not self . _consider_constraint : y_max_ind_valid = np . maximum ( y , y_max_ind_valid ) if self . _problem . obj_dominate ( y , y_max_valid ): # TODO: handle multi-objective parato front y_max_valid = y x_max_valid = x print ( f \"Iteration { i } : x = { x_min } , y = { y } , y_max = { y_max_valid } \" ) return x_max_valid , y_max_valid def _evaluate ( self , parameters : npt . ArrayLike , record : bool = True , idx : int | None = None ) -> tuple [ list [ float ], list [ bool ]]: \"\"\"Evaluates the parameters and returns the objective function value and constraints satisfaction\"\"\" obj_vals , con_vals = self . _problem . evaluate ( parameters ) if idx is not None : obj_vals = obj_vals [ idx ] con_vals = con_vals [ idx ] if record : self . _hist . add_hist ( params = parameters , obj_vals = obj_vals , valid = con_vals ) return obj_vals , con_vals def _explore_with_surrogate ( self , obj_model : SurrogateInterface , con_model : SurrogateInterface , y_best , index ): \"\"\"leverage the surrogate and optimize the acquicistion function\"\"\" # find the maximum of the acquisition function # find minimum of its negative x_min = None y_min = float ( \"inf\" ) def func ( x ): return - self . _acq_function ( obj_model = obj_model , con_model = con_model , x = x , y_best = y_best , index = index ) # func2 = lambda x: -self._acquisition_function_backup(gpr, classifier, x, y_best, xi) # generate starting points for global exploration warn_samples = self . _get_samples ( n_samples = self . _explore_num_warm_up ) # print(warn_samples.shape, self._explore_num_warm_up) res_array = [] # warn up for x0 in warn_samples : test_res = func ( x0 ) res_array . append ( test_res . item ( 0 )) if test_res < y_min : x_min = x0 y_min = test_res idx_array = np . argsort ( res_array ) . flatten () exploring_samples = warn_samples [ idx_array [: self . _explore_num_samples ], :] # print(idx_array[:self._explore_num_samples].shape, idx_array.shape, self._explore_num_samples) # exploring_samples = self._get_samples(n_samples=self._explore_num_samples) # exploring_samples = np.concatenate(warn_samples, exploring_samples) self . debug_print ( 1 , \"Finding exploration points...\" ) for x0 in exploring_samples : # print(\"run\", exploring_samples.shape) # print(\"inner\", x0, -func(x0), gpr.predict(x0.reshape(1, -1), return_std = True), classifier.predict_proba(x0.reshape(1, -1))) res = minimize ( func , x0 = x0 , bounds = self . _problem . bounds , method = \"L-BFGS-B\" ) # print(\"inner\", res.success, res.x, res.fun) if res . fun < y_min : x_min = res . x y_min = res . fun if self . _plot_debug and index % self . _plot_freq == 0 : self . _visualizer . plot_acquisition ( func , x_min ) self . _visualizer . plot_prediction ( obj_model = obj_model , hist = self . _hist , x_next = x_min ) if self . _consider_constraint : self . _visualizer . plot_classification ( con_model = con_model , hist = self . _hist , x_next = x_min ) # plot_acquisition(self._X_gold, func, x_min) # plot_acquisition(self._X_gold, func2, x_min) # print(f\"xmax = {x_min} y_max = {-y_min}, y_best = {y_best}\") # print(x_min, classifier.predict_proba(x_min.reshape(1, -1))) return x_min def expected_improvement ( self , obj_model , con_model , x , y_best , index ): # print(\"EI\") x = x . reshape ( 1 , - 1 ) mean , std = obj_model . predict ( x ) # print(mean, std) if std == 0.0 : return 0 if self . _consider_constraint : proba = con_model . predict ( x ) # print(proba) # proba = classifier.predict_proba(x) # compute the expected improvement den = mean - y_best - self . _xi Z = den / std ei = den * norm . cdf ( Z ) + std * norm . pdf ( Z ) # print(proba, classifier.classes_) # print(\"EI:\", ei) # Consider the probability of invalid inputs if self . _consider_constraint : if proba > 0.2 : return ei * proba else : return 0 else : return ei def upper_confidence_bound ( self , obj_model , con_model , x , y_best , index ): # print(\"UCB\") x = x . reshape ( 1 , - 1 ) mean , std = obj_model . predict ( x ) # print(mean, std) if std == 0.0 : return 0 if self . _consider_constraint : proba = con_model . predict ( x ) # print(proba) # proba = classifier.predict_proba(x) # compute the expected improvement beta = 2 * math . log (( index + 1 ) ** 2 ) ucb = mean + math . sqrt ( beta ) * std # print(proba, classifier.classes_) # print(\"EI:\", ei) # Consider the probability of invalid inputs if self . _consider_constraint : if proba > 0.2 : return ucb * proba else : return 0 else : return ucb","title":"BayesianOptimizer"},{"location":"reference/sym_cps/optimizers/tools/optimization/bayesian_optimizer/#sym_cps.optimizers.tools.optimization.bayesian_optimizer.BayesianOptimizer.optimize","text":"This function performs maximization!! Source code in sym_cps/optimizers/tools/optimization/bayesian_optimizer.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def optimize ( self , ** kwarg ): \"\"\"This function performs maximization!!\"\"\" if self . _plot_debug : self . _visualizer . plot_objectives () self . _visualizer . plot_finalize () self . _visualizer . plot_constraints () self . _visualizer . plot_finalize () self . set_args ( ** kwarg ) x_max_valid = None y_max_ind_valid = np . full ( self . _problem . obj_dim , - float ( \"inf\" )) # record the best obj value of valid design y_max_valid = np . full ( self . _problem . obj_dim , - float ( \"inf\" )) # record the best obj value of valid design # seed init x_init = np . array ( self . _problem . opt_array ) # warnup with random samples x_sample = self . _get_samples ( n_samples = self . _num_warn_up_samples ) # print(x_init, x_sample) x_sample = np . concatenate (( x_init . reshape ( 1 , - 1 ), x_sample )) # evaluate the random samples for x in x_sample : y , v = self . _evaluate ( parameters = x ) valid = np . all ( v ) if valid or not self . _consider_constraint : y_max_ind_valid = np . maximum ( y , y_max_ind_valid ) if self . _problem . obj_dominate ( y , y_max_valid ): # TODO: handle multi-objective parato front y_max_valid = y x_max_valid = x # print(self._hist.hist_params) # print(self._hist.hist_func) # print(self._hist.hist_valid) # start performing bayesian optimization for i in range ( self . _iteration ): self . debug_print ( 1 , \"iteration\" , i ) obj_model = self . _surrogate_model_obj ( kernel = self . _kernel ) con_model = self . _surrogate_model_con () x_explored = self . _hist . hist_params y_explored = self . _hist . hist_func v_explored = self . _hist . hist_valid obj_model . fit ( x_explored , y_explored ) if self . _consider_constraint : con_model . fit ( x_explored , v_explored ) # apply the surrogate x_min = self . _explore_with_surrogate ( obj_model = obj_model , con_model = con_model , y_best = y_max_ind_valid , index = i ) # evaluate the candidate y , v = self . _evaluate ( parameters = x_min ) valid = np . all ( v ) if valid or not self . _consider_constraint : y_max_ind_valid = np . maximum ( y , y_max_ind_valid ) if self . _problem . obj_dominate ( y , y_max_valid ): # TODO: handle multi-objective parato front y_max_valid = y x_max_valid = x print ( f \"Iteration { i } : x = { x_min } , y = { y } , y_max = { y_max_valid } \" ) return x_max_valid , y_max_valid","title":"optimize()"},{"location":"reference/sym_cps/optimizers/tools/optimization/cem_optimizer/","text":"","title":"cem_optimizer"},{"location":"reference/sym_cps/optimizers/tools/optimization/nm_optimizer/","text":"NMOptimizer \u00b6 Bases: OptimizerBase Optimization usign Nealson-Mead Local Optimization Taking a optimization problem, performs black box optimization which combines a classifier Input: problem: A ProblemBase object Source code in sym_cps/optimizers/tools/optimization/nm_optimizer.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class NMOptimizer ( OptimizerBase ): \"\"\"Optimization usign Nealson-Mead Local Optimization Taking a optimization problem, performs black box optimization which combines a classifier Input: problem: A ProblemBase object \"\"\" def __init__ ( self , problem : ProblemBase , ** kwarg ): super () . __init__ ( problem = problem ) self . set_args ( ** kwarg ) self . _maxiter = 100000 self . _x0 = self . _problem . opt_array def set_args ( self , ** kwarg ): if \"maxiter\" in kwarg : self . _maxiter = kwarg [ \"maxiter\" ] if \"x0\" in kwarg : self . _x0 = kwarg [ \"x0\" ] def _get_samples ( self , n_samples ): ubound = np . array ([ u_b for ( _ , u_b ) in self . _problem . bounds ]) lbound = np . array ([ l_b for ( l_b , _ ) in self . _problem . bounds ]) return self . _rng . uniform ( low = lbound , high = ubound , size = ( self . _num_warn_up_samples , self . _problem . dim )) def optimize ( self , ** kwarg ): # init x list self . set_args ( ** kwarg ) options = {} options [ \"maxiter\" ] = self . _maxiter options [ \"disp\" ] = True print ( self . _evaluate ( np . array ( self . _x0 ), idx = 0 )) ret = minimize ( lambda x : - self . _evaluate ( x , idx = 0 ), x0 = self . _x0 , bounds = self . _problem . bounds , method = \"Nelder-Mead\" , options = options , ) print ( ret . x , ret . fun ) return ret . x , ret . fun def _evaluate ( self , parameters : npt . ArrayLike , record : bool = True , idx : int | None = None ) -> tuple [ list [ float ], list [ bool ]]: \"\"\"Evaluates the parameters and returns the objective function value and constraints satisfaction\"\"\" obj_vals , con_vals = self . _problem . evaluate ( parameters ) if idx is not None : obj_vals = obj_vals [ idx ] con_vals = con_vals [ idx ] if record : self . _hist . add_hist ( params = parameters , obj_vals = obj_vals , valid = con_vals ) return obj_vals","title":"nm_optimizer"},{"location":"reference/sym_cps/optimizers/tools/optimization/nm_optimizer/#sym_cps.optimizers.tools.optimization.nm_optimizer.NMOptimizer","text":"Bases: OptimizerBase Optimization usign Nealson-Mead Local Optimization Taking a optimization problem, performs black box optimization which combines a classifier Input: problem: A ProblemBase object Source code in sym_cps/optimizers/tools/optimization/nm_optimizer.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class NMOptimizer ( OptimizerBase ): \"\"\"Optimization usign Nealson-Mead Local Optimization Taking a optimization problem, performs black box optimization which combines a classifier Input: problem: A ProblemBase object \"\"\" def __init__ ( self , problem : ProblemBase , ** kwarg ): super () . __init__ ( problem = problem ) self . set_args ( ** kwarg ) self . _maxiter = 100000 self . _x0 = self . _problem . opt_array def set_args ( self , ** kwarg ): if \"maxiter\" in kwarg : self . _maxiter = kwarg [ \"maxiter\" ] if \"x0\" in kwarg : self . _x0 = kwarg [ \"x0\" ] def _get_samples ( self , n_samples ): ubound = np . array ([ u_b for ( _ , u_b ) in self . _problem . bounds ]) lbound = np . array ([ l_b for ( l_b , _ ) in self . _problem . bounds ]) return self . _rng . uniform ( low = lbound , high = ubound , size = ( self . _num_warn_up_samples , self . _problem . dim )) def optimize ( self , ** kwarg ): # init x list self . set_args ( ** kwarg ) options = {} options [ \"maxiter\" ] = self . _maxiter options [ \"disp\" ] = True print ( self . _evaluate ( np . array ( self . _x0 ), idx = 0 )) ret = minimize ( lambda x : - self . _evaluate ( x , idx = 0 ), x0 = self . _x0 , bounds = self . _problem . bounds , method = \"Nelder-Mead\" , options = options , ) print ( ret . x , ret . fun ) return ret . x , ret . fun def _evaluate ( self , parameters : npt . ArrayLike , record : bool = True , idx : int | None = None ) -> tuple [ list [ float ], list [ bool ]]: \"\"\"Evaluates the parameters and returns the objective function value and constraints satisfaction\"\"\" obj_vals , con_vals = self . _problem . evaluate ( parameters ) if idx is not None : obj_vals = obj_vals [ idx ] con_vals = con_vals [ idx ] if record : self . _hist . add_hist ( params = parameters , obj_vals = obj_vals , valid = con_vals ) return obj_vals","title":"NMOptimizer"},{"location":"reference/sym_cps/optimizers/tools/optimization/optimizer_base/","text":"optimizer_base.py Define the class OptimizerBase as an abstract class for optimizer. OptimizerBase \u00b6 Bases: ABC Define the base class for all optimizer, either a self-implemented optimzer or an interface to other optimization library Source code in sym_cps/optimizers/tools/optimization/optimizer_base.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 class OptimizerBase ( ABC ): \"\"\" Define the base class for all optimizer, either a self-implemented optimzer or an interface to other optimization library \"\"\" def __init__ ( self , problem : ProblemBase , debug_level = 1 ): # debug_level 1: print every detail during each iteration # debug_level 2: print every steps in the algorithm self . _problem : ProblemBase = problem self . _debug_level : int = debug_level self . _fail_value : float = float ( \"inf\" ) self . _hist : History = History () self . reset_history () @abstractmethod def set_args ( self , ** kwarg ): \"\"\"Set the arguments before calling optimize\"\"\" @abstractmethod def optimize ( self , ** kwarg ): \"\"\" Abstract method that optimizes a design problem Implementation \"\"\" def reset_history ( self ): \"\"\"Clear all history\"\"\" x_dim = self . _problem . dim self . _hist . reset_history ( x_dim , self . _problem . obj_dim , self . _problem . con_dim ) @property def hist ( self ) -> History : return self . _hist def debug_print ( self , level_constraint : int , * args , ** kwargs ): if self . _debug_level > level_constraint : print ( * args , ** kwargs ) @abstractmethod def _evaluate ( self , parameters : npt . ArrayLike , record : bool = True , idx : int | None = None ) -> tuple [ list [ float ], list [ bool ]]: \"\"\"Evaluates the parameters and returns the objective function value and constraints satisfaction\"\"\" obj_vals , con_vals = self . _problem . evaluete ( parameters ) if record : self . _hist . add_hist ( params = parameters , obj_vals = obj_vals , valid = con_vals ) return obj_vals , con_vals def _update_parameters ( self , parameters : npt . ArrayLike ) -> None : self . _problem . set_parameters ( parameters = parameters ) optimize ( ** kwarg ) abstractmethod \u00b6 Abstract method that optimizes a design problem Implementation Source code in sym_cps/optimizers/tools/optimization/optimizer_base.py 37 38 39 40 41 42 @abstractmethod def optimize ( self , ** kwarg ): \"\"\" Abstract method that optimizes a design problem Implementation \"\"\" reset_history () \u00b6 Clear all history Source code in sym_cps/optimizers/tools/optimization/optimizer_base.py 44 45 46 47 def reset_history ( self ): \"\"\"Clear all history\"\"\" x_dim = self . _problem . dim self . _hist . reset_history ( x_dim , self . _problem . obj_dim , self . _problem . con_dim ) set_args ( ** kwarg ) abstractmethod \u00b6 Set the arguments before calling optimize Source code in sym_cps/optimizers/tools/optimization/optimizer_base.py 33 34 35 @abstractmethod def set_args ( self , ** kwarg ): \"\"\"Set the arguments before calling optimize\"\"\"","title":"optimizer_base"},{"location":"reference/sym_cps/optimizers/tools/optimization/optimizer_base/#sym_cps.optimizers.tools.optimization.optimizer_base.OptimizerBase","text":"Bases: ABC Define the base class for all optimizer, either a self-implemented optimzer or an interface to other optimization library Source code in sym_cps/optimizers/tools/optimization/optimizer_base.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 class OptimizerBase ( ABC ): \"\"\" Define the base class for all optimizer, either a self-implemented optimzer or an interface to other optimization library \"\"\" def __init__ ( self , problem : ProblemBase , debug_level = 1 ): # debug_level 1: print every detail during each iteration # debug_level 2: print every steps in the algorithm self . _problem : ProblemBase = problem self . _debug_level : int = debug_level self . _fail_value : float = float ( \"inf\" ) self . _hist : History = History () self . reset_history () @abstractmethod def set_args ( self , ** kwarg ): \"\"\"Set the arguments before calling optimize\"\"\" @abstractmethod def optimize ( self , ** kwarg ): \"\"\" Abstract method that optimizes a design problem Implementation \"\"\" def reset_history ( self ): \"\"\"Clear all history\"\"\" x_dim = self . _problem . dim self . _hist . reset_history ( x_dim , self . _problem . obj_dim , self . _problem . con_dim ) @property def hist ( self ) -> History : return self . _hist def debug_print ( self , level_constraint : int , * args , ** kwargs ): if self . _debug_level > level_constraint : print ( * args , ** kwargs ) @abstractmethod def _evaluate ( self , parameters : npt . ArrayLike , record : bool = True , idx : int | None = None ) -> tuple [ list [ float ], list [ bool ]]: \"\"\"Evaluates the parameters and returns the objective function value and constraints satisfaction\"\"\" obj_vals , con_vals = self . _problem . evaluete ( parameters ) if record : self . _hist . add_hist ( params = parameters , obj_vals = obj_vals , valid = con_vals ) return obj_vals , con_vals def _update_parameters ( self , parameters : npt . ArrayLike ) -> None : self . _problem . set_parameters ( parameters = parameters )","title":"OptimizerBase"},{"location":"reference/sym_cps/optimizers/tools/optimization/optimizer_base/#sym_cps.optimizers.tools.optimization.optimizer_base.OptimizerBase.optimize","text":"Abstract method that optimizes a design problem Implementation Source code in sym_cps/optimizers/tools/optimization/optimizer_base.py 37 38 39 40 41 42 @abstractmethod def optimize ( self , ** kwarg ): \"\"\" Abstract method that optimizes a design problem Implementation \"\"\"","title":"optimize()"},{"location":"reference/sym_cps/optimizers/tools/optimization/optimizer_base/#sym_cps.optimizers.tools.optimization.optimizer_base.OptimizerBase.reset_history","text":"Clear all history Source code in sym_cps/optimizers/tools/optimization/optimizer_base.py 44 45 46 47 def reset_history ( self ): \"\"\"Clear all history\"\"\" x_dim = self . _problem . dim self . _hist . reset_history ( x_dim , self . _problem . obj_dim , self . _problem . con_dim )","title":"reset_history()"},{"location":"reference/sym_cps/optimizers/tools/optimization/optimizer_base/#sym_cps.optimizers.tools.optimization.optimizer_base.OptimizerBase.set_args","text":"Set the arguments before calling optimize Source code in sym_cps/optimizers/tools/optimization/optimizer_base.py 33 34 35 @abstractmethod def set_args ( self , ** kwarg ): \"\"\"Set the arguments before calling optimize\"\"\"","title":"set_args()"},{"location":"reference/sym_cps/optimizers/tools/optimization/problem_base/","text":"ProblemBase \u00b6 Bases: ABC The base class for the Optimization Problem _bounds: list[Tuple[float, float]]the bound (box constraints) for the design problem. The first element of the tuple is the lower bound and the other element is the upper bound For example, [(1,5), (2,4)] can be used to represent the box constraints $1 < x < 5, 2 < y < 4$. _opt_array: the numpy array that are used as initial value. Source code in sym_cps/optimizers/tools/optimization/problem_base.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class ProblemBase ( ABC ): \"\"\"The base class for the Optimization Problem _bounds: list[Tuple[float, float]]the bound (box constraints) for the design problem. The first element of the tuple is the lower bound and the other element is the upper bound For example, [(1,5), (2,4)] can be used to represent the box constraints $1 < x < 5, 2 < y < 4$. _opt_array: the numpy array that are used as initial value. \"\"\" def __init__ ( self ): self . _bounds : list [ tuple [ float , float ]] = None self . _opt_array : npt . ArrayLike = None self . _obj_dim = 0 self . _con_dim = 0 @property def dim ( self ): \"\"\"Number of optimization variables\"\"\" return len ( self . _bounds ) @property def obj_dim ( self ): return self . _obj_dim def set_obj_dim ( self , dim : int ): self . _obj_dim = dim @property def opt_array ( self ) -> npt . ArrayLike : return self . _opt_array @property def con_dim ( self ): return self . _con_dim def set_con_dim ( self , dim : int ): self . _con_dim = dim @abstractmethod def obj_dominate ( self , obj1 : npt . ArrayLike , obj2 : npt . ArrayLike ): pass @property def bounds ( self ): \"\"\"The bounds of the optimization problem\"\"\" return self . _bounds @abstractmethod def evaluate ( self , parameters : npt . ArrayLike ) -> tuple [ list [ float ], list [ bool ]]: \"\"\"return the objective function or invalid parameters\"\"\" @abstractmethod def set_parameters ( self , parameters : npt . ArrayLike ) -> None : pass bounds () property \u00b6 The bounds of the optimization problem Source code in sym_cps/optimizers/tools/optimization/problem_base.py 47 48 49 50 @property def bounds ( self ): \"\"\"The bounds of the optimization problem\"\"\" return self . _bounds dim () property \u00b6 Number of optimization variables Source code in sym_cps/optimizers/tools/optimization/problem_base.py 20 21 22 23 @property def dim ( self ): \"\"\"Number of optimization variables\"\"\" return len ( self . _bounds ) evaluate ( parameters ) abstractmethod \u00b6 return the objective function or invalid parameters Source code in sym_cps/optimizers/tools/optimization/problem_base.py 52 53 54 @abstractmethod def evaluate ( self , parameters : npt . ArrayLike ) -> tuple [ list [ float ], list [ bool ]]: \"\"\"return the objective function or invalid parameters\"\"\"","title":"problem_base"},{"location":"reference/sym_cps/optimizers/tools/optimization/problem_base/#sym_cps.optimizers.tools.optimization.problem_base.ProblemBase","text":"Bases: ABC The base class for the Optimization Problem _bounds: list[Tuple[float, float]]the bound (box constraints) for the design problem. The first element of the tuple is the lower bound and the other element is the upper bound For example, [(1,5), (2,4)] can be used to represent the box constraints $1 < x < 5, 2 < y < 4$. _opt_array: the numpy array that are used as initial value. Source code in sym_cps/optimizers/tools/optimization/problem_base.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class ProblemBase ( ABC ): \"\"\"The base class for the Optimization Problem _bounds: list[Tuple[float, float]]the bound (box constraints) for the design problem. The first element of the tuple is the lower bound and the other element is the upper bound For example, [(1,5), (2,4)] can be used to represent the box constraints $1 < x < 5, 2 < y < 4$. _opt_array: the numpy array that are used as initial value. \"\"\" def __init__ ( self ): self . _bounds : list [ tuple [ float , float ]] = None self . _opt_array : npt . ArrayLike = None self . _obj_dim = 0 self . _con_dim = 0 @property def dim ( self ): \"\"\"Number of optimization variables\"\"\" return len ( self . _bounds ) @property def obj_dim ( self ): return self . _obj_dim def set_obj_dim ( self , dim : int ): self . _obj_dim = dim @property def opt_array ( self ) -> npt . ArrayLike : return self . _opt_array @property def con_dim ( self ): return self . _con_dim def set_con_dim ( self , dim : int ): self . _con_dim = dim @abstractmethod def obj_dominate ( self , obj1 : npt . ArrayLike , obj2 : npt . ArrayLike ): pass @property def bounds ( self ): \"\"\"The bounds of the optimization problem\"\"\" return self . _bounds @abstractmethod def evaluate ( self , parameters : npt . ArrayLike ) -> tuple [ list [ float ], list [ bool ]]: \"\"\"return the objective function or invalid parameters\"\"\" @abstractmethod def set_parameters ( self , parameters : npt . ArrayLike ) -> None : pass","title":"ProblemBase"},{"location":"reference/sym_cps/optimizers/tools/optimization/problem_base/#sym_cps.optimizers.tools.optimization.problem_base.ProblemBase.bounds","text":"The bounds of the optimization problem Source code in sym_cps/optimizers/tools/optimization/problem_base.py 47 48 49 50 @property def bounds ( self ): \"\"\"The bounds of the optimization problem\"\"\" return self . _bounds","title":"bounds()"},{"location":"reference/sym_cps/optimizers/tools/optimization/problem_base/#sym_cps.optimizers.tools.optimization.problem_base.ProblemBase.dim","text":"Number of optimization variables Source code in sym_cps/optimizers/tools/optimization/problem_base.py 20 21 22 23 @property def dim ( self ): \"\"\"Number of optimization variables\"\"\" return len ( self . _bounds )","title":"dim()"},{"location":"reference/sym_cps/optimizers/tools/optimization/problem_base/#sym_cps.optimizers.tools.optimization.problem_base.ProblemBase.evaluate","text":"return the objective function or invalid parameters Source code in sym_cps/optimizers/tools/optimization/problem_base.py 52 53 54 @abstractmethod def evaluate ( self , parameters : npt . ArrayLike ) -> tuple [ list [ float ], list [ bool ]]: \"\"\"return the objective function or invalid parameters\"\"\"","title":"evaluate()"},{"location":"reference/sym_cps/optimizers/tools/optimization/test_optimization/","text":"","title":"test_optimization"},{"location":"reference/sym_cps/optimizers/tools/optimization/test_optimization/test_bayesian_opt/","text":"TestProblem \u00b6 Bases: ProblemBase Source code in sym_cps/optimizers/tools/optimization/test_optimization/test_bayesian_opt.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class TestProblem ( ProblemBase ): def __init__ ( self , bounds , opt_array , obj_dim , con_dim , obj_func , con_func ): self . _bounds : list [ tuple [ float , float ]] = bounds self . _opt_array : npt . ArrayLike = opt_array self . _obj_dim = obj_dim self . _con_dim = con_dim self . _obj_func = obj_func self . _con_func = con_func def obj_dominate ( self , obj1 : npt . ArrayLike , obj2 : npt . ArrayLike ): return obj1 [ 0 ] > obj2 [ 0 ] def evaluate ( self , parameters : npt . ArrayLike ): \"\"\"return the objective function or invalid parameters\"\"\" return self . _obj_func ( parameters ), self . _con_func ( parameters ) def set_parameters ( self , parameters : npt . ArrayLike ) -> None : pass evaluate ( parameters ) \u00b6 return the objective function or invalid parameters Source code in sym_cps/optimizers/tools/optimization/test_optimization/test_bayesian_opt.py 21 22 23 def evaluate ( self , parameters : npt . ArrayLike ): \"\"\"return the objective function or invalid parameters\"\"\" return self . _obj_func ( parameters ), self . _con_func ( parameters ) drop_wave_equation_1d ( x ) \u00b6 1 dimensional simplification of drop wave equation from https://www.sfu.ca/~ssurjano/drop.html The drop wave equation has multiple local minima Source code in sym_cps/optimizers/tools/optimization/test_optimization/test_bayesian_opt.py 29 30 31 32 33 34 def drop_wave_equation_1d ( x ): \"\"\" 1 dimensional simplification of drop wave equation from https://www.sfu.ca/~ssurjano/drop.html The drop wave equation has multiple local minima \"\"\" return - ( 1 + np . cos ( 12 * np . sqrt ( x ** 2 ))) / (( 0.5 * x ** 2 ) + 2 )","title":"test_bayesian_opt"},{"location":"reference/sym_cps/optimizers/tools/optimization/test_optimization/test_bayesian_opt/#sym_cps.optimizers.tools.optimization.test_optimization.test_bayesian_opt.TestProblem","text":"Bases: ProblemBase Source code in sym_cps/optimizers/tools/optimization/test_optimization/test_bayesian_opt.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class TestProblem ( ProblemBase ): def __init__ ( self , bounds , opt_array , obj_dim , con_dim , obj_func , con_func ): self . _bounds : list [ tuple [ float , float ]] = bounds self . _opt_array : npt . ArrayLike = opt_array self . _obj_dim = obj_dim self . _con_dim = con_dim self . _obj_func = obj_func self . _con_func = con_func def obj_dominate ( self , obj1 : npt . ArrayLike , obj2 : npt . ArrayLike ): return obj1 [ 0 ] > obj2 [ 0 ] def evaluate ( self , parameters : npt . ArrayLike ): \"\"\"return the objective function or invalid parameters\"\"\" return self . _obj_func ( parameters ), self . _con_func ( parameters ) def set_parameters ( self , parameters : npt . ArrayLike ) -> None : pass","title":"TestProblem"},{"location":"reference/sym_cps/optimizers/tools/optimization/test_optimization/test_bayesian_opt/#sym_cps.optimizers.tools.optimization.test_optimization.test_bayesian_opt.TestProblem.evaluate","text":"return the objective function or invalid parameters Source code in sym_cps/optimizers/tools/optimization/test_optimization/test_bayesian_opt.py 21 22 23 def evaluate ( self , parameters : npt . ArrayLike ): \"\"\"return the objective function or invalid parameters\"\"\" return self . _obj_func ( parameters ), self . _con_func ( parameters )","title":"evaluate()"},{"location":"reference/sym_cps/optimizers/tools/optimization/test_optimization/test_bayesian_opt/#sym_cps.optimizers.tools.optimization.test_optimization.test_bayesian_opt.drop_wave_equation_1d","text":"1 dimensional simplification of drop wave equation from https://www.sfu.ca/~ssurjano/drop.html The drop wave equation has multiple local minima Source code in sym_cps/optimizers/tools/optimization/test_optimization/test_bayesian_opt.py 29 30 31 32 33 34 def drop_wave_equation_1d ( x ): \"\"\" 1 dimensional simplification of drop wave equation from https://www.sfu.ca/~ssurjano/drop.html The drop wave equation has multiple local minima \"\"\" return - ( 1 + np . cos ( 12 * np . sqrt ( x ** 2 ))) / (( 0.5 * x ** 2 ) + 2 )","title":"drop_wave_equation_1d()"},{"location":"reference/sym_cps/optimizers/tools/optimization/util/","text":"","title":"util"},{"location":"reference/sym_cps/optimizers/tools/optimization/util/exceptions/","text":"InValidDesignException \u00b6 Bases: Exception Class Invalid Design Exception Source code in sym_cps/optimizers/tools/optimization/util/exceptions.py 1 2 class InValidDesignException ( Exception ): \"\"\"Class Invalid Design Exception\"\"\"","title":"exceptions"},{"location":"reference/sym_cps/optimizers/tools/optimization/util/exceptions/#sym_cps.optimizers.tools.optimization.util.exceptions.InValidDesignException","text":"Bases: Exception Class Invalid Design Exception Source code in sym_cps/optimizers/tools/optimization/util/exceptions.py 1 2 class InValidDesignException ( Exception ): \"\"\"Class Invalid Design Exception\"\"\"","title":"InValidDesignException"},{"location":"reference/sym_cps/optimizers/tools/optimization/util/history/","text":"History \u00b6 Source code in sym_cps/optimizers/tools/optimization/util/history.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 class History : def __init__ ( self ): self . _hist_p = None # params self . _hist_c_f = None # combined obj self . _hist_c_v = None # combined obj self . _hist_p_f = None # params self . _hist_f = None # func values self . _hist_p_v = None # params_valid self . _hist_v = None # valid def reset_history ( self , p_dim , num_obj , num_con ): \"\"\"Clear all history\"\"\" self . _hist_p = np . array ([]) . reshape (( 0 , p_dim )) self . _hist_c_f = np . array ([]) . reshape (( 0 , num_obj )) self . _hist_c_v = np . array ([]) . reshape (( 0 , num_con )) self . _hist_p_f = np . array ([]) . reshape (( 0 , p_dim )) self . _hist_f = np . array ([]) . reshape (( 0 , num_obj )) self . _hist_p_v = np . array ([]) . reshape (( 0 , p_dim )) self . _hist_v = np . array ([]) . reshape (( 0 , num_con )) def add_hist ( self , params , obj_vals , valid ): \"\"\"Push a data point to the history\"\"\" obj_vals = np . array ( obj_vals ) valid = np . array ( valid ) self . _hist_p = np . concatenate (( self . _hist_p , params . reshape ( 1 , - 1 ))) self . _hist_c_f = np . concatenate (( self . _hist_c_f , obj_vals . reshape ( 1 , - 1 ))) self . _hist_c_v = np . concatenate (( self . _hist_c_v , valid . reshape ( 1 , - 1 ))) if obj_vals is not None : self . _hist_p_f = np . concatenate (( self . _hist_p_f , params . reshape ( 1 , - 1 ))) self . _hist_f = np . concatenate (( self . _hist_f , obj_vals . reshape ( 1 , - 1 ))) if valid is not None : self . _hist_p_v = np . concatenate (( self . _hist_p_v , params . reshape ( 1 , - 1 ))) self . _hist_v = np . concatenate (( self . _hist_v , valid . reshape ( 1 , - 1 ))) @property def length_obj ( self ): return len ( self . _hist_p ) @property def length_obj ( self ): return len ( self . _hist_p_v ) @property def hist_params ( self ): return self . _hist_p def hist_combined_obj ( self ): return self . _hist_c_f def hist_combined_con ( self ): return self . _hist_c_v @property def hist_params_for_objective ( self ): return self . _hist_p_f @property def hist_func ( self ): return self . _hist_f @property def hist_param_for_valid ( self ): return self . _hist_p_v @property def hist_valid ( self ): return self . _hist_v @property def hist ( self ): return ( self . hist_params , self . hist_combined_obj , self . hist_combined_con , self . hist_params_for_objective , self . hist_func , self . hist_param_for_valid , self . hist_valid , ) add_hist ( params , obj_vals , valid ) \u00b6 Push a data point to the history Source code in sym_cps/optimizers/tools/optimization/util/history.py 26 27 28 29 30 31 32 33 34 35 36 37 38 def add_hist ( self , params , obj_vals , valid ): \"\"\"Push a data point to the history\"\"\" obj_vals = np . array ( obj_vals ) valid = np . array ( valid ) self . _hist_p = np . concatenate (( self . _hist_p , params . reshape ( 1 , - 1 ))) self . _hist_c_f = np . concatenate (( self . _hist_c_f , obj_vals . reshape ( 1 , - 1 ))) self . _hist_c_v = np . concatenate (( self . _hist_c_v , valid . reshape ( 1 , - 1 ))) if obj_vals is not None : self . _hist_p_f = np . concatenate (( self . _hist_p_f , params . reshape ( 1 , - 1 ))) self . _hist_f = np . concatenate (( self . _hist_f , obj_vals . reshape ( 1 , - 1 ))) if valid is not None : self . _hist_p_v = np . concatenate (( self . _hist_p_v , params . reshape ( 1 , - 1 ))) self . _hist_v = np . concatenate (( self . _hist_v , valid . reshape ( 1 , - 1 ))) reset_history ( p_dim , num_obj , num_con ) \u00b6 Clear all history Source code in sym_cps/optimizers/tools/optimization/util/history.py 16 17 18 19 20 21 22 23 24 def reset_history ( self , p_dim , num_obj , num_con ): \"\"\"Clear all history\"\"\" self . _hist_p = np . array ([]) . reshape (( 0 , p_dim )) self . _hist_c_f = np . array ([]) . reshape (( 0 , num_obj )) self . _hist_c_v = np . array ([]) . reshape (( 0 , num_con )) self . _hist_p_f = np . array ([]) . reshape (( 0 , p_dim )) self . _hist_f = np . array ([]) . reshape (( 0 , num_obj )) self . _hist_p_v = np . array ([]) . reshape (( 0 , p_dim )) self . _hist_v = np . array ([]) . reshape (( 0 , num_con ))","title":"history"},{"location":"reference/sym_cps/optimizers/tools/optimization/util/history/#sym_cps.optimizers.tools.optimization.util.history.History","text":"Source code in sym_cps/optimizers/tools/optimization/util/history.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 class History : def __init__ ( self ): self . _hist_p = None # params self . _hist_c_f = None # combined obj self . _hist_c_v = None # combined obj self . _hist_p_f = None # params self . _hist_f = None # func values self . _hist_p_v = None # params_valid self . _hist_v = None # valid def reset_history ( self , p_dim , num_obj , num_con ): \"\"\"Clear all history\"\"\" self . _hist_p = np . array ([]) . reshape (( 0 , p_dim )) self . _hist_c_f = np . array ([]) . reshape (( 0 , num_obj )) self . _hist_c_v = np . array ([]) . reshape (( 0 , num_con )) self . _hist_p_f = np . array ([]) . reshape (( 0 , p_dim )) self . _hist_f = np . array ([]) . reshape (( 0 , num_obj )) self . _hist_p_v = np . array ([]) . reshape (( 0 , p_dim )) self . _hist_v = np . array ([]) . reshape (( 0 , num_con )) def add_hist ( self , params , obj_vals , valid ): \"\"\"Push a data point to the history\"\"\" obj_vals = np . array ( obj_vals ) valid = np . array ( valid ) self . _hist_p = np . concatenate (( self . _hist_p , params . reshape ( 1 , - 1 ))) self . _hist_c_f = np . concatenate (( self . _hist_c_f , obj_vals . reshape ( 1 , - 1 ))) self . _hist_c_v = np . concatenate (( self . _hist_c_v , valid . reshape ( 1 , - 1 ))) if obj_vals is not None : self . _hist_p_f = np . concatenate (( self . _hist_p_f , params . reshape ( 1 , - 1 ))) self . _hist_f = np . concatenate (( self . _hist_f , obj_vals . reshape ( 1 , - 1 ))) if valid is not None : self . _hist_p_v = np . concatenate (( self . _hist_p_v , params . reshape ( 1 , - 1 ))) self . _hist_v = np . concatenate (( self . _hist_v , valid . reshape ( 1 , - 1 ))) @property def length_obj ( self ): return len ( self . _hist_p ) @property def length_obj ( self ): return len ( self . _hist_p_v ) @property def hist_params ( self ): return self . _hist_p def hist_combined_obj ( self ): return self . _hist_c_f def hist_combined_con ( self ): return self . _hist_c_v @property def hist_params_for_objective ( self ): return self . _hist_p_f @property def hist_func ( self ): return self . _hist_f @property def hist_param_for_valid ( self ): return self . _hist_p_v @property def hist_valid ( self ): return self . _hist_v @property def hist ( self ): return ( self . hist_params , self . hist_combined_obj , self . hist_combined_con , self . hist_params_for_objective , self . hist_func , self . hist_param_for_valid , self . hist_valid , )","title":"History"},{"location":"reference/sym_cps/optimizers/tools/optimization/util/history/#sym_cps.optimizers.tools.optimization.util.history.History.add_hist","text":"Push a data point to the history Source code in sym_cps/optimizers/tools/optimization/util/history.py 26 27 28 29 30 31 32 33 34 35 36 37 38 def add_hist ( self , params , obj_vals , valid ): \"\"\"Push a data point to the history\"\"\" obj_vals = np . array ( obj_vals ) valid = np . array ( valid ) self . _hist_p = np . concatenate (( self . _hist_p , params . reshape ( 1 , - 1 ))) self . _hist_c_f = np . concatenate (( self . _hist_c_f , obj_vals . reshape ( 1 , - 1 ))) self . _hist_c_v = np . concatenate (( self . _hist_c_v , valid . reshape ( 1 , - 1 ))) if obj_vals is not None : self . _hist_p_f = np . concatenate (( self . _hist_p_f , params . reshape ( 1 , - 1 ))) self . _hist_f = np . concatenate (( self . _hist_f , obj_vals . reshape ( 1 , - 1 ))) if valid is not None : self . _hist_p_v = np . concatenate (( self . _hist_p_v , params . reshape ( 1 , - 1 ))) self . _hist_v = np . concatenate (( self . _hist_v , valid . reshape ( 1 , - 1 )))","title":"add_hist()"},{"location":"reference/sym_cps/optimizers/tools/optimization/util/history/#sym_cps.optimizers.tools.optimization.util.history.History.reset_history","text":"Clear all history Source code in sym_cps/optimizers/tools/optimization/util/history.py 16 17 18 19 20 21 22 23 24 def reset_history ( self , p_dim , num_obj , num_con ): \"\"\"Clear all history\"\"\" self . _hist_p = np . array ([]) . reshape (( 0 , p_dim )) self . _hist_c_f = np . array ([]) . reshape (( 0 , num_obj )) self . _hist_c_v = np . array ([]) . reshape (( 0 , num_con )) self . _hist_p_f = np . array ([]) . reshape (( 0 , p_dim )) self . _hist_f = np . array ([]) . reshape (( 0 , num_obj )) self . _hist_p_v = np . array ([]) . reshape (( 0 , p_dim )) self . _hist_v = np . array ([]) . reshape (( 0 , num_con ))","title":"reset_history()"},{"location":"reference/sym_cps/optimizers/tools/optimization/util/surrogate/","text":"SurrogateInterface \u00b6 Bases: ABC Source code in sym_cps/optimizers/tools/optimization/util/surrogate.py 8 9 10 11 12 13 14 15 16 17 18 class SurrogateInterface ( ABC ): def __init__ ( self ): pass @abstractmethod def fit ( self , X , Y ): \"\"\"Built the surrogate model\"\"\" @abstractmethod def predict ( self , x ): \"\"\"Access the model\"\"\" fit ( X , Y ) abstractmethod \u00b6 Built the surrogate model Source code in sym_cps/optimizers/tools/optimization/util/surrogate.py 12 13 14 @abstractmethod def fit ( self , X , Y ): \"\"\"Built the surrogate model\"\"\" predict ( x ) abstractmethod \u00b6 Access the model Source code in sym_cps/optimizers/tools/optimization/util/surrogate.py 16 17 18 @abstractmethod def predict ( self , x ): \"\"\"Access the model\"\"\"","title":"surrogate"},{"location":"reference/sym_cps/optimizers/tools/optimization/util/surrogate/#sym_cps.optimizers.tools.optimization.util.surrogate.SurrogateInterface","text":"Bases: ABC Source code in sym_cps/optimizers/tools/optimization/util/surrogate.py 8 9 10 11 12 13 14 15 16 17 18 class SurrogateInterface ( ABC ): def __init__ ( self ): pass @abstractmethod def fit ( self , X , Y ): \"\"\"Built the surrogate model\"\"\" @abstractmethod def predict ( self , x ): \"\"\"Access the model\"\"\"","title":"SurrogateInterface"},{"location":"reference/sym_cps/optimizers/tools/optimization/util/surrogate/#sym_cps.optimizers.tools.optimization.util.surrogate.SurrogateInterface.fit","text":"Built the surrogate model Source code in sym_cps/optimizers/tools/optimization/util/surrogate.py 12 13 14 @abstractmethod def fit ( self , X , Y ): \"\"\"Built the surrogate model\"\"\"","title":"fit()"},{"location":"reference/sym_cps/optimizers/tools/optimization/util/surrogate/#sym_cps.optimizers.tools.optimization.util.surrogate.SurrogateInterface.predict","text":"Access the model Source code in sym_cps/optimizers/tools/optimization/util/surrogate.py 16 17 18 @abstractmethod def predict ( self , x ): \"\"\"Access the model\"\"\"","title":"predict()"},{"location":"reference/sym_cps/optimizers/tools/optimization/util/visualize/","text":"visualize.py Define the class ContinuousDesignProblemVisualizer for visualing the continous optimization problem ContinuousProblemVisualizer \u00b6 Bases: object Used for visualizing the design problem and design space Source code in sym_cps/optimizers/tools/optimization/util/visualize.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 class ContinuousProblemVisualizer ( object ): \"\"\"Used for visualizing the design problem and design space\"\"\" def __init__ ( self , resolution : int = 100 ): self . _problem = None self . _res = resolution self . _x = None self . _y = None self . _xv = None self . _yv = None self . _f_gold = None self . _x_valid = None self . _dim = None @property def res ( self ) -> int : return self . _res @res . setter def res ( self , res ): self . _res = res def initialize_design_space ( self , problem : ProblemBase ): \"\"\"Plot the design space (Only apply to 1d or 2d design space)\"\"\" self . _problem = problem lbound = [ l_b for ( l_b , _ ) in problem . bounds ] ubound = [ u_b for ( _ , u_b ) in problem . bounds ] if self . _problem . dim == 1 : self . _dim = 1 self . _x = np . linspace ( lbound [ 0 ], ubound [ 0 ], self . res ) self . _f_gold = self . _get_F_1d ( self . _x ) # function value self . _x_valid = self . _get_valid_1d ( self . _x ) elif self . _problem . dim == 2 : self . _dim = 2 self . _x = np . linspace ( lbound [ 0 ], ubound [ 0 ], self . res ) self . _y = np . linspace ( lbound [ 1 ], ubound [ 1 ], self . res ) self . _xv , self . _yv = np . meshgrid ( self . _x , self . _y ) self . _f_gold = self . _get_F_2d ( self . _xv , self . _yv ) # function value self . _x_valid = self . _get_valid_2d ( self . _xv , self . _yv ) else : raise Exception ( \"Not supported for high dimension\" ) def _get_F_1d ( self , x_array : npt . ArrayLike ): \"\"\"Get all objectives in the design space\"\"\" problem_dim = self . _problem . obj_dim f_shape = ( * ( x_array . shape ), problem_dim ) # adding dimensions, each element becomes multiple objectives f_array = np . zeros ( f_shape ) for i , _x in enumerate ( x_array ): obj_vals , con_vals = self . _problem . evaluate ( np . array ([ _x ])) f_array [ i ] = obj_vals . flatten () return f_array def _get_F_2d ( self , xv_array : npt . ArrayLike , yv_array : npt . ArrayLike ): problem_dim = self . _problem . obj_dim f_shape = ( * ( xv_array . shape ), problem_dim ) # adding dimensions, each element becomes multiple objectives f_array = np . zeros ( f_shape ) for i in range ( xv_array . shape [ 0 ]): for j in range ( xv_array . shape [ 1 ]): obj_vals , con_vals = self . _problem . evaluate ( np . array ([ xv_array [ i , j ], yv_array [ i , j ]])) f_array [ i , j ] = obj_vals . flatten () return f_array def _get_valid_1d ( self , x_array : npt . ArrayLike ): \"\"\"Get all constraints in the design space\"\"\" constraint_dim = self . _problem . con_dim x_valid_shape = ( * ( x_array . shape ), constraint_dim , ) # adding dimensions, each element becomes multiple objectives x_valid = np . zeros ( x_valid_shape ) for i , _x in enumerate ( x_array ): obj_vals , con_vals = self . _problem . evaluate ( np . array ([ _x ])) x_valid [ i ] = con_vals . flatten () return x_valid def _get_valid_2d ( self , xv_array : npt . ArrayLike , yv_array : npt . ArrayLike ): constraint_dim = self . _problem . con_dim x_valid_shape = ( * ( xv_array . shape ), constraint_dim ) # adding dimensions, each element becomes multiple objectives x_valid_array = np . zeros ( x_valid_shape ) for i in range ( xv_array . shape [ 0 ]): for j in range ( xv_array . shape [ 1 ]): obj_vals , con_vals = self . _problem . evaluate ( np . array ([ xv_array [ i , j ], yv_array [ i , j ]])) x_valid_array [ i , j ] = con_vals . flatten () return x_valid_array def plot_objectives ( self , show : bool = False , idx : int = None ): if self . _dim == 1 : self . _plot_objectives_1d ( idx = idx ) elif self . _dim == 2 : self . _plot_objectives_2d ( idx = idx ) else : raise Exception ( f \"Dimension ( { self . _dim } ) not supported!\" ) if show : self . plot_finalize () def plot_constraints ( self , show : bool = False , idx : int = None ): if self . _dim == 1 : self . _plot_constraints_1d ( idx = idx ) elif self . _dim == 2 : self . _plot_constraints_2d ( idx = idx ) else : raise Exception ( f \"Dimension ( { self . _dim } ) not supported!\" ) if show : self . plot_finalize () def plot_optimizer_hist_params_1d ( self , optimizer : OptimizerBase ): \"\"\"Plot the searched point of 1d\"\"\" hist = optimizer . hist p_hist = hist . hist_params_for_objective f_hist = hist . hist_func p_hist_v = hist . hist_params_for_valid plt . scatter ( p_hist , f_hist , color = cm . Greys ( np . linspace ( 0 , 1 , hist . length )), marker = \"x\" ) plt . scatter ( p_hist_v , np . zeros ( p_hist_v . shape [ 0 ]), marker = \"x\" , color = \"red\" ) plt . legend () def plot_optimizer_hist_params_2d ( self , optimizer : OptimizerBase ): \"\"\"Plot the searched point of 2d\"\"\" hist = optimizer . hist p_hist = hist . hist_params plt . scatter ( p_hist [:, 0 ], p_hist [:, 1 ], color = cm . Greys ( np . linspace ( 0 , 1 , hist . length )), marker = \"x\" ) # plt.legend() def plot_best_params_1d ( self , best_param , best_f ): plt . scatter ( best_param , best_f , c = \"cyan\" , marker = \"*\" , label = \"Best\" ) plt . legend () def plot_best_params_2d ( self , best_param ): plt . scatter ( best_param [ 0 ], best_param [ 1 ], c = \"cyan\" , marker = \"*\" , label = \"Best\" ) plt . legend () def plot_optimizer_convergence ( self , optimizer : OptimizerBase ): f_hist = optimizer . hist . hist_combined_obj v_hist = optimizer . hist . hist_combined_con f_best = float ( \"inf\" ) f_best_hist = np . zeros ( f_hist . shape ) for i , f in enumerate ( f_hist ): if f is None : continue if f < f_best and v_hist [ i ]: f_best = f f_best_hist [ i ] = f_best plt . plot ( np . arange ( 1 , f_hist . shape [ 0 ] + 1 ), f_best_hist . flatten () - f_best , label = \"convergence\" ) plt . yscale ( \"log\" ) plt . legend () plt . title ( \"Convergence\" ) plt . show () # def plot_history_1d(self, hist_x: npt.ArrayLike, hist_f: npt.ArrayLike): # \"\"\"Plot the 1d history provided in the space\"\"\" # plt.plot(hist_x, hist_f, color=cm.Greys(np.linspace(0, 1, hist_x.shape[0])), marker='x', mew=3, label='samples') # def plot_history_2d(self, hist_x: npt.ArrayLike): # \"\"\"Plot the 2d history provided in the space\"\"\" # plt.scatter(hist_x[:, 0], hist_x[:, 1], color=cm.Greys(np.linspace(0, 1, hist_x.shape[0])), marker = \"x\") # def plot_best_point_1d(self, best_pos: npt.ArrayLike, best_val: float): # \"\"\"Plot the optimal point finded in the space\"\"\" # plt.scatter(best_pos, best_val, c = \"cyan\", marker=\"*\") # def plot_best_point_2d(self, best_pos: npt.ArrayLike): # \"\"\"Plot the optimal point finded in the space\"\"\" # plt.scatter(best_pos[0], best_pos[1], c = \"cyan\", marker=\"*\") def plot_finalize ( self ): plt . show () def _plot_objectives_1d ( self , idx : int = None ): if idx is None : for idx in range ( self . _f_gold . shape [ - 1 ]): plt . plot ( self . _x , self . _f_gold [:, idx ], \"y--\" , lw = 1 , label = f \"objective { idx } \" ) else : plt . plot ( self . _x , self . _f_gold [:, idx ], \"y--\" , lw = 1 , label = f \"objective { idx } \" ) plt . legend () def _plot_objectives_2d ( self , idx : int = None ): if idx is None : for idx in range ( self . _f_gold . shape [ - 1 ]): c = plt . pcolormesh ( self . _xv , self . _yv , self . _f_gold [ 1 :, 1 :, idx ], cmap = \"coolwarm\" , shading = \"flat\" , label = f \"objective { idx } \" , ) plt . colorbar ( c ) else : c = plt . pcolormesh ( self . _xv , self . _yv , self . _f_gold [ 1 :, 1 :, idx ], cmap = \"coolwarm\" , shading = \"flat\" , label = f \"objective { idx } \" ) plt . colorbar ( c ) def _plot_constraints_1d ( self , idx : int = None ): if idx is None : for idx in range ( self . _x_valid . shape [ - 1 ]): plt . plot ( self . _x , self . _x_valid [:, idx ], \"y--\" , lw = 1 , label = f \"constraint { idx } \" ) else : plt . plot ( self . _x , self . _x_valid [:, idx ], \"y--\" , lw = 1 , label = f \"constraint { idx } \" ) plt . legend () def _plot_constraints_2d ( self , idx : int = None ): if idx is None : for idx in range ( self . _x_valid . shape [ - 1 ]): c = plt . pcolormesh ( self . _xv , self . _yv , self . _x_valid [ 1 :, 1 :, idx ], cmap = \"coolwarm\" , shading = \"flat\" , label = f \"constraint { idx } \" , ) plt . colorbar ( c ) else : c = plt . pcolormesh ( self . _xv , self . _yv , self . _x_valid [ 1 :, 1 :, idx ], cmap = \"coolwarm\" , shading = \"flat\" , label = f \"constraint { idx } \" , ) plt . colorbar ( c ) initialize_design_space ( problem ) \u00b6 Plot the design space (Only apply to 1d or 2d design space) Source code in sym_cps/optimizers/tools/optimization/util/visualize.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def initialize_design_space ( self , problem : ProblemBase ): \"\"\"Plot the design space (Only apply to 1d or 2d design space)\"\"\" self . _problem = problem lbound = [ l_b for ( l_b , _ ) in problem . bounds ] ubound = [ u_b for ( _ , u_b ) in problem . bounds ] if self . _problem . dim == 1 : self . _dim = 1 self . _x = np . linspace ( lbound [ 0 ], ubound [ 0 ], self . res ) self . _f_gold = self . _get_F_1d ( self . _x ) # function value self . _x_valid = self . _get_valid_1d ( self . _x ) elif self . _problem . dim == 2 : self . _dim = 2 self . _x = np . linspace ( lbound [ 0 ], ubound [ 0 ], self . res ) self . _y = np . linspace ( lbound [ 1 ], ubound [ 1 ], self . res ) self . _xv , self . _yv = np . meshgrid ( self . _x , self . _y ) self . _f_gold = self . _get_F_2d ( self . _xv , self . _yv ) # function value self . _x_valid = self . _get_valid_2d ( self . _xv , self . _yv ) else : raise Exception ( \"Not supported for high dimension\" ) plot_optimizer_hist_params_1d ( optimizer ) \u00b6 Plot the searched point of 1d Source code in sym_cps/optimizers/tools/optimization/util/visualize.py 129 130 131 132 133 134 135 136 137 138 def plot_optimizer_hist_params_1d ( self , optimizer : OptimizerBase ): \"\"\"Plot the searched point of 1d\"\"\" hist = optimizer . hist p_hist = hist . hist_params_for_objective f_hist = hist . hist_func p_hist_v = hist . hist_params_for_valid plt . scatter ( p_hist , f_hist , color = cm . Greys ( np . linspace ( 0 , 1 , hist . length )), marker = \"x\" ) plt . scatter ( p_hist_v , np . zeros ( p_hist_v . shape [ 0 ]), marker = \"x\" , color = \"red\" ) plt . legend () plot_optimizer_hist_params_2d ( optimizer ) \u00b6 Plot the searched point of 2d Source code in sym_cps/optimizers/tools/optimization/util/visualize.py 140 141 142 143 144 145 def plot_optimizer_hist_params_2d ( self , optimizer : OptimizerBase ): \"\"\"Plot the searched point of 2d\"\"\" hist = optimizer . hist p_hist = hist . hist_params plt . scatter ( p_hist [:, 0 ], p_hist [:, 1 ], color = cm . Greys ( np . linspace ( 0 , 1 , hist . length )), marker = \"x\" )","title":"visualize"},{"location":"reference/sym_cps/optimizers/tools/optimization/util/visualize/#sym_cps.optimizers.tools.optimization.util.visualize.ContinuousProblemVisualizer","text":"Bases: object Used for visualizing the design problem and design space Source code in sym_cps/optimizers/tools/optimization/util/visualize.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 class ContinuousProblemVisualizer ( object ): \"\"\"Used for visualizing the design problem and design space\"\"\" def __init__ ( self , resolution : int = 100 ): self . _problem = None self . _res = resolution self . _x = None self . _y = None self . _xv = None self . _yv = None self . _f_gold = None self . _x_valid = None self . _dim = None @property def res ( self ) -> int : return self . _res @res . setter def res ( self , res ): self . _res = res def initialize_design_space ( self , problem : ProblemBase ): \"\"\"Plot the design space (Only apply to 1d or 2d design space)\"\"\" self . _problem = problem lbound = [ l_b for ( l_b , _ ) in problem . bounds ] ubound = [ u_b for ( _ , u_b ) in problem . bounds ] if self . _problem . dim == 1 : self . _dim = 1 self . _x = np . linspace ( lbound [ 0 ], ubound [ 0 ], self . res ) self . _f_gold = self . _get_F_1d ( self . _x ) # function value self . _x_valid = self . _get_valid_1d ( self . _x ) elif self . _problem . dim == 2 : self . _dim = 2 self . _x = np . linspace ( lbound [ 0 ], ubound [ 0 ], self . res ) self . _y = np . linspace ( lbound [ 1 ], ubound [ 1 ], self . res ) self . _xv , self . _yv = np . meshgrid ( self . _x , self . _y ) self . _f_gold = self . _get_F_2d ( self . _xv , self . _yv ) # function value self . _x_valid = self . _get_valid_2d ( self . _xv , self . _yv ) else : raise Exception ( \"Not supported for high dimension\" ) def _get_F_1d ( self , x_array : npt . ArrayLike ): \"\"\"Get all objectives in the design space\"\"\" problem_dim = self . _problem . obj_dim f_shape = ( * ( x_array . shape ), problem_dim ) # adding dimensions, each element becomes multiple objectives f_array = np . zeros ( f_shape ) for i , _x in enumerate ( x_array ): obj_vals , con_vals = self . _problem . evaluate ( np . array ([ _x ])) f_array [ i ] = obj_vals . flatten () return f_array def _get_F_2d ( self , xv_array : npt . ArrayLike , yv_array : npt . ArrayLike ): problem_dim = self . _problem . obj_dim f_shape = ( * ( xv_array . shape ), problem_dim ) # adding dimensions, each element becomes multiple objectives f_array = np . zeros ( f_shape ) for i in range ( xv_array . shape [ 0 ]): for j in range ( xv_array . shape [ 1 ]): obj_vals , con_vals = self . _problem . evaluate ( np . array ([ xv_array [ i , j ], yv_array [ i , j ]])) f_array [ i , j ] = obj_vals . flatten () return f_array def _get_valid_1d ( self , x_array : npt . ArrayLike ): \"\"\"Get all constraints in the design space\"\"\" constraint_dim = self . _problem . con_dim x_valid_shape = ( * ( x_array . shape ), constraint_dim , ) # adding dimensions, each element becomes multiple objectives x_valid = np . zeros ( x_valid_shape ) for i , _x in enumerate ( x_array ): obj_vals , con_vals = self . _problem . evaluate ( np . array ([ _x ])) x_valid [ i ] = con_vals . flatten () return x_valid def _get_valid_2d ( self , xv_array : npt . ArrayLike , yv_array : npt . ArrayLike ): constraint_dim = self . _problem . con_dim x_valid_shape = ( * ( xv_array . shape ), constraint_dim ) # adding dimensions, each element becomes multiple objectives x_valid_array = np . zeros ( x_valid_shape ) for i in range ( xv_array . shape [ 0 ]): for j in range ( xv_array . shape [ 1 ]): obj_vals , con_vals = self . _problem . evaluate ( np . array ([ xv_array [ i , j ], yv_array [ i , j ]])) x_valid_array [ i , j ] = con_vals . flatten () return x_valid_array def plot_objectives ( self , show : bool = False , idx : int = None ): if self . _dim == 1 : self . _plot_objectives_1d ( idx = idx ) elif self . _dim == 2 : self . _plot_objectives_2d ( idx = idx ) else : raise Exception ( f \"Dimension ( { self . _dim } ) not supported!\" ) if show : self . plot_finalize () def plot_constraints ( self , show : bool = False , idx : int = None ): if self . _dim == 1 : self . _plot_constraints_1d ( idx = idx ) elif self . _dim == 2 : self . _plot_constraints_2d ( idx = idx ) else : raise Exception ( f \"Dimension ( { self . _dim } ) not supported!\" ) if show : self . plot_finalize () def plot_optimizer_hist_params_1d ( self , optimizer : OptimizerBase ): \"\"\"Plot the searched point of 1d\"\"\" hist = optimizer . hist p_hist = hist . hist_params_for_objective f_hist = hist . hist_func p_hist_v = hist . hist_params_for_valid plt . scatter ( p_hist , f_hist , color = cm . Greys ( np . linspace ( 0 , 1 , hist . length )), marker = \"x\" ) plt . scatter ( p_hist_v , np . zeros ( p_hist_v . shape [ 0 ]), marker = \"x\" , color = \"red\" ) plt . legend () def plot_optimizer_hist_params_2d ( self , optimizer : OptimizerBase ): \"\"\"Plot the searched point of 2d\"\"\" hist = optimizer . hist p_hist = hist . hist_params plt . scatter ( p_hist [:, 0 ], p_hist [:, 1 ], color = cm . Greys ( np . linspace ( 0 , 1 , hist . length )), marker = \"x\" ) # plt.legend() def plot_best_params_1d ( self , best_param , best_f ): plt . scatter ( best_param , best_f , c = \"cyan\" , marker = \"*\" , label = \"Best\" ) plt . legend () def plot_best_params_2d ( self , best_param ): plt . scatter ( best_param [ 0 ], best_param [ 1 ], c = \"cyan\" , marker = \"*\" , label = \"Best\" ) plt . legend () def plot_optimizer_convergence ( self , optimizer : OptimizerBase ): f_hist = optimizer . hist . hist_combined_obj v_hist = optimizer . hist . hist_combined_con f_best = float ( \"inf\" ) f_best_hist = np . zeros ( f_hist . shape ) for i , f in enumerate ( f_hist ): if f is None : continue if f < f_best and v_hist [ i ]: f_best = f f_best_hist [ i ] = f_best plt . plot ( np . arange ( 1 , f_hist . shape [ 0 ] + 1 ), f_best_hist . flatten () - f_best , label = \"convergence\" ) plt . yscale ( \"log\" ) plt . legend () plt . title ( \"Convergence\" ) plt . show () # def plot_history_1d(self, hist_x: npt.ArrayLike, hist_f: npt.ArrayLike): # \"\"\"Plot the 1d history provided in the space\"\"\" # plt.plot(hist_x, hist_f, color=cm.Greys(np.linspace(0, 1, hist_x.shape[0])), marker='x', mew=3, label='samples') # def plot_history_2d(self, hist_x: npt.ArrayLike): # \"\"\"Plot the 2d history provided in the space\"\"\" # plt.scatter(hist_x[:, 0], hist_x[:, 1], color=cm.Greys(np.linspace(0, 1, hist_x.shape[0])), marker = \"x\") # def plot_best_point_1d(self, best_pos: npt.ArrayLike, best_val: float): # \"\"\"Plot the optimal point finded in the space\"\"\" # plt.scatter(best_pos, best_val, c = \"cyan\", marker=\"*\") # def plot_best_point_2d(self, best_pos: npt.ArrayLike): # \"\"\"Plot the optimal point finded in the space\"\"\" # plt.scatter(best_pos[0], best_pos[1], c = \"cyan\", marker=\"*\") def plot_finalize ( self ): plt . show () def _plot_objectives_1d ( self , idx : int = None ): if idx is None : for idx in range ( self . _f_gold . shape [ - 1 ]): plt . plot ( self . _x , self . _f_gold [:, idx ], \"y--\" , lw = 1 , label = f \"objective { idx } \" ) else : plt . plot ( self . _x , self . _f_gold [:, idx ], \"y--\" , lw = 1 , label = f \"objective { idx } \" ) plt . legend () def _plot_objectives_2d ( self , idx : int = None ): if idx is None : for idx in range ( self . _f_gold . shape [ - 1 ]): c = plt . pcolormesh ( self . _xv , self . _yv , self . _f_gold [ 1 :, 1 :, idx ], cmap = \"coolwarm\" , shading = \"flat\" , label = f \"objective { idx } \" , ) plt . colorbar ( c ) else : c = plt . pcolormesh ( self . _xv , self . _yv , self . _f_gold [ 1 :, 1 :, idx ], cmap = \"coolwarm\" , shading = \"flat\" , label = f \"objective { idx } \" ) plt . colorbar ( c ) def _plot_constraints_1d ( self , idx : int = None ): if idx is None : for idx in range ( self . _x_valid . shape [ - 1 ]): plt . plot ( self . _x , self . _x_valid [:, idx ], \"y--\" , lw = 1 , label = f \"constraint { idx } \" ) else : plt . plot ( self . _x , self . _x_valid [:, idx ], \"y--\" , lw = 1 , label = f \"constraint { idx } \" ) plt . legend () def _plot_constraints_2d ( self , idx : int = None ): if idx is None : for idx in range ( self . _x_valid . shape [ - 1 ]): c = plt . pcolormesh ( self . _xv , self . _yv , self . _x_valid [ 1 :, 1 :, idx ], cmap = \"coolwarm\" , shading = \"flat\" , label = f \"constraint { idx } \" , ) plt . colorbar ( c ) else : c = plt . pcolormesh ( self . _xv , self . _yv , self . _x_valid [ 1 :, 1 :, idx ], cmap = \"coolwarm\" , shading = \"flat\" , label = f \"constraint { idx } \" , ) plt . colorbar ( c )","title":"ContinuousProblemVisualizer"},{"location":"reference/sym_cps/optimizers/tools/optimization/util/visualize/#sym_cps.optimizers.tools.optimization.util.visualize.ContinuousProblemVisualizer.initialize_design_space","text":"Plot the design space (Only apply to 1d or 2d design space) Source code in sym_cps/optimizers/tools/optimization/util/visualize.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def initialize_design_space ( self , problem : ProblemBase ): \"\"\"Plot the design space (Only apply to 1d or 2d design space)\"\"\" self . _problem = problem lbound = [ l_b for ( l_b , _ ) in problem . bounds ] ubound = [ u_b for ( _ , u_b ) in problem . bounds ] if self . _problem . dim == 1 : self . _dim = 1 self . _x = np . linspace ( lbound [ 0 ], ubound [ 0 ], self . res ) self . _f_gold = self . _get_F_1d ( self . _x ) # function value self . _x_valid = self . _get_valid_1d ( self . _x ) elif self . _problem . dim == 2 : self . _dim = 2 self . _x = np . linspace ( lbound [ 0 ], ubound [ 0 ], self . res ) self . _y = np . linspace ( lbound [ 1 ], ubound [ 1 ], self . res ) self . _xv , self . _yv = np . meshgrid ( self . _x , self . _y ) self . _f_gold = self . _get_F_2d ( self . _xv , self . _yv ) # function value self . _x_valid = self . _get_valid_2d ( self . _xv , self . _yv ) else : raise Exception ( \"Not supported for high dimension\" )","title":"initialize_design_space()"},{"location":"reference/sym_cps/optimizers/tools/optimization/util/visualize/#sym_cps.optimizers.tools.optimization.util.visualize.ContinuousProblemVisualizer.plot_optimizer_hist_params_1d","text":"Plot the searched point of 1d Source code in sym_cps/optimizers/tools/optimization/util/visualize.py 129 130 131 132 133 134 135 136 137 138 def plot_optimizer_hist_params_1d ( self , optimizer : OptimizerBase ): \"\"\"Plot the searched point of 1d\"\"\" hist = optimizer . hist p_hist = hist . hist_params_for_objective f_hist = hist . hist_func p_hist_v = hist . hist_params_for_valid plt . scatter ( p_hist , f_hist , color = cm . Greys ( np . linspace ( 0 , 1 , hist . length )), marker = \"x\" ) plt . scatter ( p_hist_v , np . zeros ( p_hist_v . shape [ 0 ]), marker = \"x\" , color = \"red\" ) plt . legend ()","title":"plot_optimizer_hist_params_1d()"},{"location":"reference/sym_cps/optimizers/tools/optimization/util/visualize/#sym_cps.optimizers.tools.optimization.util.visualize.ContinuousProblemVisualizer.plot_optimizer_hist_params_2d","text":"Plot the searched point of 2d Source code in sym_cps/optimizers/tools/optimization/util/visualize.py 140 141 142 143 144 145 def plot_optimizer_hist_params_2d ( self , optimizer : OptimizerBase ): \"\"\"Plot the searched point of 2d\"\"\" hist = optimizer . hist p_hist = hist . hist_params plt . scatter ( p_hist [:, 0 ], p_hist [:, 1 ], color = cm . Greys ( np . linspace ( 0 , 1 , hist . length )), marker = \"x\" )","title":"plot_optimizer_hist_params_2d()"},{"location":"reference/sym_cps/optimizers/topo_opt/","text":"","title":"topo_opt"},{"location":"reference/sym_cps/representation/","text":"","title":"representation"},{"location":"reference/sym_cps/representation/design/","text":"","title":"design"},{"location":"reference/sym_cps/representation/design/tools/","text":"","title":"tools"},{"location":"reference/sym_cps/representation/design/concrete/","text":"Test Documentation DConcrete dataclass \u00b6 A class representing a Concrete Design ... Attributes \u00b6 str name of the design dict[str, DesignParameter] design parameters Source code in sym_cps/representation/design/concrete/__init__.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 @dataclass class DConcrete : \"\"\" A class representing a Concrete Design ... Attributes ---------- name : str name of the design design_parameters : dict[str, DesignParameter] design parameters \"\"\" name : str description : str = \"\" design_parameters : dict [ str , DesignParameter ] = field ( default_factory = dict ) comp_id_to_node : dict [ str , Vertex ] = field ( default_factory = dict ) def __post_init__ ( self ): self . _graph = Graph ( directed = True ) self . description = \"empty_description\" @classmethod def from_abstract_topology ( cls , topo : AbstractTopology ): d_concrete = cls ( name = topo . name ) for component_a , connections in topo . connections . items (): node_a_vertex = d_concrete . add_default_node ( component_a ) \"\"\"Parameters\"\"\" if component_a in topo . parameters . keys (): node_a_vertex [ \"component\" ] . update_parameters ( topo . parameters [ component_a ]) \"\"\"Connections\"\"\" for component_b , direction in connections . items (): node_b_vertex = d_concrete . add_default_node ( component_b ) connection = Connection . from_direction ( component_a = node_a_vertex [ \"component\" ], component_b = node_b_vertex [ \"component\" ], direction = direction , ) d_concrete . connect ( connection ) return d_concrete @property def graph ( self ) -> Graph : return self . _graph @property def nodes ( self ) -> list [ Vertex ]: return list ( self . graph . vs ) @property def edges ( self ) -> list [ Edge ]: return list ( self . graph . es ) def get_vertex_by_id ( self , vid : int ) -> Vertex : return self . graph . vs [ vid ] @property def n_nodes ( self ) -> int : return len ( self . graph . vs ) @property def n_edges ( self ) -> int : return len ( self . graph . es ) def export_parameters ( self ) -> dict [ str , dict [ str , Parameter ]]: pass def add_default_node ( self , abstract_component_id : str ) -> Vertex : if abstract_component_id in self . comp_id_to_node . keys (): return self . comp_id_to_node [ abstract_component_id ] id_split = abstract_component_id . split ( \"_\" ) try : if id_split [ - 2 ] == \"instance\" : node_type_a = \"_\" . join ( id_split [: - 2 ]) else : node_type_a = abstract_component_id except : node_type_a = abstract_component_id from sym_cps.shared.library import c_library lib_comp_a = c_library . get_default_component ( node_type_a ) instance_a = Component ( id = abstract_component_id , library_component = lib_comp_a ) self . comp_id_to_node [ abstract_component_id ] = self . add_node ( instance_a ) return self . comp_id_to_node [ abstract_component_id ] def add_node ( self , component : Component ) -> Vertex : return self . graph . add_vertex ( instance = component . id , library_component = component . library_component , c_type = component . c_type , component = component , label = f \" { component . library_component . id } \" , ) def remove_node ( self ): \"\"\"TODO\"\"\" raise NotImplementedError def add_edge ( self , node_id_a : int , node_id_b : int , connection : Connection ): self . graph . add_edge ( source = node_id_a , target = node_id_b , connection = connection ) def connect ( self , connection : Connection ): a = self . get_node_by_instance ( connection . component_a . id ) . index b = self . get_node_by_instance ( connection . component_b . id ) . index self . add_edge ( a , b , connection ) # print(f\"Edge: {a}: {connection.component_a.id} -> {b}: {connection.component_b.id}\") def remove_edge ( self ): \"\"\"TODO. Tip: self.graph.delete_edges\"\"\" raise NotImplementedError def disconnect ( self , connection : Connection ): \"\"\"TODO. Might want to remove a Connection, retrieve the node_id from the Connection\"\"\" raise NotImplementedError @property def components ( self ) -> set [ Component | None ]: if self . n_nodes > 0 : return set ( self . graph . vs ()[ \"component\" ]) return set () @property def parameters ( self ) -> set [ Parameter | None ]: parameters = set () for component in self . components : for para_id , parameter in component . parameters . items (): parameters . add ( parameter ) return parameters @property def connections ( self ) -> set [ Connection | None ]: if self . n_nodes > 0 : if self . n_edges > 0 : return set ( self . graph . es ()[ \"connection\" ]) return set () def get_node_by_instance ( self , instance : str ) -> Vertex | None : if self . n_nodes > 0 : nodes = self . graph . vs . select ( instance = instance ) if len ( nodes ) == 1 : return nodes [ 0 ] return None def get_instance ( self , instance : str ) -> Component | None : if self . n_nodes > 0 : nodes = self . graph . vs . select ( instance = instance ) if len ( nodes ) == 1 : return nodes [ \"component\" ][ 0 ] print ( f \" { instance } NOT FOUND\" ) for v in self . graph . vs : print ( v [ \"instance\" ]) raise Exception def select ( self , library_component : LibraryComponent | None = None , component_type : CType | None = None , ) -> set [ Component ]: components = set () if library_component is not None : return set ( self . graph . vs . select ( library_component = library_component )[ \"component\" ]) if component_type is not None : return set ( self . graph . vs . select ( component_type = component_type )[ \"component\" ]) return components @property def all_library_components_in_type ( self , ) -> dict [ CType , set [ LibraryComponent ]]: \"\"\"Returns all LibraryComponent for each Component class in the design\"\"\" comp_types_n : dict [ CType , set [ LibraryComponent ]] = {} for component in self . components : if component . c_type in comp_types_n . keys (): comp_types_n [ component . c_type ] . add ( component . library_component ) else : comp_types_n [ component . c_type ] = { component . library_component } return comp_types_n @property def all_components_by_library_components ( self , ) -> dict [ LibraryComponent , set [ Component ]]: \"\"\"Returns all Components for each LibraryComponent in the design\"\"\" comp_types_n : dict [ LibraryComponent , set [ Component ]] = {} for component in self . components : if component . library_component in comp_types_n . keys (): comp_types_n [ component . library_component ] . add ( component ) else : comp_types_n [ component . library_component ] = { component } return comp_types_n def validate ( self ): \"\"\"Validates the Parameters of the Design\"\"\" raise NotImplementedError def evaluate ( self ): \"\"\"Sends the Design for evaluation\"\"\" json_path = self . export ( ExportType . JSON ) evaluate_design ( design_json_path = json_path , metadata = { \"extra_info\" : \"full evaluation example\" }, timeout = 800 ) def evaluation ( self , evaluation_results_json : str ): \"\"\"Parse and update the evaluation of the Design\"\"\" raise NotImplementedError def export_to_cad ( self ): \"\"\"Generates a CAD representation of the Design\"\"\" raise NotImplementedError @property def to_design_swri ( self ) -> dict [ str , str ]: \"\"\"Generate design_swri.json format file from a concrete design design: the concrete design exporting to design_swri.json file output_path: file path for the export file. \"\"\" design_swri_data = {} \"\"\" Storing the design name\"\"\" design_swri_data [ \"name\" ] = self . name \"\"\"Storing parameters\"\"\" data_parameters : list = [] for component in self . components : for parameter_id , parameter in component . parameters . items (): data_parameters . append ( { \"parameter_name\" : f \" { component . id } _ { parameter . c_parameter . name } \" , \"value\" : str ( int ( parameter . value )), \"component_properties\" : [ { \"component_name\" : component . id , \"component_property\" : parameter . c_parameter . name , } ], } ) design_swri_data [ \"parameters\" ] = data_parameters \"\"\"Storing components\"\"\" data_components : list [ dict [ str , str ]] = [] for component in self . components : data_components . append ( { \"component_instance\" : component . id , \"component_type\" : component . c_type . id , \"component_choice\" : component . model , } ) design_swri_data [ \"components\" ] = data_components \"\"\"Storing connections\"\"\" data_connections : list [ dict [ str , str ]] = [] for connection in self . connections : data_connections . append ( { \"from_ci\" : connection . component_a . id , \"from_conn\" : connection . connector_a . name , \"to_ci\" : connection . component_b . id , \"to_conn\" : connection . connector_b . name , } ) data_connections . append ( { \"from_ci\" : connection . component_b . id , \"from_conn\" : connection . connector_b . name , \"to_ci\" : connection . component_a . id , \"to_conn\" : connection . connector_a . name , } ) design_swri_data [ \"connections\" ] = data_connections return design_swri_data def to_abstract_topology ( self ) -> AbstractTopology : name = self . name description = self . description connections : dict [ str , dict [ str , str ]] = {} parameters : dict [ str , dict [ str , float ]] = {} \"\"\"Connections\"\"\" for edge in self . edges : node_id_s = self . _graph . vs [ edge . source ][ \"instance\" ] node_id_t = self . _graph . vs [ edge . target ][ \"instance\" ] direction = edge [ \"connection\" ] . direction_b_respect_to_a if node_id_s not in connections : connections [ node_id_s ] = {} connections [ node_id_s ][ node_id_t ] = direction \"\"\"Parameters\"\"\" for node in self . nodes : node_id = node [ \"instance\" ] if node_id not in connections . keys (): \"\"\"Adding nodes with no connections\"\"\" connections [ node_id ] = {} if node_id not in parameters . keys (): \"\"\"Adding nodes with no connections\"\"\" parameters [ node_id ] = {} for parameter_id , parameter in node [ \"component\" ] . parameters . items (): print ( node [ \"component\" ]) parameters [ node_id ][ parameter_id ] = float ( parameter . value ) return AbstractTopology ( name , description , connections , parameters ) @property def pydot ( self ) -> pydot . Dot : absolute_folder = designs_folder / self . name dot_file_path = absolute_folder / \"concrete_graph.dot\" if not dot_file_path . exists (): self . _graph . write_dot ( f = str ( dot_file_path )) graphs = pydot . graph_from_dot_file ( dot_file_path ) return graphs [ 0 ] def export ( self , file_type : ExportType ) -> Path : absolute_folder = designs_folder / self . name if file_type == ExportType . TXT : return save_to_file ( str ( self ), file_name = f \"DConcrete\" , absolute_folder_path = absolute_folder , ) elif \"TOPOLOGY\" in file_type . name : ab_topo = self . to_abstract_topology () ab_level = export_type_to_topology_level ( file_type ) return save_to_file ( ab_topo . to_json ( ab_level ), file_name = f \"topology_summary_ { ab_level } .json\" , absolute_folder_path = absolute_folder , ) elif file_type == ExportType . JSON : return save_to_file ( str ( json . dumps ( self . to_design_swri )), file_name = f \"design_swri.json\" , absolute_folder_path = absolute_folder , ) elif file_type == ExportType . DOT : if not os . path . exists ( absolute_folder ): os . makedirs ( absolute_folder ) file_path = absolute_folder / \"concrete_graph.dot\" # self._graph.write_dot(f=str(file_path)) elif file_type == ExportType . PDF : file_path = absolute_folder / \"concrete_graph.pdf\" self . pydot . write_pdf ( file_path ) else : raise Exception ( \"File type not supported\" ) print ( f \" { file_type } file saved in { absolute_folder } \" ) return file_path def export_all ( self ): self . export ( ExportType . DOT ) self . export ( ExportType . PDF ) self . export ( ExportType . TXT ) self . export ( ExportType . JSON ) self . export ( ExportType . TOPOLOGY_1 ) self . export ( ExportType . TOPOLOGY_2 ) self . export ( ExportType . TOPOLOGY_3 ) def __eq__ ( self , other : object ): if isinstance ( other , DConcrete ): return self . components == other . components and self . connections == other . connections else : raise Exception ( \"Different classes\" ) def __ne__ ( self , other : object ): if not isinstance ( other , DConcrete ): return NotImplementedError return not self . __eq__ ( other ) def generate_connections_json ( self ): connection_dict = {} for ( components_class , library_components , ) in self . all_library_components_in_type . items (): for library_component in library_components : connection_dict [ library_component . id ] = {} components = self . select ( library_component = library_component ) for component in components : for connection in self . connections : direction = get_direction_from_components_and_connections ( connection . component_a . c_type . id , connection . component_b . c_type . id , connection . connector_a . id , connection . connector_b . id , ) if component . id == connection . component_a . id : if ( connection . component_b . library_component . id in connection_dict [ library_component . id ] . keys () ): connection_dict [ library_component . id ][ connection . component_b . library_component . id ] . append (( connection . connector_a . id , connection . connector_b . id , direction )) else : connection_dict [ library_component . id ][ connection . component_b . library_component . id ] = [ ( connection . connector_a . id , connection . connector_b . id , direction ) ] if component . id == connection . component_b . id : if ( connection . component_a . library_component . id in connection_dict [ library_component . id ] . keys () ): connection_dict [ library_component . id ][ connection . component_a . library_component . id ] . append (( connection . connector_b . id , connection . connector_a . id , direction )) else : connection_dict [ library_component . id ][ connection . component_a . library_component . id ] = [ ( connection . connector_b . id , connection . connector_a . id , direction ) ] connection_json = json . dumps ( connection_dict , indent = 4 ) return connection_json def get_neighbours_of ( self , node : Vertex ) -> list [ Vertex ]: neighbors = self . _graph . neighbors ( node . index ) neighbors = set ( neighbors ) neighbors_vertices = [] for n in neighbors : neighbors_vertices . append ( self . _graph . vs . select ( n )[ 0 ]) return neighbors_vertices def get_edges_from ( self , node : Vertex ) -> EdgeSeq : return self . _graph . es . select ( _source = node . index ) def get_edges_to ( self , node : Vertex ) -> EdgeSeq : return self . _graph . es . select ( _target = node . index ) # def get_edges_of(self, node: Vertex) -> set(Edge): # edges = set() # edges |= set(self._graph.es.select(_source=[node.index])) # edges |= set(self._graph.es.select(_target=[node.index])) # return edges def __str__ ( self ): ret = \"TOPOLOGY SUMMARY \\n\\n \" connections_map : dict = {} ret += \"<VERTEX_ID> - <COMPONENT_INSTANCE>::<LIBRARY_COMPONENT>::<COMPONENT_TYPE> \\n\\n \" for node in self . nodes : node_id = f \" { node . index } - { node [ 'instance' ] } :: { node [ 'label' ] } :: { node [ 'c_type' ] } \" connections_map [ node_id ] = [] print ( f \"SOURCE NODE: \\t { node [ 'instance' ] } \" ) for edge in self . get_edges_from ( node ): print ( edge [ \"connection\" ]) t_node = self . _graph . vs [ edge . target ] dir = edge [ \"connection\" ] . direction_b_respect_to_a c_a = edge [ \"connection\" ] . component_a . id c_b = edge [ \"connection\" ] . component_b . id conn_a = edge [ \"connection\" ] . connector_a . id conn_b = edge [ \"connection\" ] . connector_b . id t_node_id = ( f \" { dir } -- { t_node . index } - { t_node [ 'instance' ] } :: { t_node [ 'label' ] } :: { t_node [ 'c_type' ] } \\n \" f \" \\t\\t { c_a } : { conn_a } -> { c_b } : { conn_b } \" ) connections_map [ node_id ] . append ( t_node_id ) print ( \" \\n\\n \" ) ret += repr_dictionary ( connections_map ) ret += \" \\n\\n \" ret += str ( self . _graph ) n_library_component_by_class = [] for k , v in self . all_library_components_in_type . items (): n_library_component_by_class . append ( f \" \\t { k } : { len ( v ) } \" ) n_library_component_by_class_str = \" \\n \" . join ( n_library_component_by_class ) components_list = [] # connections_by_components = {} for ( components_class , library_components , ) in self . all_library_components_in_type . items (): components_list . append ( tab ( f \"COMPONENT type: { components_class } \" )) for library_component in library_components : components_list . append ( tab ( tab ( f \"LIBRARY COMPONENT: { library_component . id } \" ))) components = self . select ( library_component = library_component ) for component in components : components_list . append ( tab ( tab ( tab ( f \"COMPONENT: { component . id } \" )))) components_list . append ( tab ( tab ( tab ( tab ( f \"CONNECTIONS:\" ))))) for connection in self . connections : if component . id == connection . component_a . id : components_list . append ( tab ( tab ( tab ( tab ( tab ( f \" { connection . component_a . library_component . id } :: { connection . connector_a . id } <<->> { connection . connector_b . id } :: { connection . component_b . id } ( { connection . component_b . library_component . id } )\" ) ) ) ) ) ) if component . id == connection . component_b . id : components_list . append ( tab ( tab ( tab ( tab ( tab ( f \" { connection . component_b . library_component . id } :: { connection . connector_b . id } <<->> { connection . connector_a . id } :: { connection . component_a . id } ( { connection . component_a . library_component . id } )\" ) ) ) ) ) ) # components_list.append(tab(tab(tab(f\"COMPONENT: {component}\")))) # components_list.append(tab(tab(tab(component)))) components_list . append ( \" \\n\\t +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\" ) connection_list = [] for connection in self . connections : connection_list . append ( str ( connection )) components_str = \" \\n \" . join ( components_list ) connection_str = \" \\n \" . join ( connection_list ) s1 = ( f \" \\n\\n name: { self . name } \\n \" f \"#_components: { len ( self . components ) } \\n \" f \"#_connections: { len ( self . connections ) } \\n \" f \"#_component_classes: \\n { n_library_component_by_class_str } \\n \" f \" \\n\\n connections: \\n { connection_str } \\n \" f \" \\n\\n components: \\n { components_str } \\n \" ) return ret + s1 all_components_by_library_components () property \u00b6 Returns all Components for each LibraryComponent in the design Source code in sym_cps/representation/design/concrete/__init__.py 213 214 215 216 217 218 219 220 221 222 223 224 @property def all_components_by_library_components ( self , ) -> dict [ LibraryComponent , set [ Component ]]: \"\"\"Returns all Components for each LibraryComponent in the design\"\"\" comp_types_n : dict [ LibraryComponent , set [ Component ]] = {} for component in self . components : if component . library_component in comp_types_n . keys (): comp_types_n [ component . library_component ] . add ( component ) else : comp_types_n [ component . library_component ] = { component } return comp_types_n all_library_components_in_type () property \u00b6 Returns all LibraryComponent for each Component class in the design Source code in sym_cps/representation/design/concrete/__init__.py 200 201 202 203 204 205 206 207 208 209 210 211 @property def all_library_components_in_type ( self , ) -> dict [ CType , set [ LibraryComponent ]]: \"\"\"Returns all LibraryComponent for each Component class in the design\"\"\" comp_types_n : dict [ CType , set [ LibraryComponent ]] = {} for component in self . components : if component . c_type in comp_types_n . keys (): comp_types_n [ component . c_type ] . add ( component . library_component ) else : comp_types_n [ component . c_type ] = { component . library_component } return comp_types_n disconnect ( connection ) \u00b6 TODO. Might want to remove a Connection, retrieve the node_id from the Connection Source code in sym_cps/representation/design/concrete/__init__.py 146 147 148 def disconnect ( self , connection : Connection ): \"\"\"TODO. Might want to remove a Connection, retrieve the node_id from the Connection\"\"\" raise NotImplementedError evaluate () \u00b6 Sends the Design for evaluation Source code in sym_cps/representation/design/concrete/__init__.py 230 231 232 233 def evaluate ( self ): \"\"\"Sends the Design for evaluation\"\"\" json_path = self . export ( ExportType . JSON ) evaluate_design ( design_json_path = json_path , metadata = { \"extra_info\" : \"full evaluation example\" }, timeout = 800 ) evaluation ( evaluation_results_json ) \u00b6 Parse and update the evaluation of the Design Source code in sym_cps/representation/design/concrete/__init__.py 235 236 237 def evaluation ( self , evaluation_results_json : str ): \"\"\"Parse and update the evaluation of the Design\"\"\" raise NotImplementedError export_to_cad () \u00b6 Generates a CAD representation of the Design Source code in sym_cps/representation/design/concrete/__init__.py 239 240 241 def export_to_cad ( self ): \"\"\"Generates a CAD representation of the Design\"\"\" raise NotImplementedError remove_edge () \u00b6 TODO. Tip: self.graph.delete_edges Source code in sym_cps/representation/design/concrete/__init__.py 142 143 144 def remove_edge ( self ): \"\"\"TODO. Tip: self.graph.delete_edges\"\"\" raise NotImplementedError remove_node () \u00b6 TODO Source code in sym_cps/representation/design/concrete/__init__.py 129 130 131 def remove_node ( self ): \"\"\"TODO\"\"\" raise NotImplementedError to_design_swri () property \u00b6 Generate design_swri.json format file from a concrete design design: the concrete design exporting to design_swri.json file output_path: file path for the export file. Source code in sym_cps/representation/design/concrete/__init__.py 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 @property def to_design_swri ( self ) -> dict [ str , str ]: \"\"\"Generate design_swri.json format file from a concrete design design: the concrete design exporting to design_swri.json file output_path: file path for the export file. \"\"\" design_swri_data = {} \"\"\" Storing the design name\"\"\" design_swri_data [ \"name\" ] = self . name \"\"\"Storing parameters\"\"\" data_parameters : list = [] for component in self . components : for parameter_id , parameter in component . parameters . items (): data_parameters . append ( { \"parameter_name\" : f \" { component . id } _ { parameter . c_parameter . name } \" , \"value\" : str ( int ( parameter . value )), \"component_properties\" : [ { \"component_name\" : component . id , \"component_property\" : parameter . c_parameter . name , } ], } ) design_swri_data [ \"parameters\" ] = data_parameters \"\"\"Storing components\"\"\" data_components : list [ dict [ str , str ]] = [] for component in self . components : data_components . append ( { \"component_instance\" : component . id , \"component_type\" : component . c_type . id , \"component_choice\" : component . model , } ) design_swri_data [ \"components\" ] = data_components \"\"\"Storing connections\"\"\" data_connections : list [ dict [ str , str ]] = [] for connection in self . connections : data_connections . append ( { \"from_ci\" : connection . component_a . id , \"from_conn\" : connection . connector_a . name , \"to_ci\" : connection . component_b . id , \"to_conn\" : connection . connector_b . name , } ) data_connections . append ( { \"from_ci\" : connection . component_b . id , \"from_conn\" : connection . connector_b . name , \"to_ci\" : connection . component_a . id , \"to_conn\" : connection . connector_a . name , } ) design_swri_data [ \"connections\" ] = data_connections return design_swri_data validate () \u00b6 Validates the Parameters of the Design Source code in sym_cps/representation/design/concrete/__init__.py 226 227 228 def validate ( self ): \"\"\"Validates the Parameters of the Design\"\"\" raise NotImplementedError","title":"concrete"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete","text":"A class representing a Concrete Design ...","title":"DConcrete"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete--attributes","text":"str name of the design dict[str, DesignParameter] design parameters Source code in sym_cps/representation/design/concrete/__init__.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 @dataclass class DConcrete : \"\"\" A class representing a Concrete Design ... Attributes ---------- name : str name of the design design_parameters : dict[str, DesignParameter] design parameters \"\"\" name : str description : str = \"\" design_parameters : dict [ str , DesignParameter ] = field ( default_factory = dict ) comp_id_to_node : dict [ str , Vertex ] = field ( default_factory = dict ) def __post_init__ ( self ): self . _graph = Graph ( directed = True ) self . description = \"empty_description\" @classmethod def from_abstract_topology ( cls , topo : AbstractTopology ): d_concrete = cls ( name = topo . name ) for component_a , connections in topo . connections . items (): node_a_vertex = d_concrete . add_default_node ( component_a ) \"\"\"Parameters\"\"\" if component_a in topo . parameters . keys (): node_a_vertex [ \"component\" ] . update_parameters ( topo . parameters [ component_a ]) \"\"\"Connections\"\"\" for component_b , direction in connections . items (): node_b_vertex = d_concrete . add_default_node ( component_b ) connection = Connection . from_direction ( component_a = node_a_vertex [ \"component\" ], component_b = node_b_vertex [ \"component\" ], direction = direction , ) d_concrete . connect ( connection ) return d_concrete @property def graph ( self ) -> Graph : return self . _graph @property def nodes ( self ) -> list [ Vertex ]: return list ( self . graph . vs ) @property def edges ( self ) -> list [ Edge ]: return list ( self . graph . es ) def get_vertex_by_id ( self , vid : int ) -> Vertex : return self . graph . vs [ vid ] @property def n_nodes ( self ) -> int : return len ( self . graph . vs ) @property def n_edges ( self ) -> int : return len ( self . graph . es ) def export_parameters ( self ) -> dict [ str , dict [ str , Parameter ]]: pass def add_default_node ( self , abstract_component_id : str ) -> Vertex : if abstract_component_id in self . comp_id_to_node . keys (): return self . comp_id_to_node [ abstract_component_id ] id_split = abstract_component_id . split ( \"_\" ) try : if id_split [ - 2 ] == \"instance\" : node_type_a = \"_\" . join ( id_split [: - 2 ]) else : node_type_a = abstract_component_id except : node_type_a = abstract_component_id from sym_cps.shared.library import c_library lib_comp_a = c_library . get_default_component ( node_type_a ) instance_a = Component ( id = abstract_component_id , library_component = lib_comp_a ) self . comp_id_to_node [ abstract_component_id ] = self . add_node ( instance_a ) return self . comp_id_to_node [ abstract_component_id ] def add_node ( self , component : Component ) -> Vertex : return self . graph . add_vertex ( instance = component . id , library_component = component . library_component , c_type = component . c_type , component = component , label = f \" { component . library_component . id } \" , ) def remove_node ( self ): \"\"\"TODO\"\"\" raise NotImplementedError def add_edge ( self , node_id_a : int , node_id_b : int , connection : Connection ): self . graph . add_edge ( source = node_id_a , target = node_id_b , connection = connection ) def connect ( self , connection : Connection ): a = self . get_node_by_instance ( connection . component_a . id ) . index b = self . get_node_by_instance ( connection . component_b . id ) . index self . add_edge ( a , b , connection ) # print(f\"Edge: {a}: {connection.component_a.id} -> {b}: {connection.component_b.id}\") def remove_edge ( self ): \"\"\"TODO. Tip: self.graph.delete_edges\"\"\" raise NotImplementedError def disconnect ( self , connection : Connection ): \"\"\"TODO. Might want to remove a Connection, retrieve the node_id from the Connection\"\"\" raise NotImplementedError @property def components ( self ) -> set [ Component | None ]: if self . n_nodes > 0 : return set ( self . graph . vs ()[ \"component\" ]) return set () @property def parameters ( self ) -> set [ Parameter | None ]: parameters = set () for component in self . components : for para_id , parameter in component . parameters . items (): parameters . add ( parameter ) return parameters @property def connections ( self ) -> set [ Connection | None ]: if self . n_nodes > 0 : if self . n_edges > 0 : return set ( self . graph . es ()[ \"connection\" ]) return set () def get_node_by_instance ( self , instance : str ) -> Vertex | None : if self . n_nodes > 0 : nodes = self . graph . vs . select ( instance = instance ) if len ( nodes ) == 1 : return nodes [ 0 ] return None def get_instance ( self , instance : str ) -> Component | None : if self . n_nodes > 0 : nodes = self . graph . vs . select ( instance = instance ) if len ( nodes ) == 1 : return nodes [ \"component\" ][ 0 ] print ( f \" { instance } NOT FOUND\" ) for v in self . graph . vs : print ( v [ \"instance\" ]) raise Exception def select ( self , library_component : LibraryComponent | None = None , component_type : CType | None = None , ) -> set [ Component ]: components = set () if library_component is not None : return set ( self . graph . vs . select ( library_component = library_component )[ \"component\" ]) if component_type is not None : return set ( self . graph . vs . select ( component_type = component_type )[ \"component\" ]) return components @property def all_library_components_in_type ( self , ) -> dict [ CType , set [ LibraryComponent ]]: \"\"\"Returns all LibraryComponent for each Component class in the design\"\"\" comp_types_n : dict [ CType , set [ LibraryComponent ]] = {} for component in self . components : if component . c_type in comp_types_n . keys (): comp_types_n [ component . c_type ] . add ( component . library_component ) else : comp_types_n [ component . c_type ] = { component . library_component } return comp_types_n @property def all_components_by_library_components ( self , ) -> dict [ LibraryComponent , set [ Component ]]: \"\"\"Returns all Components for each LibraryComponent in the design\"\"\" comp_types_n : dict [ LibraryComponent , set [ Component ]] = {} for component in self . components : if component . library_component in comp_types_n . keys (): comp_types_n [ component . library_component ] . add ( component ) else : comp_types_n [ component . library_component ] = { component } return comp_types_n def validate ( self ): \"\"\"Validates the Parameters of the Design\"\"\" raise NotImplementedError def evaluate ( self ): \"\"\"Sends the Design for evaluation\"\"\" json_path = self . export ( ExportType . JSON ) evaluate_design ( design_json_path = json_path , metadata = { \"extra_info\" : \"full evaluation example\" }, timeout = 800 ) def evaluation ( self , evaluation_results_json : str ): \"\"\"Parse and update the evaluation of the Design\"\"\" raise NotImplementedError def export_to_cad ( self ): \"\"\"Generates a CAD representation of the Design\"\"\" raise NotImplementedError @property def to_design_swri ( self ) -> dict [ str , str ]: \"\"\"Generate design_swri.json format file from a concrete design design: the concrete design exporting to design_swri.json file output_path: file path for the export file. \"\"\" design_swri_data = {} \"\"\" Storing the design name\"\"\" design_swri_data [ \"name\" ] = self . name \"\"\"Storing parameters\"\"\" data_parameters : list = [] for component in self . components : for parameter_id , parameter in component . parameters . items (): data_parameters . append ( { \"parameter_name\" : f \" { component . id } _ { parameter . c_parameter . name } \" , \"value\" : str ( int ( parameter . value )), \"component_properties\" : [ { \"component_name\" : component . id , \"component_property\" : parameter . c_parameter . name , } ], } ) design_swri_data [ \"parameters\" ] = data_parameters \"\"\"Storing components\"\"\" data_components : list [ dict [ str , str ]] = [] for component in self . components : data_components . append ( { \"component_instance\" : component . id , \"component_type\" : component . c_type . id , \"component_choice\" : component . model , } ) design_swri_data [ \"components\" ] = data_components \"\"\"Storing connections\"\"\" data_connections : list [ dict [ str , str ]] = [] for connection in self . connections : data_connections . append ( { \"from_ci\" : connection . component_a . id , \"from_conn\" : connection . connector_a . name , \"to_ci\" : connection . component_b . id , \"to_conn\" : connection . connector_b . name , } ) data_connections . append ( { \"from_ci\" : connection . component_b . id , \"from_conn\" : connection . connector_b . name , \"to_ci\" : connection . component_a . id , \"to_conn\" : connection . connector_a . name , } ) design_swri_data [ \"connections\" ] = data_connections return design_swri_data def to_abstract_topology ( self ) -> AbstractTopology : name = self . name description = self . description connections : dict [ str , dict [ str , str ]] = {} parameters : dict [ str , dict [ str , float ]] = {} \"\"\"Connections\"\"\" for edge in self . edges : node_id_s = self . _graph . vs [ edge . source ][ \"instance\" ] node_id_t = self . _graph . vs [ edge . target ][ \"instance\" ] direction = edge [ \"connection\" ] . direction_b_respect_to_a if node_id_s not in connections : connections [ node_id_s ] = {} connections [ node_id_s ][ node_id_t ] = direction \"\"\"Parameters\"\"\" for node in self . nodes : node_id = node [ \"instance\" ] if node_id not in connections . keys (): \"\"\"Adding nodes with no connections\"\"\" connections [ node_id ] = {} if node_id not in parameters . keys (): \"\"\"Adding nodes with no connections\"\"\" parameters [ node_id ] = {} for parameter_id , parameter in node [ \"component\" ] . parameters . items (): print ( node [ \"component\" ]) parameters [ node_id ][ parameter_id ] = float ( parameter . value ) return AbstractTopology ( name , description , connections , parameters ) @property def pydot ( self ) -> pydot . Dot : absolute_folder = designs_folder / self . name dot_file_path = absolute_folder / \"concrete_graph.dot\" if not dot_file_path . exists (): self . _graph . write_dot ( f = str ( dot_file_path )) graphs = pydot . graph_from_dot_file ( dot_file_path ) return graphs [ 0 ] def export ( self , file_type : ExportType ) -> Path : absolute_folder = designs_folder / self . name if file_type == ExportType . TXT : return save_to_file ( str ( self ), file_name = f \"DConcrete\" , absolute_folder_path = absolute_folder , ) elif \"TOPOLOGY\" in file_type . name : ab_topo = self . to_abstract_topology () ab_level = export_type_to_topology_level ( file_type ) return save_to_file ( ab_topo . to_json ( ab_level ), file_name = f \"topology_summary_ { ab_level } .json\" , absolute_folder_path = absolute_folder , ) elif file_type == ExportType . JSON : return save_to_file ( str ( json . dumps ( self . to_design_swri )), file_name = f \"design_swri.json\" , absolute_folder_path = absolute_folder , ) elif file_type == ExportType . DOT : if not os . path . exists ( absolute_folder ): os . makedirs ( absolute_folder ) file_path = absolute_folder / \"concrete_graph.dot\" # self._graph.write_dot(f=str(file_path)) elif file_type == ExportType . PDF : file_path = absolute_folder / \"concrete_graph.pdf\" self . pydot . write_pdf ( file_path ) else : raise Exception ( \"File type not supported\" ) print ( f \" { file_type } file saved in { absolute_folder } \" ) return file_path def export_all ( self ): self . export ( ExportType . DOT ) self . export ( ExportType . PDF ) self . export ( ExportType . TXT ) self . export ( ExportType . JSON ) self . export ( ExportType . TOPOLOGY_1 ) self . export ( ExportType . TOPOLOGY_2 ) self . export ( ExportType . TOPOLOGY_3 ) def __eq__ ( self , other : object ): if isinstance ( other , DConcrete ): return self . components == other . components and self . connections == other . connections else : raise Exception ( \"Different classes\" ) def __ne__ ( self , other : object ): if not isinstance ( other , DConcrete ): return NotImplementedError return not self . __eq__ ( other ) def generate_connections_json ( self ): connection_dict = {} for ( components_class , library_components , ) in self . all_library_components_in_type . items (): for library_component in library_components : connection_dict [ library_component . id ] = {} components = self . select ( library_component = library_component ) for component in components : for connection in self . connections : direction = get_direction_from_components_and_connections ( connection . component_a . c_type . id , connection . component_b . c_type . id , connection . connector_a . id , connection . connector_b . id , ) if component . id == connection . component_a . id : if ( connection . component_b . library_component . id in connection_dict [ library_component . id ] . keys () ): connection_dict [ library_component . id ][ connection . component_b . library_component . id ] . append (( connection . connector_a . id , connection . connector_b . id , direction )) else : connection_dict [ library_component . id ][ connection . component_b . library_component . id ] = [ ( connection . connector_a . id , connection . connector_b . id , direction ) ] if component . id == connection . component_b . id : if ( connection . component_a . library_component . id in connection_dict [ library_component . id ] . keys () ): connection_dict [ library_component . id ][ connection . component_a . library_component . id ] . append (( connection . connector_b . id , connection . connector_a . id , direction )) else : connection_dict [ library_component . id ][ connection . component_a . library_component . id ] = [ ( connection . connector_b . id , connection . connector_a . id , direction ) ] connection_json = json . dumps ( connection_dict , indent = 4 ) return connection_json def get_neighbours_of ( self , node : Vertex ) -> list [ Vertex ]: neighbors = self . _graph . neighbors ( node . index ) neighbors = set ( neighbors ) neighbors_vertices = [] for n in neighbors : neighbors_vertices . append ( self . _graph . vs . select ( n )[ 0 ]) return neighbors_vertices def get_edges_from ( self , node : Vertex ) -> EdgeSeq : return self . _graph . es . select ( _source = node . index ) def get_edges_to ( self , node : Vertex ) -> EdgeSeq : return self . _graph . es . select ( _target = node . index ) # def get_edges_of(self, node: Vertex) -> set(Edge): # edges = set() # edges |= set(self._graph.es.select(_source=[node.index])) # edges |= set(self._graph.es.select(_target=[node.index])) # return edges def __str__ ( self ): ret = \"TOPOLOGY SUMMARY \\n\\n \" connections_map : dict = {} ret += \"<VERTEX_ID> - <COMPONENT_INSTANCE>::<LIBRARY_COMPONENT>::<COMPONENT_TYPE> \\n\\n \" for node in self . nodes : node_id = f \" { node . index } - { node [ 'instance' ] } :: { node [ 'label' ] } :: { node [ 'c_type' ] } \" connections_map [ node_id ] = [] print ( f \"SOURCE NODE: \\t { node [ 'instance' ] } \" ) for edge in self . get_edges_from ( node ): print ( edge [ \"connection\" ]) t_node = self . _graph . vs [ edge . target ] dir = edge [ \"connection\" ] . direction_b_respect_to_a c_a = edge [ \"connection\" ] . component_a . id c_b = edge [ \"connection\" ] . component_b . id conn_a = edge [ \"connection\" ] . connector_a . id conn_b = edge [ \"connection\" ] . connector_b . id t_node_id = ( f \" { dir } -- { t_node . index } - { t_node [ 'instance' ] } :: { t_node [ 'label' ] } :: { t_node [ 'c_type' ] } \\n \" f \" \\t\\t { c_a } : { conn_a } -> { c_b } : { conn_b } \" ) connections_map [ node_id ] . append ( t_node_id ) print ( \" \\n\\n \" ) ret += repr_dictionary ( connections_map ) ret += \" \\n\\n \" ret += str ( self . _graph ) n_library_component_by_class = [] for k , v in self . all_library_components_in_type . items (): n_library_component_by_class . append ( f \" \\t { k } : { len ( v ) } \" ) n_library_component_by_class_str = \" \\n \" . join ( n_library_component_by_class ) components_list = [] # connections_by_components = {} for ( components_class , library_components , ) in self . all_library_components_in_type . items (): components_list . append ( tab ( f \"COMPONENT type: { components_class } \" )) for library_component in library_components : components_list . append ( tab ( tab ( f \"LIBRARY COMPONENT: { library_component . id } \" ))) components = self . select ( library_component = library_component ) for component in components : components_list . append ( tab ( tab ( tab ( f \"COMPONENT: { component . id } \" )))) components_list . append ( tab ( tab ( tab ( tab ( f \"CONNECTIONS:\" ))))) for connection in self . connections : if component . id == connection . component_a . id : components_list . append ( tab ( tab ( tab ( tab ( tab ( f \" { connection . component_a . library_component . id } :: { connection . connector_a . id } <<->> { connection . connector_b . id } :: { connection . component_b . id } ( { connection . component_b . library_component . id } )\" ) ) ) ) ) ) if component . id == connection . component_b . id : components_list . append ( tab ( tab ( tab ( tab ( tab ( f \" { connection . component_b . library_component . id } :: { connection . connector_b . id } <<->> { connection . connector_a . id } :: { connection . component_a . id } ( { connection . component_a . library_component . id } )\" ) ) ) ) ) ) # components_list.append(tab(tab(tab(f\"COMPONENT: {component}\")))) # components_list.append(tab(tab(tab(component)))) components_list . append ( \" \\n\\t +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\" ) connection_list = [] for connection in self . connections : connection_list . append ( str ( connection )) components_str = \" \\n \" . join ( components_list ) connection_str = \" \\n \" . join ( connection_list ) s1 = ( f \" \\n\\n name: { self . name } \\n \" f \"#_components: { len ( self . components ) } \\n \" f \"#_connections: { len ( self . connections ) } \\n \" f \"#_component_classes: \\n { n_library_component_by_class_str } \\n \" f \" \\n\\n connections: \\n { connection_str } \\n \" f \" \\n\\n components: \\n { components_str } \\n \" ) return ret + s1","title":"Attributes"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.all_components_by_library_components","text":"Returns all Components for each LibraryComponent in the design Source code in sym_cps/representation/design/concrete/__init__.py 213 214 215 216 217 218 219 220 221 222 223 224 @property def all_components_by_library_components ( self , ) -> dict [ LibraryComponent , set [ Component ]]: \"\"\"Returns all Components for each LibraryComponent in the design\"\"\" comp_types_n : dict [ LibraryComponent , set [ Component ]] = {} for component in self . components : if component . library_component in comp_types_n . keys (): comp_types_n [ component . library_component ] . add ( component ) else : comp_types_n [ component . library_component ] = { component } return comp_types_n","title":"all_components_by_library_components()"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.all_library_components_in_type","text":"Returns all LibraryComponent for each Component class in the design Source code in sym_cps/representation/design/concrete/__init__.py 200 201 202 203 204 205 206 207 208 209 210 211 @property def all_library_components_in_type ( self , ) -> dict [ CType , set [ LibraryComponent ]]: \"\"\"Returns all LibraryComponent for each Component class in the design\"\"\" comp_types_n : dict [ CType , set [ LibraryComponent ]] = {} for component in self . components : if component . c_type in comp_types_n . keys (): comp_types_n [ component . c_type ] . add ( component . library_component ) else : comp_types_n [ component . c_type ] = { component . library_component } return comp_types_n","title":"all_library_components_in_type()"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.disconnect","text":"TODO. Might want to remove a Connection, retrieve the node_id from the Connection Source code in sym_cps/representation/design/concrete/__init__.py 146 147 148 def disconnect ( self , connection : Connection ): \"\"\"TODO. Might want to remove a Connection, retrieve the node_id from the Connection\"\"\" raise NotImplementedError","title":"disconnect()"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.evaluate","text":"Sends the Design for evaluation Source code in sym_cps/representation/design/concrete/__init__.py 230 231 232 233 def evaluate ( self ): \"\"\"Sends the Design for evaluation\"\"\" json_path = self . export ( ExportType . JSON ) evaluate_design ( design_json_path = json_path , metadata = { \"extra_info\" : \"full evaluation example\" }, timeout = 800 )","title":"evaluate()"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.evaluation","text":"Parse and update the evaluation of the Design Source code in sym_cps/representation/design/concrete/__init__.py 235 236 237 def evaluation ( self , evaluation_results_json : str ): \"\"\"Parse and update the evaluation of the Design\"\"\" raise NotImplementedError","title":"evaluation()"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.export_to_cad","text":"Generates a CAD representation of the Design Source code in sym_cps/representation/design/concrete/__init__.py 239 240 241 def export_to_cad ( self ): \"\"\"Generates a CAD representation of the Design\"\"\" raise NotImplementedError","title":"export_to_cad()"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.remove_edge","text":"TODO. Tip: self.graph.delete_edges Source code in sym_cps/representation/design/concrete/__init__.py 142 143 144 def remove_edge ( self ): \"\"\"TODO. Tip: self.graph.delete_edges\"\"\" raise NotImplementedError","title":"remove_edge()"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.remove_node","text":"TODO Source code in sym_cps/representation/design/concrete/__init__.py 129 130 131 def remove_node ( self ): \"\"\"TODO\"\"\" raise NotImplementedError","title":"remove_node()"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.to_design_swri","text":"Generate design_swri.json format file from a concrete design design: the concrete design exporting to design_swri.json file output_path: file path for the export file. Source code in sym_cps/representation/design/concrete/__init__.py 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 @property def to_design_swri ( self ) -> dict [ str , str ]: \"\"\"Generate design_swri.json format file from a concrete design design: the concrete design exporting to design_swri.json file output_path: file path for the export file. \"\"\" design_swri_data = {} \"\"\" Storing the design name\"\"\" design_swri_data [ \"name\" ] = self . name \"\"\"Storing parameters\"\"\" data_parameters : list = [] for component in self . components : for parameter_id , parameter in component . parameters . items (): data_parameters . append ( { \"parameter_name\" : f \" { component . id } _ { parameter . c_parameter . name } \" , \"value\" : str ( int ( parameter . value )), \"component_properties\" : [ { \"component_name\" : component . id , \"component_property\" : parameter . c_parameter . name , } ], } ) design_swri_data [ \"parameters\" ] = data_parameters \"\"\"Storing components\"\"\" data_components : list [ dict [ str , str ]] = [] for component in self . components : data_components . append ( { \"component_instance\" : component . id , \"component_type\" : component . c_type . id , \"component_choice\" : component . model , } ) design_swri_data [ \"components\" ] = data_components \"\"\"Storing connections\"\"\" data_connections : list [ dict [ str , str ]] = [] for connection in self . connections : data_connections . append ( { \"from_ci\" : connection . component_a . id , \"from_conn\" : connection . connector_a . name , \"to_ci\" : connection . component_b . id , \"to_conn\" : connection . connector_b . name , } ) data_connections . append ( { \"from_ci\" : connection . component_b . id , \"from_conn\" : connection . connector_b . name , \"to_ci\" : connection . component_a . id , \"to_conn\" : connection . connector_a . name , } ) design_swri_data [ \"connections\" ] = data_connections return design_swri_data","title":"to_design_swri()"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.validate","text":"Validates the Parameters of the Design Source code in sym_cps/representation/design/concrete/__init__.py 226 227 228 def validate ( self ): \"\"\"Validates the Parameters of the Design\"\"\" raise NotImplementedError","title":"validate()"},{"location":"reference/sym_cps/representation/design/concrete/elements/","text":"","title":"elements"},{"location":"reference/sym_cps/representation/design/concrete/elements/component/","text":"Component dataclass \u00b6 Source code in sym_cps/representation/design/concrete/elements/component.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 @dataclass ( frozen = True ) class Component : id : str library_component : LibraryComponent parameters : dict [ str , Parameter ] = field ( default_factory = dict ) def __post_init__ ( self ): \"\"\"Fill up all the parameters with the assigned_value, or default_value\"\"\" for parameter_accepted in self . configurable_parameters : if parameter_accepted . id not in self . parameters . keys (): if \"assigned_val\" in parameter_accepted . values . keys (): new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"assigned_val\" ]), c_parameter = parameter_accepted , component = self , ) elif \"default_val\" in parameter_accepted . values . keys (): new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"default_val\" ]), c_parameter = parameter_accepted , component = self , ) else : # raise Exception( # f\"Parameter {parameter_accepted.id} does not have assigned_val nor default_val\" # ) new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"min_val\" ]), c_parameter = parameter_accepted , component = self , ) self . parameters [ parameter_accepted . id ] = new_parameter for parameter in self . parameters . values (): parameter . component = self @property def model ( self ) -> str : return self . library_component . id @property def c_type ( self ) -> CType : return self . library_component . comp_type @property def properties ( self ) -> dict [ str , CProperty ]: return self . library_component . properties @property def configurable_parameters ( self ) -> set [ CParameter ]: \"\"\"Returns the set of all ParameterType that can be configured in the Component\"\"\" return set ( self . library_component . parameters . values ()) @property def params_props_values ( self ) -> dict [ str , float | str ]: \"\"\"Returns dictionary: with the values of each parameter and property of the component\"\"\" params_props_values : dict [ str , float | str ] = {} for param_id , parameter in self . parameters . items (): params_props_values [ param_id ] = parameter . value for property_id , property in self . properties . items (): params_props_values [ property_id ] = property . value return params_props_values def update_parameters ( self , parameters : dict [ str , float ]): for param_id , value in parameters . items (): self . parameters [ param_id ] . value = value def _edit_field ( self , name , value ): object . __setattr__ ( self , name , value ) def _update_field ( self , name , value ): attr = object . __getattribute__ ( self , name ) attr . update ( value ) object . __setattr__ ( self , name , attr ) def __eq__ ( self , other : object ): if not isinstance ( other , Component ): return NotImplemented if self . library_component != other . library_component : return False if self . params_props_values != self . params_props_values : return False return True def __ne__ ( self , other : object ): if not isinstance ( other , Component ): return NotImplemented return not self . __eq__ ( other ) def __hash__ ( self ): return abs ( hash ( self . id )) def __str__ ( self ): s1 = f \"name: { self . model } \\n \" f \"type: { self . c_type } \\n \" parameters_str = [] for k , v in self . parameters . items (): parameters_str . append ( f \" \\t { k } : { v } \" ) parameters = \" \\n \" . join ( parameters_str ) if len ( parameters_str ) != 0 : s2 = f \"parameters: \\n { parameters } \\n \" else : s2 = \"\" return s1 + s2 __post_init__ () \u00b6 Fill up all the parameters with the assigned_value, or default_value Source code in sym_cps/representation/design/concrete/elements/component.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def __post_init__ ( self ): \"\"\"Fill up all the parameters with the assigned_value, or default_value\"\"\" for parameter_accepted in self . configurable_parameters : if parameter_accepted . id not in self . parameters . keys (): if \"assigned_val\" in parameter_accepted . values . keys (): new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"assigned_val\" ]), c_parameter = parameter_accepted , component = self , ) elif \"default_val\" in parameter_accepted . values . keys (): new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"default_val\" ]), c_parameter = parameter_accepted , component = self , ) else : # raise Exception( # f\"Parameter {parameter_accepted.id} does not have assigned_val nor default_val\" # ) new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"min_val\" ]), c_parameter = parameter_accepted , component = self , ) self . parameters [ parameter_accepted . id ] = new_parameter for parameter in self . parameters . values (): parameter . component = self configurable_parameters () property \u00b6 Returns the set of all ParameterType that can be configured in the Component Source code in sym_cps/representation/design/concrete/elements/component.py 61 62 63 64 @property def configurable_parameters ( self ) -> set [ CParameter ]: \"\"\"Returns the set of all ParameterType that can be configured in the Component\"\"\" return set ( self . library_component . parameters . values ()) params_props_values () property \u00b6 Returns dictionary: with the values of each parameter and property of the component Source code in sym_cps/representation/design/concrete/elements/component.py 66 67 68 69 70 71 72 73 74 75 76 @property def params_props_values ( self ) -> dict [ str , float | str ]: \"\"\"Returns dictionary: with the values of each parameter and property of the component\"\"\" params_props_values : dict [ str , float | str ] = {} for param_id , parameter in self . parameters . items (): params_props_values [ param_id ] = parameter . value for property_id , property in self . properties . items (): params_props_values [ property_id ] = property . value return params_props_values","title":"component"},{"location":"reference/sym_cps/representation/design/concrete/elements/component/#sym_cps.representation.design.concrete.elements.component.Component","text":"Source code in sym_cps/representation/design/concrete/elements/component.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 @dataclass ( frozen = True ) class Component : id : str library_component : LibraryComponent parameters : dict [ str , Parameter ] = field ( default_factory = dict ) def __post_init__ ( self ): \"\"\"Fill up all the parameters with the assigned_value, or default_value\"\"\" for parameter_accepted in self . configurable_parameters : if parameter_accepted . id not in self . parameters . keys (): if \"assigned_val\" in parameter_accepted . values . keys (): new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"assigned_val\" ]), c_parameter = parameter_accepted , component = self , ) elif \"default_val\" in parameter_accepted . values . keys (): new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"default_val\" ]), c_parameter = parameter_accepted , component = self , ) else : # raise Exception( # f\"Parameter {parameter_accepted.id} does not have assigned_val nor default_val\" # ) new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"min_val\" ]), c_parameter = parameter_accepted , component = self , ) self . parameters [ parameter_accepted . id ] = new_parameter for parameter in self . parameters . values (): parameter . component = self @property def model ( self ) -> str : return self . library_component . id @property def c_type ( self ) -> CType : return self . library_component . comp_type @property def properties ( self ) -> dict [ str , CProperty ]: return self . library_component . properties @property def configurable_parameters ( self ) -> set [ CParameter ]: \"\"\"Returns the set of all ParameterType that can be configured in the Component\"\"\" return set ( self . library_component . parameters . values ()) @property def params_props_values ( self ) -> dict [ str , float | str ]: \"\"\"Returns dictionary: with the values of each parameter and property of the component\"\"\" params_props_values : dict [ str , float | str ] = {} for param_id , parameter in self . parameters . items (): params_props_values [ param_id ] = parameter . value for property_id , property in self . properties . items (): params_props_values [ property_id ] = property . value return params_props_values def update_parameters ( self , parameters : dict [ str , float ]): for param_id , value in parameters . items (): self . parameters [ param_id ] . value = value def _edit_field ( self , name , value ): object . __setattr__ ( self , name , value ) def _update_field ( self , name , value ): attr = object . __getattribute__ ( self , name ) attr . update ( value ) object . __setattr__ ( self , name , attr ) def __eq__ ( self , other : object ): if not isinstance ( other , Component ): return NotImplemented if self . library_component != other . library_component : return False if self . params_props_values != self . params_props_values : return False return True def __ne__ ( self , other : object ): if not isinstance ( other , Component ): return NotImplemented return not self . __eq__ ( other ) def __hash__ ( self ): return abs ( hash ( self . id )) def __str__ ( self ): s1 = f \"name: { self . model } \\n \" f \"type: { self . c_type } \\n \" parameters_str = [] for k , v in self . parameters . items (): parameters_str . append ( f \" \\t { k } : { v } \" ) parameters = \" \\n \" . join ( parameters_str ) if len ( parameters_str ) != 0 : s2 = f \"parameters: \\n { parameters } \\n \" else : s2 = \"\" return s1 + s2","title":"Component"},{"location":"reference/sym_cps/representation/design/concrete/elements/component/#sym_cps.representation.design.concrete.elements.component.Component.__post_init__","text":"Fill up all the parameters with the assigned_value, or default_value Source code in sym_cps/representation/design/concrete/elements/component.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def __post_init__ ( self ): \"\"\"Fill up all the parameters with the assigned_value, or default_value\"\"\" for parameter_accepted in self . configurable_parameters : if parameter_accepted . id not in self . parameters . keys (): if \"assigned_val\" in parameter_accepted . values . keys (): new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"assigned_val\" ]), c_parameter = parameter_accepted , component = self , ) elif \"default_val\" in parameter_accepted . values . keys (): new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"default_val\" ]), c_parameter = parameter_accepted , component = self , ) else : # raise Exception( # f\"Parameter {parameter_accepted.id} does not have assigned_val nor default_val\" # ) new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"min_val\" ]), c_parameter = parameter_accepted , component = self , ) self . parameters [ parameter_accepted . id ] = new_parameter for parameter in self . parameters . values (): parameter . component = self","title":"__post_init__()"},{"location":"reference/sym_cps/representation/design/concrete/elements/component/#sym_cps.representation.design.concrete.elements.component.Component.configurable_parameters","text":"Returns the set of all ParameterType that can be configured in the Component Source code in sym_cps/representation/design/concrete/elements/component.py 61 62 63 64 @property def configurable_parameters ( self ) -> set [ CParameter ]: \"\"\"Returns the set of all ParameterType that can be configured in the Component\"\"\" return set ( self . library_component . parameters . values ())","title":"configurable_parameters()"},{"location":"reference/sym_cps/representation/design/concrete/elements/component/#sym_cps.representation.design.concrete.elements.component.Component.params_props_values","text":"Returns dictionary: with the values of each parameter and property of the component Source code in sym_cps/representation/design/concrete/elements/component.py 66 67 68 69 70 71 72 73 74 75 76 @property def params_props_values ( self ) -> dict [ str , float | str ]: \"\"\"Returns dictionary: with the values of each parameter and property of the component\"\"\" params_props_values : dict [ str , float | str ] = {} for param_id , parameter in self . parameters . items (): params_props_values [ param_id ] = parameter . value for property_id , property in self . properties . items (): params_props_values [ property_id ] = property . value return params_props_values","title":"params_props_values()"},{"location":"reference/sym_cps/representation/design/concrete/elements/connection/","text":"Connection dataclass \u00b6 Models the connection between two 'Component'. Each Connection is symmetric, i.e. Connection(A,B) = Connection(B,A) Source code in sym_cps/representation/design/concrete/elements/connection.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 @dataclass ( frozen = True ) class Connection : \"\"\"Models the connection between two 'Component'. Each Connection is symmetric, i.e. Connection(A,B) = Connection(B,A)\"\"\" component_a : Component connector_a : CConnector component_b : Component connector_b : CConnector # brendan: make api to output connector_a and connect_b given component_a and component_b @classmethod def from_direction ( cls , component_a : Component , component_b : Component , direction : str ): print ( f \"connecting { component_a . c_type . id } to { component_b . c_type . id } , direction: { direction } \" ) connector_a = connections_map [ component_a . c_type . id ][ component_b . c_type . id ][ direction ][ 0 ] connector_b = connections_map [ component_a . c_type . id ][ component_b . c_type . id ][ direction ][ 1 ] from sym_cps.shared.library import c_library return cls ( component_a , c_library . connectors [ connector_a ], component_b , c_library . connectors [ connector_b ], ) @property def components_and_connectors ( self ) -> set [ tuple [ Component , CConnector ]]: \"\"\"Returns a set of two tuples, where each tuple is formed by a Component and a CConnector\"\"\" connections = set () connections . add (( self . component_a , self . connector_a )) connections . add (( self . component_b , self . connector_b )) return connections @property def components ( self ) -> tuple [ Component , Component ]: \"\"\"Returns the two components connected\"\"\" return self . component_a , self . component_b @property def key ( self ) -> str : a1 = self . component_a . id a2 = self . connector_a . id b1 = self . component_b . id b2 = self . connector_b . id if ( a1 + a2 ) >= ( b1 + b2 ): return f \" { a1 } - { a2 } - { b1 } - { b2 } \" return f \" { b1 } - { b2 } - { a1 } - { a2 } \" @property def lib_key ( self ) -> str : a1 = self . component_a . library_component . id a2 = self . connector_a . id b1 = self . component_b . library_component . id b2 = self . connector_b . id return f \" { a1 } - { a2 } - { b1 } - { b2 } \" # if (a1 + a2) >= (b1 + b2): # return f\"{a1}-{a2}-{b1}-{b2}\" # return f\"{b1}-{b2}-{a1}-{a2}\" @property def direction_b_respect_to_a ( self ): return get_direction_from_components_and_connections ( self . component_a . c_type . id , self . component_b . c_type . id , self . connector_a . id , self . connector_b . id ) def __eq__ ( self , other : object ): if not isinstance ( other , Connection ): return NotImplementedError return self . key == other . key def is_similar ( self , other : Connection ): return self . lib_key == other . lib_key def __ne__ ( self , other : object ): if not isinstance ( other , Connection ): return NotImplementedError return not self . __eq__ ( other ) def __str__ ( self ): s1 = ( f \"FROM \\n\\t COMPONENT \\t { self . component_a . c_type . id } ( { self . component_a . id } )\" f \" \\n\\t CONNECTOR \\t { self . connector_a . name } \\n \" ) s2 = ( f \"TO \\n\\t COMPONENT \\t { self . component_b . c_type . id } ( { self . component_b . id } )\" f \" \\n\\t CONNECTOR \\t { self . connector_b . name } \\n \" ) return f \" { s1 }{ s2 } \" def __hash__ ( self ): return abs ( hash ( self . key )) components () property \u00b6 Returns the two components connected Source code in sym_cps/representation/design/concrete/elements/connection.py 49 50 51 52 53 @property def components ( self ) -> tuple [ Component , Component ]: \"\"\"Returns the two components connected\"\"\" return self . component_a , self . component_b components_and_connectors () property \u00b6 Returns a set of two tuples, where each tuple is formed by a Component and a CConnector Source code in sym_cps/representation/design/concrete/elements/connection.py 40 41 42 43 44 45 46 47 @property def components_and_connectors ( self ) -> set [ tuple [ Component , CConnector ]]: \"\"\"Returns a set of two tuples, where each tuple is formed by a Component and a CConnector\"\"\" connections = set () connections . add (( self . component_a , self . connector_a )) connections . add (( self . component_b , self . connector_b )) return connections","title":"connection"},{"location":"reference/sym_cps/representation/design/concrete/elements/connection/#sym_cps.representation.design.concrete.elements.connection.Connection","text":"Models the connection between two 'Component'. Each Connection is symmetric, i.e. Connection(A,B) = Connection(B,A) Source code in sym_cps/representation/design/concrete/elements/connection.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 @dataclass ( frozen = True ) class Connection : \"\"\"Models the connection between two 'Component'. Each Connection is symmetric, i.e. Connection(A,B) = Connection(B,A)\"\"\" component_a : Component connector_a : CConnector component_b : Component connector_b : CConnector # brendan: make api to output connector_a and connect_b given component_a and component_b @classmethod def from_direction ( cls , component_a : Component , component_b : Component , direction : str ): print ( f \"connecting { component_a . c_type . id } to { component_b . c_type . id } , direction: { direction } \" ) connector_a = connections_map [ component_a . c_type . id ][ component_b . c_type . id ][ direction ][ 0 ] connector_b = connections_map [ component_a . c_type . id ][ component_b . c_type . id ][ direction ][ 1 ] from sym_cps.shared.library import c_library return cls ( component_a , c_library . connectors [ connector_a ], component_b , c_library . connectors [ connector_b ], ) @property def components_and_connectors ( self ) -> set [ tuple [ Component , CConnector ]]: \"\"\"Returns a set of two tuples, where each tuple is formed by a Component and a CConnector\"\"\" connections = set () connections . add (( self . component_a , self . connector_a )) connections . add (( self . component_b , self . connector_b )) return connections @property def components ( self ) -> tuple [ Component , Component ]: \"\"\"Returns the two components connected\"\"\" return self . component_a , self . component_b @property def key ( self ) -> str : a1 = self . component_a . id a2 = self . connector_a . id b1 = self . component_b . id b2 = self . connector_b . id if ( a1 + a2 ) >= ( b1 + b2 ): return f \" { a1 } - { a2 } - { b1 } - { b2 } \" return f \" { b1 } - { b2 } - { a1 } - { a2 } \" @property def lib_key ( self ) -> str : a1 = self . component_a . library_component . id a2 = self . connector_a . id b1 = self . component_b . library_component . id b2 = self . connector_b . id return f \" { a1 } - { a2 } - { b1 } - { b2 } \" # if (a1 + a2) >= (b1 + b2): # return f\"{a1}-{a2}-{b1}-{b2}\" # return f\"{b1}-{b2}-{a1}-{a2}\" @property def direction_b_respect_to_a ( self ): return get_direction_from_components_and_connections ( self . component_a . c_type . id , self . component_b . c_type . id , self . connector_a . id , self . connector_b . id ) def __eq__ ( self , other : object ): if not isinstance ( other , Connection ): return NotImplementedError return self . key == other . key def is_similar ( self , other : Connection ): return self . lib_key == other . lib_key def __ne__ ( self , other : object ): if not isinstance ( other , Connection ): return NotImplementedError return not self . __eq__ ( other ) def __str__ ( self ): s1 = ( f \"FROM \\n\\t COMPONENT \\t { self . component_a . c_type . id } ( { self . component_a . id } )\" f \" \\n\\t CONNECTOR \\t { self . connector_a . name } \\n \" ) s2 = ( f \"TO \\n\\t COMPONENT \\t { self . component_b . c_type . id } ( { self . component_b . id } )\" f \" \\n\\t CONNECTOR \\t { self . connector_b . name } \\n \" ) return f \" { s1 }{ s2 } \" def __hash__ ( self ): return abs ( hash ( self . key ))","title":"Connection"},{"location":"reference/sym_cps/representation/design/concrete/elements/connection/#sym_cps.representation.design.concrete.elements.connection.Connection.components","text":"Returns the two components connected Source code in sym_cps/representation/design/concrete/elements/connection.py 49 50 51 52 53 @property def components ( self ) -> tuple [ Component , Component ]: \"\"\"Returns the two components connected\"\"\" return self . component_a , self . component_b","title":"components()"},{"location":"reference/sym_cps/representation/design/concrete/elements/connection/#sym_cps.representation.design.concrete.elements.connection.Connection.components_and_connectors","text":"Returns a set of two tuples, where each tuple is formed by a Component and a CConnector Source code in sym_cps/representation/design/concrete/elements/connection.py 40 41 42 43 44 45 46 47 @property def components_and_connectors ( self ) -> set [ tuple [ Component , CConnector ]]: \"\"\"Returns a set of two tuples, where each tuple is formed by a Component and a CConnector\"\"\" connections = set () connections . add (( self . component_a , self . connector_a )) connections . add (( self . component_b , self . connector_b )) return connections","title":"components_and_connectors()"},{"location":"reference/sym_cps/representation/design/concrete/elements/design_parameters/","text":"","title":"design_parameters"},{"location":"reference/sym_cps/representation/design/concrete/elements/parameter/","text":"","title":"parameter"},{"location":"reference/sym_cps/representation/design/topology/","text":"DTopology dataclass \u00b6 Source code in sym_cps/representation/design/topology/__init__.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 @dataclass class DTopology : name : str def __post_init__ ( self ): self . _graph = Graph ( directed = True ) @property def graph ( self ) -> Graph : return self . _graph @classmethod def from_concrete ( cls , d_concrete : DConcrete ) -> DTopology : # Create all the vertexes with the same id in d_concrete: d_topology = cls ( name = d_concrete . name ) for i in range ( d_concrete . n_nodes ): vertex = d_concrete . get_vertex_by_id ( i ) component : Component = vertex [ \"component\" ] d_topology . add_node ( c_type = component . library_component . comp_type ) # print(f\"{vertex.index} - {new_vertex.index}\") for edge in d_concrete . edges : d_topology . add_edge ( edge . source , edge . target , edge [ \"connection\" ] . direction_b_respect_to_a ) return d_topology @property def nodes ( self ) -> list [ igraph . Vertex ]: return list ( self . graph . vs ) def get_vertex_by_id ( self , vid : int ) -> igraph . Vertex : return self . graph . vs [ vid ] @property def edges ( self ) -> list [ igraph . Edge ]: return list ( self . graph . es ) @property def n_nodes ( self ) -> int : return len ( self . graph . vs ) def add_node ( self , c_type : CType ) -> igraph . Vertex : if not isinstance ( c_type , CType ): print ( c_type ) raise Exception ( \"CType wrong\" ) return self . graph . add_vertex ( c_type = c_type , label = c_type . id ) def remove_node ( self ): \"\"\"TODO\"\"\" raise NotImplementedError def add_edge ( self , node_id_a : int , node_id_b : int , direction : str = \"\" ): self . graph . add_edge ( source = node_id_a , target = node_id_b , label = direction ) def remove_edge ( self ): \"\"\"TODO. Tip: self.graph.delete_edges\"\"\" raise NotImplementedError @property def components ( self ) -> set [ CType ]: if self . n_nodes > 0 : return set ( self . graph . vs ()[ \"c_type\" ]) return set () def draw_random_node ( self ) -> igraph . Vertex | None : if self . n_nodes == 0 : return None return choice ( self . nodes ) def get_nodes_connected_to ( self , node : igraph . Vertex ): nodes = set () for edge in self . _graph . es . select ( _source = node ): nodes . add ( edge . target ) return nodes @property def pydot ( self ) -> pydot . Dot : absolute_folder = designs_folder / self . name dot_file_path = absolute_folder / \"topology_graph.dot\" if not dot_file_path . exists (): self . _graph . write_dot ( f = str ( dot_file_path )) graphs = pydot . graph_from_dot_file ( dot_file_path ) return graphs [ 0 ] def export ( self , file_type : ExportType ): absolute_folder = designs_folder / self . name if file_type == ExportType . TXT : save_to_file ( str ( self ), file_name = f \"DTopology\" , absolute_folder_path = absolute_folder , ) elif file_type == ExportType . JSON : raise Exception ( \"Can't create JSON from DTopology. It must be from DConcrete.\" ) elif file_type == ExportType . DOT : if not os . path . exists ( absolute_folder ): os . makedirs ( absolute_folder ) file_path = absolute_folder / \"topology_graph.dot\" self . _graph . write_dot ( f = str ( file_path )) elif file_type == ExportType . PDF : file_path = absolute_folder / \"topology_graph.pdf\" self . pydot . write_pdf ( file_path ) elif file_type == ExportType . DOT : self . graph . write_dot ( f = str ( absolute_folder / \"topo_graph.dot\" )) else : raise Exception ( \"File type not supported\" ) print ( f \" { file_type } file saved in { absolute_folder } \" ) def export_all ( self ): self . export ( ExportType . DOT ) self . export ( ExportType . PDF ) self . export ( ExportType . TXT ) def __str__ ( self ): ret = \"TOPOLOGY SUMMARY \\n\\n \" connections_map : dict = {} for node in self . nodes : connections_map [ f \" { node . index } ( { node [ 'c_type' ] } )\" ] = [] target_nodes = self . get_nodes_connected_to ( node ) for t_node in target_nodes : connections_map [ f \" { node . index } ( { node [ 'c_type' ] } )\" ] . append ( self . _graph . vs [ \"c_type\" ][ t_node ]) ret += repr_dictionary ( connections_map ) ret += \" \\n\\n GRAPH\" ret += str ( self . graph ) ret += \" \\n \" for node in self . nodes : ret += f \" { node . index } : { node [ 'c_type' ] } \\n \" return ret remove_edge () \u00b6 TODO. Tip: self.graph.delete_edges Source code in sym_cps/representation/design/topology/__init__.py 77 78 79 def remove_edge ( self ): \"\"\"TODO. Tip: self.graph.delete_edges\"\"\" raise NotImplementedError remove_node () \u00b6 TODO Source code in sym_cps/representation/design/topology/__init__.py 70 71 72 def remove_node ( self ): \"\"\"TODO\"\"\" raise NotImplementedError","title":"topology"},{"location":"reference/sym_cps/representation/design/topology/#sym_cps.representation.design.topology.DTopology","text":"Source code in sym_cps/representation/design/topology/__init__.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 @dataclass class DTopology : name : str def __post_init__ ( self ): self . _graph = Graph ( directed = True ) @property def graph ( self ) -> Graph : return self . _graph @classmethod def from_concrete ( cls , d_concrete : DConcrete ) -> DTopology : # Create all the vertexes with the same id in d_concrete: d_topology = cls ( name = d_concrete . name ) for i in range ( d_concrete . n_nodes ): vertex = d_concrete . get_vertex_by_id ( i ) component : Component = vertex [ \"component\" ] d_topology . add_node ( c_type = component . library_component . comp_type ) # print(f\"{vertex.index} - {new_vertex.index}\") for edge in d_concrete . edges : d_topology . add_edge ( edge . source , edge . target , edge [ \"connection\" ] . direction_b_respect_to_a ) return d_topology @property def nodes ( self ) -> list [ igraph . Vertex ]: return list ( self . graph . vs ) def get_vertex_by_id ( self , vid : int ) -> igraph . Vertex : return self . graph . vs [ vid ] @property def edges ( self ) -> list [ igraph . Edge ]: return list ( self . graph . es ) @property def n_nodes ( self ) -> int : return len ( self . graph . vs ) def add_node ( self , c_type : CType ) -> igraph . Vertex : if not isinstance ( c_type , CType ): print ( c_type ) raise Exception ( \"CType wrong\" ) return self . graph . add_vertex ( c_type = c_type , label = c_type . id ) def remove_node ( self ): \"\"\"TODO\"\"\" raise NotImplementedError def add_edge ( self , node_id_a : int , node_id_b : int , direction : str = \"\" ): self . graph . add_edge ( source = node_id_a , target = node_id_b , label = direction ) def remove_edge ( self ): \"\"\"TODO. Tip: self.graph.delete_edges\"\"\" raise NotImplementedError @property def components ( self ) -> set [ CType ]: if self . n_nodes > 0 : return set ( self . graph . vs ()[ \"c_type\" ]) return set () def draw_random_node ( self ) -> igraph . Vertex | None : if self . n_nodes == 0 : return None return choice ( self . nodes ) def get_nodes_connected_to ( self , node : igraph . Vertex ): nodes = set () for edge in self . _graph . es . select ( _source = node ): nodes . add ( edge . target ) return nodes @property def pydot ( self ) -> pydot . Dot : absolute_folder = designs_folder / self . name dot_file_path = absolute_folder / \"topology_graph.dot\" if not dot_file_path . exists (): self . _graph . write_dot ( f = str ( dot_file_path )) graphs = pydot . graph_from_dot_file ( dot_file_path ) return graphs [ 0 ] def export ( self , file_type : ExportType ): absolute_folder = designs_folder / self . name if file_type == ExportType . TXT : save_to_file ( str ( self ), file_name = f \"DTopology\" , absolute_folder_path = absolute_folder , ) elif file_type == ExportType . JSON : raise Exception ( \"Can't create JSON from DTopology. It must be from DConcrete.\" ) elif file_type == ExportType . DOT : if not os . path . exists ( absolute_folder ): os . makedirs ( absolute_folder ) file_path = absolute_folder / \"topology_graph.dot\" self . _graph . write_dot ( f = str ( file_path )) elif file_type == ExportType . PDF : file_path = absolute_folder / \"topology_graph.pdf\" self . pydot . write_pdf ( file_path ) elif file_type == ExportType . DOT : self . graph . write_dot ( f = str ( absolute_folder / \"topo_graph.dot\" )) else : raise Exception ( \"File type not supported\" ) print ( f \" { file_type } file saved in { absolute_folder } \" ) def export_all ( self ): self . export ( ExportType . DOT ) self . export ( ExportType . PDF ) self . export ( ExportType . TXT ) def __str__ ( self ): ret = \"TOPOLOGY SUMMARY \\n\\n \" connections_map : dict = {} for node in self . nodes : connections_map [ f \" { node . index } ( { node [ 'c_type' ] } )\" ] = [] target_nodes = self . get_nodes_connected_to ( node ) for t_node in target_nodes : connections_map [ f \" { node . index } ( { node [ 'c_type' ] } )\" ] . append ( self . _graph . vs [ \"c_type\" ][ t_node ]) ret += repr_dictionary ( connections_map ) ret += \" \\n\\n GRAPH\" ret += str ( self . graph ) ret += \" \\n \" for node in self . nodes : ret += f \" { node . index } : { node [ 'c_type' ] } \\n \" return ret","title":"DTopology"},{"location":"reference/sym_cps/representation/design/topology/#sym_cps.representation.design.topology.DTopology.remove_edge","text":"TODO. Tip: self.graph.delete_edges Source code in sym_cps/representation/design/topology/__init__.py 77 78 79 def remove_edge ( self ): \"\"\"TODO. Tip: self.graph.delete_edges\"\"\" raise NotImplementedError","title":"remove_edge()"},{"location":"reference/sym_cps/representation/design/topology/#sym_cps.representation.design.topology.DTopology.remove_node","text":"TODO Source code in sym_cps/representation/design/topology/__init__.py 70 71 72 def remove_node ( self ): \"\"\"TODO\"\"\" raise NotImplementedError","title":"remove_node()"},{"location":"reference/sym_cps/representation/library/","text":"Library dataclass \u00b6 Source code in sym_cps/representation/library/__init__.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 @dataclass class Library : components : dict [ str , LibraryComponent ] = field ( default_factory = dict ) component_types : dict [ str , CType ] = field ( init = False , default_factory = dict ) components_in_type : dict [ str , set [ LibraryComponent ]] = field ( init = False , default_factory = dict ) parameters : dict [ str , CParameter ] = field ( init = False , default_factory = dict ) connectors : dict [ str , CConnector ] = field ( init = False , default_factory = dict ) def __post_init__ ( self ): self . _update_data_structures () def _update_data_structures ( self ): for component in self . components . values (): if component . comp_type . id not in self . component_types . keys (): self . component_types [ component . comp_type . id ] = component . comp_type self . components_in_type [ component . comp_type . id ] = set () self . components_in_type [ component . comp_type . id ] . add ( component ) for comp_type in self . component_types . values (): if len ( self . parameters ) == 0 : self . parameters = comp_type . parameters else : self . parameters . update ( comp_type . parameters ) if len ( self . connectors ) == 0 : self . connectors = comp_type . connectors else : self . connectors . update ( comp_type . connectors ) def get_default_component ( self , component_type : str , hub_size : int = 0 ) -> LibraryComponent : if component_type not in self . component_types . keys (): raise Exception ( f \" { component_type } \\n Component Type not present in the library\" ) default_comp_path = data_folder / \"reverse_engineering\" / \"default_components.json\" f = open ( default_comp_path ) default = json . load ( f ) if component_type == \"Hub\" : if hub_size == 4 : component = self . components [ \"0394od_para_hub_4\" ] elif hub_size == 3 : component = self . components [ \"0394od_para_hub_4\" ] else : raise Exception ( f \"No hub of size { hub_size } \" ) else : component = self . components [ default [ component_type ][ 0 ]] return component def get_connectors ( self , component_type_a : CType , component_type_b : CType , direction : str ) -> ( CConnector , CConnector ): \"\"\"TODO\"\"\" connectors_components_path = data_folder / \"reverse_engineering\" / \"connectors_components_mapping.json\" f = open ( connectors_components_path ) connections = json . load ( f ) name_a = component_type_a . id name_b = component_type_b . id results = () available_components_a = list ( connections [ name_a ] . keys ()) if name_b in available_components_a : if direction == \"\" : direction = \"NONE\" if direction in list ( connections [ name_a ][ name_b ] . keys ()): connector_names = connections [ name_a ][ name_b ][ direction ] a_connector_name = connector_names [ 0 ] b_connector_name = connector_names [ 1 ] connector_a = self . connectors [ a_connector_name ] connector_b = self . connectors [ b_connector_name ] results = ( connector_a , connector_b ) else : print ( \"illegal direction\" ) else : print ( \"illegal component\" ) return results def update_information ( self , connectable_connectors : dict [ str , set [ str ]] | None , connectable_components_types : dict [ CType , set [ CType ]] | None , design_parameters : dict [ str , str ] | None , ): if isinstance ( connectable_connectors , dict ): for key , value in connectable_connectors . items (): for output_connector in value : # type: ignore if output_connector . id in self . connectors . keys (): # print(f\"{key} -> {output_connector}\") self . connectors [ key ] . _update_field ( \"compatible_with\" , { output_connector . id : output_connector }) if isinstance ( connectable_components_types , dict ): for key , value in connectable_components_types . items (): for compatible_class in value : # type: ignore self . component_types [ key . id ] . _update_field ( \"compatible_with\" , { compatible_class . id : compatible_class } ) if isinstance ( design_parameters , dict ): for key , value in design_parameters . items (): if key not in self . parameters : print ( f \" { key } is missing\" ) else : self . parameters [ key ] . _edit_field ( \"design_parameter\" , value ) @classmethod def from_folder ( cls , path : Path | None = None ): if path is None : path = component_library_root_path_default print ( f \"Reading from { path } \" ) file_name_list = os . listdir ( path ) components : dict [ str , LibraryComponent ] = {} for name in file_name_list : file_path = path / name if os . path . isfile ( file_path ): components . update ( parse_components_and_types ( file_path )) for name in file_name_list : file_path = path / name if os . path . isfile ( file_path ): components . update ( fill_parameters_connectors ( file_path , components )) return Library ( components ) def __str__ ( self ): return \" \\n +++++++++++++++++++++++++++++++++ \\n \" . join ( str ( c ) for c in list ( self . components . values ())) get_connectors ( component_type_a , component_type_b , direction ) \u00b6 TODO Source code in sym_cps/representation/library/__init__.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def get_connectors ( self , component_type_a : CType , component_type_b : CType , direction : str ) -> ( CConnector , CConnector ): \"\"\"TODO\"\"\" connectors_components_path = data_folder / \"reverse_engineering\" / \"connectors_components_mapping.json\" f = open ( connectors_components_path ) connections = json . load ( f ) name_a = component_type_a . id name_b = component_type_b . id results = () available_components_a = list ( connections [ name_a ] . keys ()) if name_b in available_components_a : if direction == \"\" : direction = \"NONE\" if direction in list ( connections [ name_a ][ name_b ] . keys ()): connector_names = connections [ name_a ][ name_b ][ direction ] a_connector_name = connector_names [ 0 ] b_connector_name = connector_names [ 1 ] connector_a = self . connectors [ a_connector_name ] connector_b = self . connectors [ b_connector_name ] results = ( connector_a , connector_b ) else : print ( \"illegal direction\" ) else : print ( \"illegal component\" ) return results","title":"library"},{"location":"reference/sym_cps/representation/library/#sym_cps.representation.library.Library","text":"Source code in sym_cps/representation/library/__init__.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 @dataclass class Library : components : dict [ str , LibraryComponent ] = field ( default_factory = dict ) component_types : dict [ str , CType ] = field ( init = False , default_factory = dict ) components_in_type : dict [ str , set [ LibraryComponent ]] = field ( init = False , default_factory = dict ) parameters : dict [ str , CParameter ] = field ( init = False , default_factory = dict ) connectors : dict [ str , CConnector ] = field ( init = False , default_factory = dict ) def __post_init__ ( self ): self . _update_data_structures () def _update_data_structures ( self ): for component in self . components . values (): if component . comp_type . id not in self . component_types . keys (): self . component_types [ component . comp_type . id ] = component . comp_type self . components_in_type [ component . comp_type . id ] = set () self . components_in_type [ component . comp_type . id ] . add ( component ) for comp_type in self . component_types . values (): if len ( self . parameters ) == 0 : self . parameters = comp_type . parameters else : self . parameters . update ( comp_type . parameters ) if len ( self . connectors ) == 0 : self . connectors = comp_type . connectors else : self . connectors . update ( comp_type . connectors ) def get_default_component ( self , component_type : str , hub_size : int = 0 ) -> LibraryComponent : if component_type not in self . component_types . keys (): raise Exception ( f \" { component_type } \\n Component Type not present in the library\" ) default_comp_path = data_folder / \"reverse_engineering\" / \"default_components.json\" f = open ( default_comp_path ) default = json . load ( f ) if component_type == \"Hub\" : if hub_size == 4 : component = self . components [ \"0394od_para_hub_4\" ] elif hub_size == 3 : component = self . components [ \"0394od_para_hub_4\" ] else : raise Exception ( f \"No hub of size { hub_size } \" ) else : component = self . components [ default [ component_type ][ 0 ]] return component def get_connectors ( self , component_type_a : CType , component_type_b : CType , direction : str ) -> ( CConnector , CConnector ): \"\"\"TODO\"\"\" connectors_components_path = data_folder / \"reverse_engineering\" / \"connectors_components_mapping.json\" f = open ( connectors_components_path ) connections = json . load ( f ) name_a = component_type_a . id name_b = component_type_b . id results = () available_components_a = list ( connections [ name_a ] . keys ()) if name_b in available_components_a : if direction == \"\" : direction = \"NONE\" if direction in list ( connections [ name_a ][ name_b ] . keys ()): connector_names = connections [ name_a ][ name_b ][ direction ] a_connector_name = connector_names [ 0 ] b_connector_name = connector_names [ 1 ] connector_a = self . connectors [ a_connector_name ] connector_b = self . connectors [ b_connector_name ] results = ( connector_a , connector_b ) else : print ( \"illegal direction\" ) else : print ( \"illegal component\" ) return results def update_information ( self , connectable_connectors : dict [ str , set [ str ]] | None , connectable_components_types : dict [ CType , set [ CType ]] | None , design_parameters : dict [ str , str ] | None , ): if isinstance ( connectable_connectors , dict ): for key , value in connectable_connectors . items (): for output_connector in value : # type: ignore if output_connector . id in self . connectors . keys (): # print(f\"{key} -> {output_connector}\") self . connectors [ key ] . _update_field ( \"compatible_with\" , { output_connector . id : output_connector }) if isinstance ( connectable_components_types , dict ): for key , value in connectable_components_types . items (): for compatible_class in value : # type: ignore self . component_types [ key . id ] . _update_field ( \"compatible_with\" , { compatible_class . id : compatible_class } ) if isinstance ( design_parameters , dict ): for key , value in design_parameters . items (): if key not in self . parameters : print ( f \" { key } is missing\" ) else : self . parameters [ key ] . _edit_field ( \"design_parameter\" , value ) @classmethod def from_folder ( cls , path : Path | None = None ): if path is None : path = component_library_root_path_default print ( f \"Reading from { path } \" ) file_name_list = os . listdir ( path ) components : dict [ str , LibraryComponent ] = {} for name in file_name_list : file_path = path / name if os . path . isfile ( file_path ): components . update ( parse_components_and_types ( file_path )) for name in file_name_list : file_path = path / name if os . path . isfile ( file_path ): components . update ( fill_parameters_connectors ( file_path , components )) return Library ( components ) def __str__ ( self ): return \" \\n +++++++++++++++++++++++++++++++++ \\n \" . join ( str ( c ) for c in list ( self . components . values ()))","title":"Library"},{"location":"reference/sym_cps/representation/library/#sym_cps.representation.library.Library.get_connectors","text":"TODO Source code in sym_cps/representation/library/__init__.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def get_connectors ( self , component_type_a : CType , component_type_b : CType , direction : str ) -> ( CConnector , CConnector ): \"\"\"TODO\"\"\" connectors_components_path = data_folder / \"reverse_engineering\" / \"connectors_components_mapping.json\" f = open ( connectors_components_path ) connections = json . load ( f ) name_a = component_type_a . id name_b = component_type_b . id results = () available_components_a = list ( connections [ name_a ] . keys ()) if name_b in available_components_a : if direction == \"\" : direction = \"NONE\" if direction in list ( connections [ name_a ][ name_b ] . keys ()): connector_names = connections [ name_a ][ name_b ][ direction ] a_connector_name = connector_names [ 0 ] b_connector_name = connector_names [ 1 ] connector_a = self . connectors [ a_connector_name ] connector_b = self . connectors [ b_connector_name ] results = ( connector_a , connector_b ) else : print ( \"illegal direction\" ) else : print ( \"illegal component\" ) return results","title":"get_connectors()"},{"location":"reference/sym_cps/representation/library/elements/","text":"","title":"elements"},{"location":"reference/sym_cps/representation/library/elements/c_connector/","text":"","title":"c_connector"},{"location":"reference/sym_cps/representation/library/elements/c_parameter/","text":"CParameter dataclass \u00b6 Indicates the possible values and type of a component parameter. Parameters are associated to component classes. Source code in sym_cps/representation/library/elements/c_parameter.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 @dataclass ( frozen = True ) class CParameter : \"\"\"Indicates the possible values and type of a component parameter. Parameters are associated to component classes. \"\"\" name : str belongs_to : CType = field ( init = False ) _values : dict = field ( init = False , default_factory = dict ) def _edit_field ( self , name , value ): object . __setattr__ ( self , name , value ) def _update_field ( self , name , value ): attr = object . __getattribute__ ( self , name ) attr . update ( value ) object . __setattr__ ( self , name , attr ) def __post_init__ ( self ): vals : dict [ str , float | None ] = { \"min_val\" : None , \"max_val\" : None , \"default_val\" : None , \"assigned_val\" : None , } self . _edit_field ( \"_values\" , vals ) @property def values ( self ) -> dict [ str , float ]: \"\"\"Filters out None component\"\"\" return { key : value for key , value in self . _values . items () if value is not None } @property def min ( self ) -> float | None : if self . _values [ \"min_val\" ] is not None : return float ( self . _values [ \"min_val\" ]) return None @property def max ( self ) -> float | None : if self . _values [ \"max_val\" ] is not None : return float ( self . _values [ \"max_val\" ]) return None @property def default ( self ) -> float : if self . _values [ \"default_val\" ] is not None : return float ( self . _values [ \"default_val\" ]) if self . _values [ \"assigned_val\" ] is not None : return float ( self . _values [ \"assigned_val\" ]) raise Exception ( \"No default value\" ) def _edit_values ( self , values : dict ): for key in values . keys (): if key in self . _values . keys (): if values [ key ] != \"\" : self . _values [ key ] = float ( values [ key ]) @property def id ( self ) -> str : \"\"\"Internal ID\"\"\" return parameter_id ( self . name , str ( self . belongs_to )) def __str__ ( self ): values = \", \" . join ([ f \" { k } : { v } \" for k , v in self . values . items ()]) return f \" { self . name } \\t { values } \" def __hash__ ( self ): return abs ( hash ( self . id )) id () property \u00b6 Internal ID Source code in sym_cps/representation/library/elements/c_parameter.py 72 73 74 75 @property def id ( self ) -> str : \"\"\"Internal ID\"\"\" return parameter_id ( self . name , str ( self . belongs_to )) values () property \u00b6 Filters out None component Source code in sym_cps/representation/library/elements/c_parameter.py 41 42 43 44 @property def values ( self ) -> dict [ str , float ]: \"\"\"Filters out None component\"\"\" return { key : value for key , value in self . _values . items () if value is not None }","title":"c_parameter"},{"location":"reference/sym_cps/representation/library/elements/c_parameter/#sym_cps.representation.library.elements.c_parameter.CParameter","text":"Indicates the possible values and type of a component parameter. Parameters are associated to component classes. Source code in sym_cps/representation/library/elements/c_parameter.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 @dataclass ( frozen = True ) class CParameter : \"\"\"Indicates the possible values and type of a component parameter. Parameters are associated to component classes. \"\"\" name : str belongs_to : CType = field ( init = False ) _values : dict = field ( init = False , default_factory = dict ) def _edit_field ( self , name , value ): object . __setattr__ ( self , name , value ) def _update_field ( self , name , value ): attr = object . __getattribute__ ( self , name ) attr . update ( value ) object . __setattr__ ( self , name , attr ) def __post_init__ ( self ): vals : dict [ str , float | None ] = { \"min_val\" : None , \"max_val\" : None , \"default_val\" : None , \"assigned_val\" : None , } self . _edit_field ( \"_values\" , vals ) @property def values ( self ) -> dict [ str , float ]: \"\"\"Filters out None component\"\"\" return { key : value for key , value in self . _values . items () if value is not None } @property def min ( self ) -> float | None : if self . _values [ \"min_val\" ] is not None : return float ( self . _values [ \"min_val\" ]) return None @property def max ( self ) -> float | None : if self . _values [ \"max_val\" ] is not None : return float ( self . _values [ \"max_val\" ]) return None @property def default ( self ) -> float : if self . _values [ \"default_val\" ] is not None : return float ( self . _values [ \"default_val\" ]) if self . _values [ \"assigned_val\" ] is not None : return float ( self . _values [ \"assigned_val\" ]) raise Exception ( \"No default value\" ) def _edit_values ( self , values : dict ): for key in values . keys (): if key in self . _values . keys (): if values [ key ] != \"\" : self . _values [ key ] = float ( values [ key ]) @property def id ( self ) -> str : \"\"\"Internal ID\"\"\" return parameter_id ( self . name , str ( self . belongs_to )) def __str__ ( self ): values = \", \" . join ([ f \" { k } : { v } \" for k , v in self . values . items ()]) return f \" { self . name } \\t { values } \" def __hash__ ( self ): return abs ( hash ( self . id ))","title":"CParameter"},{"location":"reference/sym_cps/representation/library/elements/c_parameter/#sym_cps.representation.library.elements.c_parameter.CParameter.id","text":"Internal ID Source code in sym_cps/representation/library/elements/c_parameter.py 72 73 74 75 @property def id ( self ) -> str : \"\"\"Internal ID\"\"\" return parameter_id ( self . name , str ( self . belongs_to ))","title":"id()"},{"location":"reference/sym_cps/representation/library/elements/c_parameter/#sym_cps.representation.library.elements.c_parameter.CParameter.values","text":"Filters out None component Source code in sym_cps/representation/library/elements/c_parameter.py 41 42 43 44 @property def values ( self ) -> dict [ str , float ]: \"\"\"Filters out None component\"\"\" return { key : value for key , value in self . _values . items () if value is not None }","title":"values()"},{"location":"reference/sym_cps/representation/library/elements/c_property/","text":"","title":"c_property"},{"location":"reference/sym_cps/representation/library/elements/c_type/","text":"CType dataclass \u00b6 Source code in sym_cps/representation/library/elements/c_type.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 @dataclass ( frozen = True ) class CType : id : str \"\"\"Configurable parameters\"\"\" parameters : dict [ str , CParameter ] = field ( init = False , default_factory = dict ) \"\"\"Accepted connectors\"\"\" connectors : dict [ str , CConnector ] = field ( init = False , default_factory = dict ) \"\"\"Compatible CType to be connected to\"\"\" compatible_with : dict [ str , CType ] = field ( init = False , default_factory = dict ) \"\"\"Library components of CType\"\"\" belongs_to : dict [ str , LibraryComponent ] = field ( init = False , default_factory = dict ) def _edit_field ( self , name , value ): object . __setattr__ ( self , name , value ) def _update_field ( self , name , value ): attr = object . __getattribute__ ( self , name ) if len ( attr ) == 0 : object . __setattr__ ( self , name , value ) return attr . update ( value ) object . __setattr__ ( self , name , attr ) def _remove_from_field ( self , name , value ): if value not in self . belongs_to . keys (): return attr = object . __getattribute__ ( self , name ) if len ( attr ) == 0 : return del attr [ value ] object . __setattr__ ( self , name , attr ) def __str__ ( self ) -> str : return self . id def __hash__ ( self ) -> int : return hash ( self . id ) compatible_with : dict [ str , CType ] = field ( init = False , default_factory = dict ) class-attribute \u00b6 Library components of CType connectors : dict [ str , CConnector ] = field ( init = False , default_factory = dict ) class-attribute \u00b6 Compatible CType to be connected to id : str class-attribute \u00b6 Configurable parameters parameters : dict [ str , CParameter ] = field ( init = False , default_factory = dict ) class-attribute \u00b6 Accepted connectors","title":"c_type"},{"location":"reference/sym_cps/representation/library/elements/c_type/#sym_cps.representation.library.elements.c_type.CType","text":"Source code in sym_cps/representation/library/elements/c_type.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 @dataclass ( frozen = True ) class CType : id : str \"\"\"Configurable parameters\"\"\" parameters : dict [ str , CParameter ] = field ( init = False , default_factory = dict ) \"\"\"Accepted connectors\"\"\" connectors : dict [ str , CConnector ] = field ( init = False , default_factory = dict ) \"\"\"Compatible CType to be connected to\"\"\" compatible_with : dict [ str , CType ] = field ( init = False , default_factory = dict ) \"\"\"Library components of CType\"\"\" belongs_to : dict [ str , LibraryComponent ] = field ( init = False , default_factory = dict ) def _edit_field ( self , name , value ): object . __setattr__ ( self , name , value ) def _update_field ( self , name , value ): attr = object . __getattribute__ ( self , name ) if len ( attr ) == 0 : object . __setattr__ ( self , name , value ) return attr . update ( value ) object . __setattr__ ( self , name , attr ) def _remove_from_field ( self , name , value ): if value not in self . belongs_to . keys (): return attr = object . __getattribute__ ( self , name ) if len ( attr ) == 0 : return del attr [ value ] object . __setattr__ ( self , name , attr ) def __str__ ( self ) -> str : return self . id def __hash__ ( self ) -> int : return hash ( self . id )","title":"CType"},{"location":"reference/sym_cps/representation/library/elements/c_type/#sym_cps.representation.library.elements.c_type.CType.compatible_with","text":"Library components of CType","title":"compatible_with"},{"location":"reference/sym_cps/representation/library/elements/c_type/#sym_cps.representation.library.elements.c_type.CType.connectors","text":"Compatible CType to be connected to","title":"connectors"},{"location":"reference/sym_cps/representation/library/elements/c_type/#sym_cps.representation.library.elements.c_type.CType.id","text":"Configurable parameters","title":"id"},{"location":"reference/sym_cps/representation/library/elements/c_type/#sym_cps.representation.library.elements.c_type.CType.parameters","text":"Accepted connectors","title":"parameters"},{"location":"reference/sym_cps/representation/library/elements/library_component/","text":"LibraryComponent dataclass \u00b6 Represent and model of component in the components_library. It has fixed properties and can have parameters and connectors. Source code in sym_cps/representation/library/elements/library_component.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 @dataclass ( frozen = True ) class LibraryComponent : \"\"\"Represent and model of component in the components_library. It has fixed properties and can have parameters and connectors.\"\"\" \"\"\"Component Model Name\"\"\" id : str comp_type : CType properties : dict [ str , CProperty ] = field ( init = False , default_factory = dict ) @property def id_with_type ( self ) -> str : return f \" { self . id } [ { self . comp_type . id } ]\" @property def parameters ( self ) -> dict [ str , CParameter ]: return self . comp_type . parameters @property def connectors ( self ) -> dict [ str , CConnector ]: return self . comp_type . connectors def _edit_field ( self , name , value ): object . __setattr__ ( self , name , value ) def _update_field ( self , name , value ): attr = object . __getattribute__ ( self , name ) attr . update ( value ) object . __setattr__ ( self , name , attr ) def __hash__ ( self ): return hash ( str ( self . id )) def __eq__ ( self , other : object ): if not isinstance ( other , LibraryComponent ): raise Exception ( \"Different classes\" ) return self . id == other . id def __str__ ( self ) -> str : s1 = f \"name: { self . id } \\n \" f \"type: { str ( self . comp_type ) } \\n \" properties_str = [] for e in list ( self . properties . values ()): properties_str . append ( tab ( e )) properties = \" \\n \" . join ( properties_str ) parameters_str = [] for e in list ( self . parameters . values ()): parameters_str . append ( tab ( e )) parameters = \" \\n \" . join ( parameters_str ) connectors_str = [] for e in list ( self . connectors . values ()): connectors_str . append ( tab ( e )) connectors = \" \\n \" . join ( connectors_str ) s2 = f \"properties: \\n { properties } \\n \" s3 = f \"connectors: \\n { connectors } \\n \" s4 = f \"parameters: \\n { parameters } \\n \" return s1 + s2 + s3 + s4","title":"library_component"},{"location":"reference/sym_cps/representation/library/elements/library_component/#sym_cps.representation.library.elements.library_component.LibraryComponent","text":"Represent and model of component in the components_library. It has fixed properties and can have parameters and connectors. Source code in sym_cps/representation/library/elements/library_component.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 @dataclass ( frozen = True ) class LibraryComponent : \"\"\"Represent and model of component in the components_library. It has fixed properties and can have parameters and connectors.\"\"\" \"\"\"Component Model Name\"\"\" id : str comp_type : CType properties : dict [ str , CProperty ] = field ( init = False , default_factory = dict ) @property def id_with_type ( self ) -> str : return f \" { self . id } [ { self . comp_type . id } ]\" @property def parameters ( self ) -> dict [ str , CParameter ]: return self . comp_type . parameters @property def connectors ( self ) -> dict [ str , CConnector ]: return self . comp_type . connectors def _edit_field ( self , name , value ): object . __setattr__ ( self , name , value ) def _update_field ( self , name , value ): attr = object . __getattribute__ ( self , name ) attr . update ( value ) object . __setattr__ ( self , name , attr ) def __hash__ ( self ): return hash ( str ( self . id )) def __eq__ ( self , other : object ): if not isinstance ( other , LibraryComponent ): raise Exception ( \"Different classes\" ) return self . id == other . id def __str__ ( self ) -> str : s1 = f \"name: { self . id } \\n \" f \"type: { str ( self . comp_type ) } \\n \" properties_str = [] for e in list ( self . properties . values ()): properties_str . append ( tab ( e )) properties = \" \\n \" . join ( properties_str ) parameters_str = [] for e in list ( self . parameters . values ()): parameters_str . append ( tab ( e )) parameters = \" \\n \" . join ( parameters_str ) connectors_str = [] for e in list ( self . connectors . values ()): connectors_str . append ( tab ( e )) connectors = \" \\n \" . join ( connectors_str ) s2 = f \"properties: \\n { properties } \\n \" s3 = f \"connectors: \\n { connectors } \\n \" s4 = f \"parameters: \\n { parameters } \\n \" return s1 + s2 + s3 + s4","title":"LibraryComponent"},{"location":"reference/sym_cps/representation/tools/","text":"","title":"tools"},{"location":"reference/sym_cps/representation/tools/analyze/","text":"","title":"analyze"},{"location":"reference/sym_cps/representation/tools/connectors/","text":"","title":"connectors"},{"location":"reference/sym_cps/representation/tools/dictionaries/","text":"","title":"dictionaries"},{"location":"reference/sym_cps/representation/tools/ids/","text":"","title":"ids"},{"location":"reference/sym_cps/representation/tools/parameters_analysis/","text":"","title":"parameters_analysis"},{"location":"reference/sym_cps/representation/tools/export/","text":"","title":"export"},{"location":"reference/sym_cps/representation/tools/export/design_swri/","text":"","title":"design_swri"},{"location":"reference/sym_cps/representation/tools/parsers/","text":"","title":"parsers"},{"location":"reference/sym_cps/representation/tools/parsers/learn_from_designs/","text":"","title":"learn_from_designs"},{"location":"reference/sym_cps/representation/tools/parsers/parse/","text":"","title":"parse"},{"location":"reference/sym_cps/representation/tools/parsers/parsing_designs/","text":"parse_design_from_design_swri ( path , library ) \u00b6 Initialize a DConcrete from a design_swri file data Source code in sym_cps/representation/tools/parsers/parsing_designs.py 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 def parse_design_from_design_swri ( path : Path , library : Library ) -> DConcrete : \"\"\"Initialize a DConcrete from a design_swri file data\"\"\" \"\"\"Read design_swri file\"\"\" with open ( path , \"r\" ) as design_swri_file : design_swri_data = json . load ( design_swri_file ) \"\"\"Read the design name\"\"\" design_name = design_swri_data [ \"name\" ] new_design = DConcrete ( name = design_name ) \"\"\"Read the components and parameters\"\"\" # maps component instance name to library component component_map : dict [ str , tuple [ str , dict [ str , Parameter ]]] = {} for component_data in design_swri_data [ \"components\" ]: component_instance_str = component_data [ \"component_instance\" ] library_component_str = component_data [ \"component_choice\" ] component_map [ component_instance_str ] = ( library_component_str , {}) for parameter_data in design_swri_data [ \"parameters\" ]: parameter_name = parameter_data [ \"parameter_name\" ] parameter_value = parameter_data [ \"value\" ] component_properties = parameter_data [ \"component_properties\" ] parameters : dict [ str , Parameter ] = {} for prop in component_properties : component_name = prop [ \"component_name\" ] component_property = prop [ \"component_property\" ] library_component_str = component_map [ component_name ][ 0 ] param_id = parameter_id ( component_property , library . components [ library_component_str ] . comp_type . id ) for p , para in library . parameters . items (): print ( p ) try : param_type = library . parameters [ param_id ] except : print ( \"wasda\" ) param_type = library . parameters [ param_id ] parameter = Parameter ( parameter_value , param_type ) parameters [ param_id ] = parameter component_map [ component_name ][ 1 ][ param_id ] = parameter for p in parameters . values (): if isinstance ( p . component , str ): print ( \"ERRORRRR\" ) new_design . design_parameters [ parameter_name ] = DesignParameter ( id = parameter_name , parameters = set ( parameters . values ()) ) for component_name , ( library_component_str , parameters ) in component_map . items (): new_component = Component ( id = component_name , library_component = library . components [ library_component_str ], parameters = parameters , ) new_design . add_node ( new_component ) \"\"\"Read the connection\"\"\" for connection_data in design_swri_data [ \"connections\" ]: instance_s = connection_data [ \"from_ci\" ] instance_t = connection_data [ \"to_ci\" ] component_choice_s = component_map [ instance_s ][ 0 ] component_choice_t = component_map [ instance_t ][ 0 ] connector_id_s = connector_id ( name = connection_data [ \"from_conn\" ], component_type = str ( library . components [ component_choice_s ] . comp_type ), ) connector_id_t = connector_id ( name = connection_data [ \"to_conn\" ], component_type = str ( library . components [ component_choice_t ] . comp_type ), ) connection = Connection ( component_a = new_design . get_instance ( instance_s ), connector_a = library . connectors [ connector_id_s ], component_b = new_design . get_instance ( instance_t ), connector_b = library . connectors [ connector_id_t ], ) try : new_design . connect ( connection ) except : pass # d_concrete = new_design # d_topology = DTopology.from_concrete(new_design) \"\"\"TODO: Update connectable connectors\"\"\" # for key, value in connectable_connectors.items(): # for output_connector in value: # type: ignore # # print(f\"{key} -> {output_connector}\") # all_connectors[key]._update_field(\"compatible_with\", {all_connectors[output_connector].id: all_connectors[output_connector]}) return new_design","title":"parsing_designs"},{"location":"reference/sym_cps/representation/tools/parsers/parsing_designs/#sym_cps.representation.tools.parsers.parsing_designs.parse_design_from_design_swri","text":"Initialize a DConcrete from a design_swri file data Source code in sym_cps/representation/tools/parsers/parsing_designs.py 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 def parse_design_from_design_swri ( path : Path , library : Library ) -> DConcrete : \"\"\"Initialize a DConcrete from a design_swri file data\"\"\" \"\"\"Read design_swri file\"\"\" with open ( path , \"r\" ) as design_swri_file : design_swri_data = json . load ( design_swri_file ) \"\"\"Read the design name\"\"\" design_name = design_swri_data [ \"name\" ] new_design = DConcrete ( name = design_name ) \"\"\"Read the components and parameters\"\"\" # maps component instance name to library component component_map : dict [ str , tuple [ str , dict [ str , Parameter ]]] = {} for component_data in design_swri_data [ \"components\" ]: component_instance_str = component_data [ \"component_instance\" ] library_component_str = component_data [ \"component_choice\" ] component_map [ component_instance_str ] = ( library_component_str , {}) for parameter_data in design_swri_data [ \"parameters\" ]: parameter_name = parameter_data [ \"parameter_name\" ] parameter_value = parameter_data [ \"value\" ] component_properties = parameter_data [ \"component_properties\" ] parameters : dict [ str , Parameter ] = {} for prop in component_properties : component_name = prop [ \"component_name\" ] component_property = prop [ \"component_property\" ] library_component_str = component_map [ component_name ][ 0 ] param_id = parameter_id ( component_property , library . components [ library_component_str ] . comp_type . id ) for p , para in library . parameters . items (): print ( p ) try : param_type = library . parameters [ param_id ] except : print ( \"wasda\" ) param_type = library . parameters [ param_id ] parameter = Parameter ( parameter_value , param_type ) parameters [ param_id ] = parameter component_map [ component_name ][ 1 ][ param_id ] = parameter for p in parameters . values (): if isinstance ( p . component , str ): print ( \"ERRORRRR\" ) new_design . design_parameters [ parameter_name ] = DesignParameter ( id = parameter_name , parameters = set ( parameters . values ()) ) for component_name , ( library_component_str , parameters ) in component_map . items (): new_component = Component ( id = component_name , library_component = library . components [ library_component_str ], parameters = parameters , ) new_design . add_node ( new_component ) \"\"\"Read the connection\"\"\" for connection_data in design_swri_data [ \"connections\" ]: instance_s = connection_data [ \"from_ci\" ] instance_t = connection_data [ \"to_ci\" ] component_choice_s = component_map [ instance_s ][ 0 ] component_choice_t = component_map [ instance_t ][ 0 ] connector_id_s = connector_id ( name = connection_data [ \"from_conn\" ], component_type = str ( library . components [ component_choice_s ] . comp_type ), ) connector_id_t = connector_id ( name = connection_data [ \"to_conn\" ], component_type = str ( library . components [ component_choice_t ] . comp_type ), ) connection = Connection ( component_a = new_design . get_instance ( instance_s ), connector_a = library . connectors [ connector_id_s ], component_b = new_design . get_instance ( instance_t ), connector_b = library . connectors [ connector_id_t ], ) try : new_design . connect ( connection ) except : pass # d_concrete = new_design # d_topology = DTopology.from_concrete(new_design) \"\"\"TODO: Update connectable connectors\"\"\" # for key, value in connectable_connectors.items(): # for output_connector in value: # type: ignore # # print(f\"{key} -> {output_connector}\") # all_connectors[key]._update_field(\"compatible_with\", {all_connectors[output_connector].id: all_connectors[output_connector]}) return new_design","title":"parse_design_from_design_swri()"},{"location":"reference/sym_cps/representation/tools/parsers/parsing_library/","text":"parse_parameter_bounds () \u00b6 Parse design expert parameter bounds from 'lower_bound_file' 'lower_bound_file' Source code in sym_cps/representation/tools/parsers/parsing_library.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def parse_parameter_bounds () -> None : \"\"\"Parse design expert parameter bounds from 'lower_bound_file' 'lower_bound_file'\"\"\" if len ( all_parameters_lower_bounds ) == 0 : file = open ( lower_bound_file , \"r\" ) for line in file : k , v = line . strip () . split ( \":\" ) all_parameters_lower_bounds [ k . strip ()] = float ( v . strip ()) if len ( all_parameters_upper_bounds ) == 0 : file = open ( upper_bound_file , \"r\" ) for line in file : k , v = line . strip () . split ( \":\" ) all_parameters_upper_bounds [ k . strip ()] = float ( v . strip ())","title":"parsing_library"},{"location":"reference/sym_cps/representation/tools/parsers/parsing_library/#sym_cps.representation.tools.parsers.parsing_library.parse_parameter_bounds","text":"Parse design expert parameter bounds from 'lower_bound_file' 'lower_bound_file' Source code in sym_cps/representation/tools/parsers/parsing_library.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def parse_parameter_bounds () -> None : \"\"\"Parse design expert parameter bounds from 'lower_bound_file' 'lower_bound_file'\"\"\" if len ( all_parameters_lower_bounds ) == 0 : file = open ( lower_bound_file , \"r\" ) for line in file : k , v = line . strip () . split ( \":\" ) all_parameters_lower_bounds [ k . strip ()] = float ( v . strip ()) if len ( all_parameters_upper_bounds ) == 0 : file = open ( upper_bound_file , \"r\" ) for line in file : k , v = line . strip () . split ( \":\" ) all_parameters_upper_bounds [ k . strip ()] = float ( v . strip ())","title":"parse_parameter_bounds()"},{"location":"reference/sym_cps/representation/tools/parsers/temp_objects/","text":"","title":"temp_objects"},{"location":"reference/sym_cps/shared/","text":"","title":"shared"},{"location":"reference/sym_cps/shared/designs/","text":"","title":"designs"},{"location":"reference/sym_cps/shared/library/","text":"","title":"library"},{"location":"reference/sym_cps/shared/objects/","text":"","title":"objects"},{"location":"reference/sym_cps/shared/paths/","text":"","title":"paths"},{"location":"reference/sym_cps/tools/","text":"","title":"tools"},{"location":"reference/sym_cps/tools/io/","text":"","title":"io"},{"location":"reference/sym_cps/tools/persistance/","text":"","title":"persistance"},{"location":"reference/sym_cps/tools/strings/","text":"","title":"strings"},{"location":"reference/sym_cps/tools/update_library/","text":"update_dat_files_and_export () \u00b6 Loads library of components and seed designs and store them Source code in sym_cps/tools/update_library.py 26 27 28 29 def update_dat_files_and_export (): \"\"\"Loads library of components and seed designs and store them\"\"\" update_dat_files_library () export_all_designs () update_dat_files_library () \u00b6 Loads library of components and seed designs and store them Source code in sym_cps/tools/update_library.py 5 6 7 8 9 def update_dat_files_library (): \"\"\"Loads library of components and seed designs and store them\"\"\" c_library , designs = parse_library_and_seed_designs () dump ( c_library , \"library.dat\" ) dump ( designs , \"designs.dat\" )","title":"update_library"},{"location":"reference/sym_cps/tools/update_library/#sym_cps.tools.update_library.update_dat_files_and_export","text":"Loads library of components and seed designs and store them Source code in sym_cps/tools/update_library.py 26 27 28 29 def update_dat_files_and_export (): \"\"\"Loads library of components and seed designs and store them\"\"\" update_dat_files_library () export_all_designs ()","title":"update_dat_files_and_export()"},{"location":"reference/sym_cps/tools/update_library/#sym_cps.tools.update_library.update_dat_files_library","text":"Loads library of components and seed designs and store them Source code in sym_cps/tools/update_library.py 5 6 7 8 9 def update_dat_files_library (): \"\"\"Loads library of components and seed designs and store them\"\"\" c_library , designs = parse_library_and_seed_designs () dump ( c_library , \"library.dat\" ) dump ( designs , \"designs.dat\" )","title":"update_dat_files_library()"},{"location":"coverage/","text":".md-content { max-width: none !important; } article h1, article > a { display: none; } var coviframe = document.getElementById(\"coviframe\"); function resizeIframe() { coviframe.style.height = coviframe.contentWindow.document.documentElement.offsetHeight + 'px'; } coviframe.contentWindow.document.body.onclick = function() { coviframe.contentWindow.location.reload(); }","title":"Coverage report"}]}