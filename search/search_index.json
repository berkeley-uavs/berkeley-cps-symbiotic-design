{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"sym-cps \u00b6 Symbiotic Design for Cyber Physical Systems Project description available here Documentation available here Installation \u00b6 System Requirements \u00b6 pdm conda Access to the INPUT folder on Google Drive. Copy data and output directories in the root of the repo Dependencies \u00b6 To install the dependencies and environment, simply run: make setup Make sure that the script does: * Pull the submodules * Install dependencies via pdm * Create a new conda environment and install the conda dependencies Make sure that eval_pipeline folder is not empty. If the submodule was not pulled correctly you can simply clone this repo and copy its content inside eval_pipeline . Activate conda \u00b6 Once script terminates successfully you can activate the environment: conda activate ./.venv Configure AWS \u00b6 Download the aws-cvpn-config.ovpn configuration file from the INPUT folder on Google Drive and use it to connect to the AWS VPN. Here are the instructions for Linux , MacOS and Windows . Create the folder ./output/aws if it does not exist already. (Optional) notify your IDE to exclude the aws folder from being indexed. For example in PyCharm do Right Click on aws - Mark directory as - Excluded Mount the shared folder in ./output/aws . Instructions here . Make sure you are connected via the VPN before mounting the shared drive. Suggestion: from the root folder of the repo, you can try one of the following commands, according to your OS and preferences sudo mount -t nfs 10.0.137.113:/fsx/ ./output/aws sudo mount_nfs -o resvport 10.0.137.113:/fsx/ ./output/aws After have successfully installed the dependencies and activated the conda environment. Launch the following command from the root of the repo sudo pdm run suam-config install --no-symlink --input = ./data/broker.conf.yaml Examples \u00b6 Check the example folder and look at the code of the python files to get familiar with the API. Here's some example you can launch. Populate the library of components from the data folder python src/sym_cps/examples/library.py Extracts the seed designs python src/sym_cps/examples/designs.py Create a new design from scratch. First choosing and topology and then concretize it. python src/sym_cps/examples/topology.py Evaluate designs from command line specifying the path of the design_swri,json in <design-file> : sudo pdm run suam-client direct2cad.process-design --design = <design-file> --results = ./output/aws/results For example: pdm run suam-client direct2cad.process-design --design = ./output/designs/TestQuad/design_swri.json --results = ./output/aws/results Evaluate designs from python python src/sym_cps/examples/evaluation.py Web interface \u00b6 Run the back-end by executing backend/app.py Install react dependencies via npm by running: npm install --legacy-peer-deps inside the frontend folder. Then run the front-end: npm run start Troubleshooting \u00b6 NOTE: If you have problems with the environment you can clean up the files and folders created by pdm and conda by running make uninstall Then try make setup again. Note Install PDM manually. You can install it with: python3 -m pip install --user pipx pipx install pdm Now you can try running make setup again. Note Problems installing dependencies Look at the setup script located in scripts/setup.sh and launch the commands individually. You can make a clean installation by first running make uninstall and then make setup again. Note Apple Silicon Make sure that you are running a x86 terminal. You can run x86 terminal commands with Apple\u2019s Rosetta 2 by launching: arch -x86_64 /bin/bash Note Conda for Mac with Apple Silicon Some of the packages in conda do not support arm64 architecture. To install all the dependencies correctly on a Mac with Apple Silicon, make sure that you are running conda for x86_64 architecture. You can install miniconda for MacOSX x86_64 by running the following commands curl -L https://repo.anaconda.com/miniconda/Miniconda3-latest-MacOSX-x86_64.sh > Miniconda3-latest-MacOSX-x86_64.sh sh Miniconda3-latest-MacOSX-x86_64.sh Note Working with PEP 582 With PEP 582, dependencies will be installed into pypackages directory under the project root. With PEP 582 enabled globally, you can also use the project interpreter to run scripts directly. Check pdm documentation on PEP 582. To configure VSCode to support PEP 582, open .vscode/settings.json (create one if it does not exist) and add the following entries: { \"python.autoComplete.extraPaths\" : [ \"__pypackages__/3.10/lib\" ], \"python.analysis.extraPaths\" : [ \"__pypackages__/3.10/lib\" ] } Note VSCode and Apple Silicon To run a x86 terminal by default in VSCode. Add the following to your settings.json ```json \"terminal.integrated.profiles.osx\": { \"x86 bash\": { \"path\": \"/usr/bin/arch\", \"args\": [\"-arch\", \"x86_64\", \"/bin/bash\"] } }, \"terminal.integrated.defaultProfile.osx\": \"x86 bash\" NOTE: PyCharm and Apple Silicon Go to Preferences/Tools/Terminal and set the shell path to be: ```bash env /usr/bin/arch -x86_64 /bin/zsh --login License \u00b6 MIT Features and Credits \u00b6 Fully typed with annotations and checked with mypy, PEP561 compatible","title":"Overview"},{"location":"#sym-cps","text":"Symbiotic Design for Cyber Physical Systems Project description available here Documentation available here","title":"sym-cps"},{"location":"#installation","text":"","title":"Installation"},{"location":"#system-requirements","text":"pdm conda Access to the INPUT folder on Google Drive. Copy data and output directories in the root of the repo","title":"System Requirements"},{"location":"#dependencies","text":"To install the dependencies and environment, simply run: make setup Make sure that the script does: * Pull the submodules * Install dependencies via pdm * Create a new conda environment and install the conda dependencies Make sure that eval_pipeline folder is not empty. If the submodule was not pulled correctly you can simply clone this repo and copy its content inside eval_pipeline .","title":"Dependencies"},{"location":"#activate-conda","text":"Once script terminates successfully you can activate the environment: conda activate ./.venv","title":"Activate conda"},{"location":"#configure-aws","text":"Download the aws-cvpn-config.ovpn configuration file from the INPUT folder on Google Drive and use it to connect to the AWS VPN. Here are the instructions for Linux , MacOS and Windows . Create the folder ./output/aws if it does not exist already. (Optional) notify your IDE to exclude the aws folder from being indexed. For example in PyCharm do Right Click on aws - Mark directory as - Excluded Mount the shared folder in ./output/aws . Instructions here . Make sure you are connected via the VPN before mounting the shared drive. Suggestion: from the root folder of the repo, you can try one of the following commands, according to your OS and preferences sudo mount -t nfs 10.0.137.113:/fsx/ ./output/aws sudo mount_nfs -o resvport 10.0.137.113:/fsx/ ./output/aws After have successfully installed the dependencies and activated the conda environment. Launch the following command from the root of the repo sudo pdm run suam-config install --no-symlink --input = ./data/broker.conf.yaml","title":"Configure AWS"},{"location":"#examples","text":"Check the example folder and look at the code of the python files to get familiar with the API. Here's some example you can launch. Populate the library of components from the data folder python src/sym_cps/examples/library.py Extracts the seed designs python src/sym_cps/examples/designs.py Create a new design from scratch. First choosing and topology and then concretize it. python src/sym_cps/examples/topology.py Evaluate designs from command line specifying the path of the design_swri,json in <design-file> : sudo pdm run suam-client direct2cad.process-design --design = <design-file> --results = ./output/aws/results For example: pdm run suam-client direct2cad.process-design --design = ./output/designs/TestQuad/design_swri.json --results = ./output/aws/results Evaluate designs from python python src/sym_cps/examples/evaluation.py","title":"Examples"},{"location":"#web-interface","text":"Run the back-end by executing backend/app.py Install react dependencies via npm by running: npm install --legacy-peer-deps inside the frontend folder. Then run the front-end: npm run start","title":"Web interface"},{"location":"#troubleshooting","text":"NOTE: If you have problems with the environment you can clean up the files and folders created by pdm and conda by running make uninstall Then try make setup again. Note Install PDM manually. You can install it with: python3 -m pip install --user pipx pipx install pdm Now you can try running make setup again. Note Problems installing dependencies Look at the setup script located in scripts/setup.sh and launch the commands individually. You can make a clean installation by first running make uninstall and then make setup again. Note Apple Silicon Make sure that you are running a x86 terminal. You can run x86 terminal commands with Apple\u2019s Rosetta 2 by launching: arch -x86_64 /bin/bash Note Conda for Mac with Apple Silicon Some of the packages in conda do not support arm64 architecture. To install all the dependencies correctly on a Mac with Apple Silicon, make sure that you are running conda for x86_64 architecture. You can install miniconda for MacOSX x86_64 by running the following commands curl -L https://repo.anaconda.com/miniconda/Miniconda3-latest-MacOSX-x86_64.sh > Miniconda3-latest-MacOSX-x86_64.sh sh Miniconda3-latest-MacOSX-x86_64.sh Note Working with PEP 582 With PEP 582, dependencies will be installed into pypackages directory under the project root. With PEP 582 enabled globally, you can also use the project interpreter to run scripts directly. Check pdm documentation on PEP 582. To configure VSCode to support PEP 582, open .vscode/settings.json (create one if it does not exist) and add the following entries: { \"python.autoComplete.extraPaths\" : [ \"__pypackages__/3.10/lib\" ], \"python.analysis.extraPaths\" : [ \"__pypackages__/3.10/lib\" ] } Note VSCode and Apple Silicon To run a x86 terminal by default in VSCode. Add the following to your settings.json ```json \"terminal.integrated.profiles.osx\": { \"x86 bash\": { \"path\": \"/usr/bin/arch\", \"args\": [\"-arch\", \"x86_64\", \"/bin/bash\"] } }, \"terminal.integrated.defaultProfile.osx\": \"x86 bash\" NOTE: PyCharm and Apple Silicon Go to Preferences/Tools/Terminal and set the shell path to be: ```bash env /usr/bin/arch -x86_64 /bin/zsh --login","title":"Troubleshooting"},{"location":"#license","text":"MIT","title":"License"},{"location":"#features-and-credits","text":"Fully typed with annotations and checked with mypy, PEP561 compatible","title":"Features and Credits"},{"location":"changelog/","text":"Changelog \u00b6 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"contributing/","text":"Contributing \u00b6 Contributions are welcome, and they are greatly appreciated! Tasks \u00b6 This project uses duty to run tasks. A Makefile is also provided. Once the project is installed ( make setup ), run make help to see all available tasks Development \u00b6 We use pdm to manage the dependencies. Use pdm add to install new packages. Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) if you updated the documentation or the project dependencies: run make docs-serve go to http://localhost:8000 and check that everything looks good Activate Pre-Commit Hooks pre-commit install","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated!","title":"Contributing"},{"location":"contributing/#tasks","text":"This project uses duty to run tasks. A Makefile is also provided. Once the project is installed ( make setup ), run make help to see all available tasks","title":"Tasks"},{"location":"contributing/#development","text":"We use pdm to manage the dependencies. Use pdm add to install new packages. Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) if you updated the documentation or the project dependencies: run make docs-serve go to http://localhost:8000 and check that everything looks good Activate Pre-Commit Hooks pre-commit install","title":"Development"},{"location":"credits/","text":"Traceback ( most recent call last ): File \"/Users/pier/Projects/berkeley-cps-symbiotic-design_PUBLIC/__pypackages__/3.10/lib/markdown_exec/formatters/python.py\" , line 23 , in _run_python exec ( code , exec_globals ) # noqa: S102 File \"<executed code block>\" , line 59 , in < module > prod_dependencies = get_deps ( File \"<executed code block>\" , line 42 , in get_deps deps [ dep_name ] = { \"license\" : get_license ( dep_name ), ** parsed , ** lock_pkgs [ dep_name ]} KeyError : 'eval-pipeline'","title":"Credits"},{"location":"license/","text":"ISC License Copyright (c) 2021, LOGiCS Team Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies. THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.","title":"License"},{"location":"reference/SUMMARY/","text":"backend app operations rating shared paths sym_cps classifier cli control database evaluation cli tools examples design_swri designs evaluation library topology grammar hci optimizers concrete_opt params_opt optimizer param_opt_problem tools optimization bayesian_opt_visualizer bayesian_optimizer optimizer_base problem_base test_optimization test_bayesian_opt util exceptions history surrogate visualize topo_opt representation design concrete elements component connection design_parameters parameter topology library elements c_connector c_parameter c_property c_type library_component tools analyze connectors export design_swri ids parsers learn_from_designs parse parsing_designs parsing_library temp_objects shared paths tools io persistance strings","title":"SUMMARY"},{"location":"reference/backend/","text":"","title":"backend"},{"location":"reference/backend/app/","text":"check_if_session_exist ( session_id ) \u00b6 Check if a session is free and if the user can enter it. Parameters: Name Type Description Default session_id str the id of the wanted session. required Source code in backend/app.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 @socketio . on ( \"session-existing\" ) def check_if_session_exist ( session_id : str ) -> None : \"\"\"Check if a session is free and if the user can enter it. Arguments: session_id: the id of the wanted session. \"\"\" tab_id = str ( request . args . get ( \"tabId\" )) cookie = str ( request . args . get ( \"cookie\" )) print ( \"check if following session exists : \" + session_id ) dir_path , dir_names , filenames = next ( walk ( storage_path )) found = False sessions_folder = f \"s_\" + session_id for dir_name in dir_names : if dir_name == sessions_folder : found = True if session_id == \"default\" or session_id == \"contracts\" : found = False if found : if session_id in users and cookie != cookies [ session_id ]: found = False print ( f \"users : { users } \" ) emit ( \"receive-answer\" , found , room = users [ str ( request . args . get ( \"id\" ))][ tab_id ]) connected () \u00b6 Establish the connection between the front and the back while checking that the session is not already in use. Source code in backend/app.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 @socketio . on ( \"connect\" ) def connected () -> None : \"\"\"Establish the connection between the front and the back while checking that the session is not already in use.\"\"\" print ( \"Connected\" ) print ( f 'ID { request . args . get ( \"id\" ) } ' ) lock = threading . Lock () lock . acquire () session_id = str ( request . args . get ( \"id\" )) cookie = str ( request . args . get ( \"cookie\" )) tab_id = str ( request . args . get ( \"tabId\" )) if session_id in users : # Check if this session is already open if cookie != cookies [ session_id ]: emit ( \"is-connected\" , False , room = request . sid ) return else : users [ session_id ] = {} users [ session_id ][ tab_id ] = request . sid cookies [ session_id ] = cookie now = time . localtime ( time . time ()) emit ( \"send-message\" , strftime ( \"%H:%M:%S\" , now ) + f \" Connected to session { request . args . get ( 'id' ) } \" , room = request . sid ) emit ( \"is-connected\" , True , room = request . sid ) lock . release () create_design ( data ) \u00b6 Create the design and the mealy according to the strategy indicated Parameters: Name Type Description Default data Dict A dictionary that contains all the information about the synthesis that will be created. required Source code in backend/app.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 @socketio . on ( \"create-design\" ) def create_design ( data : Dict ) -> None : \"\"\"Create the design and the mealy according to the strategy indicated Arguments: data: A dictionary that contains all the information about the synthesis that will be created. \"\"\" print ( f \"create-design received with { data } \" ) try : json_content = Rating . generate_design ( data , request . args . get ( \"id\" )) send_message_to_user ( f \"The mealy has been created using { data [ 'strategy' ] } method\" , request . sid , \"success\" ) emit ( \"design-created\" , json_content , room = request . sid ) except Exception as e : emit ( \"design-created\" , False , room = request . sid ) emit ( \"send-notification\" , { \"content\" : \"The mealy creation has failed. See the console for more information\" , \"crometypes\" : \"error\" }, room = request . sid , ) emit ( \"send-message\" , f \"Mealy \\\" { data [ 'name' ] } \\\" can't be created. Error : { str ( e ) } \" , room = request . sid ) disconnected () \u00b6 It disconnects the user of the session he was attached to. Source code in backend/app.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 @socketio . on ( \"disconnect\" ) def disconnected () -> None : \"\"\"It disconnects the user of the session he was attached to.\"\"\" print ( \"Disconnected\" ) print ( request . args ) print ( f 'ID { request . args . get ( \"id\" ) } ' ) session_id = str ( request . args . get ( \"id\" )) tab_id = str ( request . args . get ( \"tabId\" )) if session_id in users and tab_id in users [ session_id ]: now = time . localtime ( time . time ()) emit ( \"send-message\" , f \" { strftime ( '%H:%M:%S' , now ) } Session { request . args . get ( 'id' ) } disconnected\" , room = request . sid , ) del users [ session_id ][ tab_id ] send_message_to_user ( content , room_id , crometype ) \u00b6 Simplified version to send a notification and a message to a user. Parameters: Name Type Description Default content str The content of the message. required room_id str Where to send the notification and the message. required crometype str The type of notification to send. required Source code in backend/app.py 124 125 126 127 128 129 130 131 132 133 134 def send_message_to_user ( content : str , room_id : str , crometype : str ) -> None : \"\"\"Simplified version to send a notification and a message to a user. Arguments: content: The content of the message. room_id: Where to send the notification and the message. crometype: The type of notification to send. \"\"\" now = time . localtime ( time . time ()) emit ( \"send-notification\" , { \"crometypes\" : crometype , \"content\" : content }, room = room_id ) emit ( \"send-message\" , f \" { strftime ( '%H:%M:%S' , now ) } - { content } \" , room = room_id )","title":"app"},{"location":"reference/backend/app/#backend.app.check_if_session_exist","text":"Check if a session is free and if the user can enter it. Parameters: Name Type Description Default session_id str the id of the wanted session. required Source code in backend/app.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 @socketio . on ( \"session-existing\" ) def check_if_session_exist ( session_id : str ) -> None : \"\"\"Check if a session is free and if the user can enter it. Arguments: session_id: the id of the wanted session. \"\"\" tab_id = str ( request . args . get ( \"tabId\" )) cookie = str ( request . args . get ( \"cookie\" )) print ( \"check if following session exists : \" + session_id ) dir_path , dir_names , filenames = next ( walk ( storage_path )) found = False sessions_folder = f \"s_\" + session_id for dir_name in dir_names : if dir_name == sessions_folder : found = True if session_id == \"default\" or session_id == \"contracts\" : found = False if found : if session_id in users and cookie != cookies [ session_id ]: found = False print ( f \"users : { users } \" ) emit ( \"receive-answer\" , found , room = users [ str ( request . args . get ( \"id\" ))][ tab_id ])","title":"check_if_session_exist()"},{"location":"reference/backend/app/#backend.app.connected","text":"Establish the connection between the front and the back while checking that the session is not already in use. Source code in backend/app.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 @socketio . on ( \"connect\" ) def connected () -> None : \"\"\"Establish the connection between the front and the back while checking that the session is not already in use.\"\"\" print ( \"Connected\" ) print ( f 'ID { request . args . get ( \"id\" ) } ' ) lock = threading . Lock () lock . acquire () session_id = str ( request . args . get ( \"id\" )) cookie = str ( request . args . get ( \"cookie\" )) tab_id = str ( request . args . get ( \"tabId\" )) if session_id in users : # Check if this session is already open if cookie != cookies [ session_id ]: emit ( \"is-connected\" , False , room = request . sid ) return else : users [ session_id ] = {} users [ session_id ][ tab_id ] = request . sid cookies [ session_id ] = cookie now = time . localtime ( time . time ()) emit ( \"send-message\" , strftime ( \"%H:%M:%S\" , now ) + f \" Connected to session { request . args . get ( 'id' ) } \" , room = request . sid ) emit ( \"is-connected\" , True , room = request . sid ) lock . release ()","title":"connected()"},{"location":"reference/backend/app/#backend.app.create_design","text":"Create the design and the mealy according to the strategy indicated Parameters: Name Type Description Default data Dict A dictionary that contains all the information about the synthesis that will be created. required Source code in backend/app.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 @socketio . on ( \"create-design\" ) def create_design ( data : Dict ) -> None : \"\"\"Create the design and the mealy according to the strategy indicated Arguments: data: A dictionary that contains all the information about the synthesis that will be created. \"\"\" print ( f \"create-design received with { data } \" ) try : json_content = Rating . generate_design ( data , request . args . get ( \"id\" )) send_message_to_user ( f \"The mealy has been created using { data [ 'strategy' ] } method\" , request . sid , \"success\" ) emit ( \"design-created\" , json_content , room = request . sid ) except Exception as e : emit ( \"design-created\" , False , room = request . sid ) emit ( \"send-notification\" , { \"content\" : \"The mealy creation has failed. See the console for more information\" , \"crometypes\" : \"error\" }, room = request . sid , ) emit ( \"send-message\" , f \"Mealy \\\" { data [ 'name' ] } \\\" can't be created. Error : { str ( e ) } \" , room = request . sid )","title":"create_design()"},{"location":"reference/backend/app/#backend.app.disconnected","text":"It disconnects the user of the session he was attached to. Source code in backend/app.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 @socketio . on ( \"disconnect\" ) def disconnected () -> None : \"\"\"It disconnects the user of the session he was attached to.\"\"\" print ( \"Disconnected\" ) print ( request . args ) print ( f 'ID { request . args . get ( \"id\" ) } ' ) session_id = str ( request . args . get ( \"id\" )) tab_id = str ( request . args . get ( \"tabId\" )) if session_id in users and tab_id in users [ session_id ]: now = time . localtime ( time . time ()) emit ( \"send-message\" , f \" { strftime ( '%H:%M:%S' , now ) } Session { request . args . get ( 'id' ) } disconnected\" , room = request . sid , ) del users [ session_id ][ tab_id ]","title":"disconnected()"},{"location":"reference/backend/app/#backend.app.send_message_to_user","text":"Simplified version to send a notification and a message to a user. Parameters: Name Type Description Default content str The content of the message. required room_id str Where to send the notification and the message. required crometype str The type of notification to send. required Source code in backend/app.py 124 125 126 127 128 129 130 131 132 133 134 def send_message_to_user ( content : str , room_id : str , crometype : str ) -> None : \"\"\"Simplified version to send a notification and a message to a user. Arguments: content: The content of the message. room_id: Where to send the notification and the message. crometype: The type of notification to send. \"\"\" now = time . localtime ( time . time ()) emit ( \"send-notification\" , { \"crometypes\" : crometype , \"content\" : content }, room = room_id ) emit ( \"send-message\" , f \" { strftime ( '%H:%M:%S' , now ) } - { content } \" , room = room_id )","title":"send_message_to_user()"},{"location":"reference/backend/operations/","text":"","title":"operations"},{"location":"reference/backend/operations/rating/","text":"Rating \u00b6 Class that has all the useful functions to synthesis a design. Source code in backend/operations/rating.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Rating : \"\"\"Class that has all the useful functions to synthesis a design.\"\"\" @staticmethod def generate_design ( data : dict , session_id : str ) -> str : \"\"\"Create a design from a synthesis. Arguments: session_id: The id of the session where the design is saved. data: A dictionary that contains all the information of the design generation. Returns: The mealy machine that is/are the representation of the design. \"\"\" full_name = data [ \"name\" ] if data [ \"strategy\" ] == \"strategy_random\" : from backend.app import topo_opt d_topology : DTopology = topo_opt . generate_topology ( name = full_name , strategy = TopologyStrategy . random_strategy ) print ( \"****D_TOPOLOGY****\" ) print ( d_topology ) d_topology . export ( ExportType . TXT ) d_topology . export ( ExportType . DOT ) d_topology . export ( ExportType . DOT ) \"\"\"TODO: SEND THE DOT (GRAPHVIZ) TO THE FRONT END AND VISUALIZE IT https://github.com/magjac/graphviz-visual-editor https://github.com/DomParfitt/graphviz-react https://www.npmjs.com/package/graphviz-react .... etc.. \"\"\" return \"...GRAPHVIZ DOT GRAPH....\" generate_design ( data , session_id ) staticmethod \u00b6 Create a design from a synthesis. Parameters: Name Type Description Default session_id str The id of the session where the design is saved. required data dict A dictionary that contains all the information of the design generation. required Returns: Type Description str The mealy machine that is/are the representation of the design. Source code in backend/operations/rating.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 @staticmethod def generate_design ( data : dict , session_id : str ) -> str : \"\"\"Create a design from a synthesis. Arguments: session_id: The id of the session where the design is saved. data: A dictionary that contains all the information of the design generation. Returns: The mealy machine that is/are the representation of the design. \"\"\" full_name = data [ \"name\" ] if data [ \"strategy\" ] == \"strategy_random\" : from backend.app import topo_opt d_topology : DTopology = topo_opt . generate_topology ( name = full_name , strategy = TopologyStrategy . random_strategy ) print ( \"****D_TOPOLOGY****\" ) print ( d_topology ) d_topology . export ( ExportType . TXT ) d_topology . export ( ExportType . DOT ) d_topology . export ( ExportType . DOT ) \"\"\"TODO: SEND THE DOT (GRAPHVIZ) TO THE FRONT END AND VISUALIZE IT https://github.com/magjac/graphviz-visual-editor https://github.com/DomParfitt/graphviz-react https://www.npmjs.com/package/graphviz-react .... etc.. \"\"\" return \"...GRAPHVIZ DOT GRAPH....\"","title":"rating"},{"location":"reference/backend/operations/rating/#backend.operations.rating.Rating","text":"Class that has all the useful functions to synthesis a design. Source code in backend/operations/rating.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Rating : \"\"\"Class that has all the useful functions to synthesis a design.\"\"\" @staticmethod def generate_design ( data : dict , session_id : str ) -> str : \"\"\"Create a design from a synthesis. Arguments: session_id: The id of the session where the design is saved. data: A dictionary that contains all the information of the design generation. Returns: The mealy machine that is/are the representation of the design. \"\"\" full_name = data [ \"name\" ] if data [ \"strategy\" ] == \"strategy_random\" : from backend.app import topo_opt d_topology : DTopology = topo_opt . generate_topology ( name = full_name , strategy = TopologyStrategy . random_strategy ) print ( \"****D_TOPOLOGY****\" ) print ( d_topology ) d_topology . export ( ExportType . TXT ) d_topology . export ( ExportType . DOT ) d_topology . export ( ExportType . DOT ) \"\"\"TODO: SEND THE DOT (GRAPHVIZ) TO THE FRONT END AND VISUALIZE IT https://github.com/magjac/graphviz-visual-editor https://github.com/DomParfitt/graphviz-react https://www.npmjs.com/package/graphviz-react .... etc.. \"\"\" return \"...GRAPHVIZ DOT GRAPH....\"","title":"Rating"},{"location":"reference/backend/operations/rating/#backend.operations.rating.Rating.generate_design","text":"Create a design from a synthesis. Parameters: Name Type Description Default session_id str The id of the session where the design is saved. required data dict A dictionary that contains all the information of the design generation. required Returns: Type Description str The mealy machine that is/are the representation of the design. Source code in backend/operations/rating.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 @staticmethod def generate_design ( data : dict , session_id : str ) -> str : \"\"\"Create a design from a synthesis. Arguments: session_id: The id of the session where the design is saved. data: A dictionary that contains all the information of the design generation. Returns: The mealy machine that is/are the representation of the design. \"\"\" full_name = data [ \"name\" ] if data [ \"strategy\" ] == \"strategy_random\" : from backend.app import topo_opt d_topology : DTopology = topo_opt . generate_topology ( name = full_name , strategy = TopologyStrategy . random_strategy ) print ( \"****D_TOPOLOGY****\" ) print ( d_topology ) d_topology . export ( ExportType . TXT ) d_topology . export ( ExportType . DOT ) d_topology . export ( ExportType . DOT ) \"\"\"TODO: SEND THE DOT (GRAPHVIZ) TO THE FRONT END AND VISUALIZE IT https://github.com/magjac/graphviz-visual-editor https://github.com/DomParfitt/graphviz-react https://www.npmjs.com/package/graphviz-react .... etc.. \"\"\" return \"...GRAPHVIZ DOT GRAPH....\"","title":"generate_design()"},{"location":"reference/backend/shared/","text":"","title":"shared"},{"location":"reference/backend/shared/paths/","text":"","title":"paths"},{"location":"reference/sym_cps/","text":"sym_cps package. Develop AI-based approaches to enable correct-by-construction design of Cyber Physical Systems","title":"sym_cps"},{"location":"reference/sym_cps/cli/","text":"Module that contains the command line application. get_parser () \u00b6 Return the CLI argument parser. Returns: Type Description argparse . ArgumentParser An argparse parser. Source code in sym_cps/cli.py 10 11 12 13 14 15 16 17 def get_parser () -> argparse . ArgumentParser : \"\"\" Return the CLI argument parser. Returns: An argparse parser. \"\"\" return argparse . ArgumentParser ( prog = \"sym-cps\" )","title":"cli"},{"location":"reference/sym_cps/cli/#sym_cps.cli.get_parser","text":"Return the CLI argument parser. Returns: Type Description argparse . ArgumentParser An argparse parser. Source code in sym_cps/cli.py 10 11 12 13 14 15 16 17 def get_parser () -> argparse . ArgumentParser : \"\"\" Return the CLI argument parser. Returns: An argparse parser. \"\"\" return argparse . ArgumentParser ( prog = \"sym-cps\" )","title":"get_parser()"},{"location":"reference/sym_cps/classifier/","text":"","title":"classifier"},{"location":"reference/sym_cps/control/","text":"","title":"control"},{"location":"reference/sym_cps/database/","text":"","title":"database"},{"location":"reference/sym_cps/evaluation/","text":"File adapted from: https://github.com/LOGiCS-Project/swri-simple-uam-example evaluate_design ( design_json_path , metadata = None , timeout = 800 , info_only = False ) \u00b6 Evaluate a design_swri.json provided at location 'design_json_path' Metadata to include with the operation, becomes part of metadata.json in the result. Source code in sym_cps/evaluation/__init__.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def evaluate_design ( design_json_path : Path , metadata : Path | dict | None = None , timeout : int = 800 , info_only : bool = False ): \"\"\" Evaluate a design_swri.json provided at location 'design_json_path' Metadata to include with the operation, becomes part of metadata.json in the result. \"\"\" print ( f \"Input file: { design_json_path } \" ) # Load the design from file print ( \"Loading Design\" ) design = load_design ( design_json_path ) # Load the metadata from file print ( \"Loading Metadata (if provided)\" ) metadata = load_metadata ( metadata ) # Send the design to worker print ( \"Sending Design to Broker\" ) if info_only : print ( \"Generating info...\" ) msg = direct2cad . gen_info_files . send ( design , metadata = metadata ) else : print ( \"Processing design...\" ) msg = direct2cad . process_design . send ( design , metadata = metadata ) print ( \"Waiting for results...\" ) result_path = polling_results ( msg , timeout ) print ( f \"Command completed. Results can be found at: { result_path } \" ) # Obtain information from the result foleder if not info_only : return extract_results ( result_path ) else : return None","title":"evaluation"},{"location":"reference/sym_cps/evaluation/#sym_cps.evaluation.evaluate_design","text":"Evaluate a design_swri.json provided at location 'design_json_path' Metadata to include with the operation, becomes part of metadata.json in the result. Source code in sym_cps/evaluation/__init__.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def evaluate_design ( design_json_path : Path , metadata : Path | dict | None = None , timeout : int = 800 , info_only : bool = False ): \"\"\" Evaluate a design_swri.json provided at location 'design_json_path' Metadata to include with the operation, becomes part of metadata.json in the result. \"\"\" print ( f \"Input file: { design_json_path } \" ) # Load the design from file print ( \"Loading Design\" ) design = load_design ( design_json_path ) # Load the metadata from file print ( \"Loading Metadata (if provided)\" ) metadata = load_metadata ( metadata ) # Send the design to worker print ( \"Sending Design to Broker\" ) if info_only : print ( \"Generating info...\" ) msg = direct2cad . gen_info_files . send ( design , metadata = metadata ) else : print ( \"Processing design...\" ) msg = direct2cad . process_design . send ( design , metadata = metadata ) print ( \"Waiting for results...\" ) result_path = polling_results ( msg , timeout ) print ( f \"Command completed. Results can be found at: { result_path } \" ) # Obtain information from the result foleder if not info_only : return extract_results ( result_path ) else : return None","title":"evaluate_design()"},{"location":"reference/sym_cps/evaluation/cli/","text":"File adapted from: https://github.com/LOGiCS-Project/swri-simple-uam-example get_args () \u00b6 Creates a parser and returns the arguments for this utility. Source code in sym_cps/evaluation/cli.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def get_args (): \"\"\" Creates a parser and returns the arguments for this utility. \"\"\" parser = argparse . ArgumentParser ( description = 'Process a design' ) parser . add_argument ( '-results_dir' , type = Path , help = 'The directory that will be checked when looking for new results.' , ) parser . add_argument ( '-design_file' , type = Path , help = 'The design file to process' , ) parser . add_argument ( '-m' , '--metadata' , default = None , help = \"Metadata to include with the operation, becomes part of metadata.json in the result.\" , ) parser . add_argument ( '-c' , '--command' , choices = [ 'info' , 'process' ], default = 'info' , help = \"Which command to perform: 'info' = gen info files, 'process' = process design.\" , ) parser . add_argument ( '-w' , '--watch' , choices = [ 'best' , 'backend' , 'polling' ], default = 'best' , help = \"How to wait for results, via backend, polling, or best available.\" , ) parser . add_argument ( '-t' , '--timeout' , type = int , default = 600 , help = \"Timeout, in seconds, before giving up on the command.\" , ) return parser . parse_args ()","title":"cli"},{"location":"reference/sym_cps/evaluation/cli/#sym_cps.evaluation.cli.get_args","text":"Creates a parser and returns the arguments for this utility. Source code in sym_cps/evaluation/cli.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def get_args (): \"\"\" Creates a parser and returns the arguments for this utility. \"\"\" parser = argparse . ArgumentParser ( description = 'Process a design' ) parser . add_argument ( '-results_dir' , type = Path , help = 'The directory that will be checked when looking for new results.' , ) parser . add_argument ( '-design_file' , type = Path , help = 'The design file to process' , ) parser . add_argument ( '-m' , '--metadata' , default = None , help = \"Metadata to include with the operation, becomes part of metadata.json in the result.\" , ) parser . add_argument ( '-c' , '--command' , choices = [ 'info' , 'process' ], default = 'info' , help = \"Which command to perform: 'info' = gen info files, 'process' = process design.\" , ) parser . add_argument ( '-w' , '--watch' , choices = [ 'best' , 'backend' , 'polling' ], default = 'best' , help = \"How to wait for results, via backend, polling, or best available.\" , ) parser . add_argument ( '-t' , '--timeout' , type = int , default = 600 , help = \"Timeout, in seconds, before giving up on the command.\" , ) return parser . parse_args ()","title":"get_args()"},{"location":"reference/sym_cps/evaluation/tools/","text":"File adapted from: https://github.com/LOGiCS-Project/swri-simple-uam-example get_result_archive_path ( result , results_dir ) \u00b6 Get the name of the specific result archive from the backend produced result. Parameters: Name Type Description Default result object The result object returned by wait_on_result required results_dir Path The directory in which all the results will appear. required Source code in sym_cps/evaluation/tools.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def get_result_archive_path ( result : object , results_dir : Path ) -> Path : \"\"\" Get the name of the specific result archive from the backend produced result. Arguments: result: The result object returned by `wait_on_result` results_dir: The directory in which all the results will appear. \"\"\" raw_path = Path ( result [ 'result_archive' ]) return results_dir / raw_path . name get_zip_metadata ( zip_file ) \u00b6 Returns the contents of the zip's metadata.json, if it has one. Parameters: Name Type Description Default zip_file Path The part to the zip we're opening. required Source code in sym_cps/evaluation/tools.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def get_zip_metadata ( zip_file : Path ) -> Optional [ object ]: \"\"\" Returns the contents of the zip's metadata.json, if it has one. Arguments: zip_file: The part to the zip we're opening. \"\"\" # Open Zip file with zipfile . ZipFile ( zip_file ) as zip : meta_file = zipfile . Path ( zip ) / 'metadata.json' # Check if `metadata.json` exists if not meta_file . exists () and meta_file . is_file (): print ( f \"Zip ' { str ( zip_file ) } ' has no metadata.json\" ) return None # If yes, decode its contents with meta_file . open ( 'r' ) as meta : return json . load ( meta ) load_design ( design_file ) \u00b6 Loads a design from file. Parameters: Name Type Description Default design_file Path Path to the design file required Source code in sym_cps/evaluation/tools.py 17 18 19 20 21 22 23 24 25 def load_design ( design_file : Path ) -> object : \"\"\" Loads a design from file. Arguments: design_file: Path to the design file \"\"\" with Path ( design_file ) . open ( 'r' ) as fp : return json . load ( fp ) load_metadata ( metadata_file ) \u00b6 Loads metadata from file. This can be any arbitrary dictionary and its contents will appear in the result archive's metadata.json. Useful for keeping track of where each call comes from in a larger optimization process. Parameters: Name Type Description Default metadata_file Union [ Path , str , None] Path to the metadata file required Source code in sym_cps/evaluation/tools.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def load_metadata ( metadata_file : Union [ Path , str , None ]) -> dict : \"\"\" Loads metadata from file. This can be any arbitrary dictionary and its contents will appear in the result archive's metadata.json. Useful for keeping track of where each call comes from in a larger optimization process. Arguments: metadata_file: Path to the metadata file \"\"\" if not metadata_file : return dict () if isinstance ( metadata_file , dict ): return metadata_file with Path ( metadata_file ) . open ( 'r' ) as fp : meta = json . load ( fp ) if not isinstance ( meta , dict ): raise RuntimeError ( \"Metadata must be JSON serializable dictionary.\" ) return meta match_msg_to_zip ( msg , zip_file ) \u00b6 Checks whether the given message produced the given zip archive. Parameters: Name Type Description Default msg dramatiq . Message The dramatiq message we're checking against required zip_file Path The path to the zip we're verifying required Source code in sym_cps/evaluation/tools.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 def match_msg_to_zip ( msg : dramatiq . Message , zip_file : Path ) -> bool : \"\"\" Checks whether the given message produced the given zip archive. Arguments: msg: The dramatiq message we're checking against zip_file: The path to the zip we're verifying \"\"\" msg_id = msg . message_id metadata = get_zip_metadata ( zip_file ) return metadata and ( 'message_info' in metadata ) and msg_id == metadata [ 'message_info' ][ 'message_id' ] wait_on_result ( msg , interval = 10 , timeout = 600 ) \u00b6 Uses the dramatiq backend mechanism to wait on a result from a worker. EXAMPLE ONLY: DO NOT USE IN PRODUCTION Parameters: Name Type Description Default msg dramatiq . Message The message from the dramatiq send call. required interval int The time, in seconds, to wait between each check of the backend. 10 timeout int The total time, in seconds, to wait for a result before giving up. 600 Source code in sym_cps/evaluation/tools.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def wait_on_result ( msg : dramatiq . Message , interval : int = 10 , timeout : int = 600 ) -> object : \"\"\" Uses the dramatiq backend mechanism to wait on a result from a worker. EXAMPLE ONLY: DO NOT USE IN PRODUCTION Arguments: msg: The message from the dramatiq send call. interval: The time, in seconds, to wait between each check of the backend. timeout: The total time, in seconds, to wait for a result before giving up. \"\"\" elapsed = 0 result = None # Loop until result found while not result : # Try to get Result try : print ( f \"Checking for result @ { elapsed } s\" ) result = msg . get_result ( block = False ) # If no result yet except dramatiq . results . ResultMissing as err : # Check if we're timed out if elapsed >= timeout : raise RuntimeError ( f \"No result found by { elapsed } s\" ) # Else wait another interval elapsed += interval time . sleep ( interval ) return result watch_results_dir ( msg , results_dir , interval = 10 , timeout = 600 ) \u00b6 Checks directory every interval to see if any of the zip files match the provided message. EXAMPLE ONLY: DO NOT USE IN PRODUCTION Parameters: Name Type Description Default msg dramatiq . Message The message we sent to the broker required results_dir Path dir to look for results archive in required interval int delay between each check of the results_dir 10 timeout int time to search for archive before giving up 600 Source code in sym_cps/evaluation/tools.py 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 def watch_results_dir ( msg : dramatiq . Message , results_dir : Path , interval : int = 10 , timeout : int = 600 ) -> Path : \"\"\" Checks directory every interval to see if any of the zip files match the provided message. EXAMPLE ONLY: DO NOT USE IN PRODUCTION Arguments: msg: The message we sent to the broker results_dir: dir to look for results archive in interval: delay between each check of the results_dir timeout: time to search for archive before giving up \"\"\" elapsed = 0 seen = dict () # Wait till we're out of time or have a result while elapsed <= timeout : print ( f \"Checking for result @ { elapsed } s\" ) for zip_file in results_dir . iterdir (): # Check if file is a valid zip valid_zip = zip_file . is_file () valid_zip = valid_zip and '.zip' == zip_file . suffix valid_zip = valid_zip and zip_file not in seen # Skip further checks if not zip if not valid_zip : continue # return file if match found, else mark as seen. print ( f \"Checking zip file: { str ( zip_file ) } \" ) if match_msg_to_zip ( msg , zip_file ): return zip_file else : seen [ zip_file ] = True # Using seen as set # Wait for next interval elapsed += interval time . sleep ( interval ) raise RuntimeError ( f \"No result found by { elapsed } s\" )","title":"tools"},{"location":"reference/sym_cps/evaluation/tools/#sym_cps.evaluation.tools.get_result_archive_path","text":"Get the name of the specific result archive from the backend produced result. Parameters: Name Type Description Default result object The result object returned by wait_on_result required results_dir Path The directory in which all the results will appear. required Source code in sym_cps/evaluation/tools.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def get_result_archive_path ( result : object , results_dir : Path ) -> Path : \"\"\" Get the name of the specific result archive from the backend produced result. Arguments: result: The result object returned by `wait_on_result` results_dir: The directory in which all the results will appear. \"\"\" raw_path = Path ( result [ 'result_archive' ]) return results_dir / raw_path . name","title":"get_result_archive_path()"},{"location":"reference/sym_cps/evaluation/tools/#sym_cps.evaluation.tools.get_zip_metadata","text":"Returns the contents of the zip's metadata.json, if it has one. Parameters: Name Type Description Default zip_file Path The part to the zip we're opening. required Source code in sym_cps/evaluation/tools.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def get_zip_metadata ( zip_file : Path ) -> Optional [ object ]: \"\"\" Returns the contents of the zip's metadata.json, if it has one. Arguments: zip_file: The part to the zip we're opening. \"\"\" # Open Zip file with zipfile . ZipFile ( zip_file ) as zip : meta_file = zipfile . Path ( zip ) / 'metadata.json' # Check if `metadata.json` exists if not meta_file . exists () and meta_file . is_file (): print ( f \"Zip ' { str ( zip_file ) } ' has no metadata.json\" ) return None # If yes, decode its contents with meta_file . open ( 'r' ) as meta : return json . load ( meta )","title":"get_zip_metadata()"},{"location":"reference/sym_cps/evaluation/tools/#sym_cps.evaluation.tools.load_design","text":"Loads a design from file. Parameters: Name Type Description Default design_file Path Path to the design file required Source code in sym_cps/evaluation/tools.py 17 18 19 20 21 22 23 24 25 def load_design ( design_file : Path ) -> object : \"\"\" Loads a design from file. Arguments: design_file: Path to the design file \"\"\" with Path ( design_file ) . open ( 'r' ) as fp : return json . load ( fp )","title":"load_design()"},{"location":"reference/sym_cps/evaluation/tools/#sym_cps.evaluation.tools.load_metadata","text":"Loads metadata from file. This can be any arbitrary dictionary and its contents will appear in the result archive's metadata.json. Useful for keeping track of where each call comes from in a larger optimization process. Parameters: Name Type Description Default metadata_file Union [ Path , str , None] Path to the metadata file required Source code in sym_cps/evaluation/tools.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def load_metadata ( metadata_file : Union [ Path , str , None ]) -> dict : \"\"\" Loads metadata from file. This can be any arbitrary dictionary and its contents will appear in the result archive's metadata.json. Useful for keeping track of where each call comes from in a larger optimization process. Arguments: metadata_file: Path to the metadata file \"\"\" if not metadata_file : return dict () if isinstance ( metadata_file , dict ): return metadata_file with Path ( metadata_file ) . open ( 'r' ) as fp : meta = json . load ( fp ) if not isinstance ( meta , dict ): raise RuntimeError ( \"Metadata must be JSON serializable dictionary.\" ) return meta","title":"load_metadata()"},{"location":"reference/sym_cps/evaluation/tools/#sym_cps.evaluation.tools.match_msg_to_zip","text":"Checks whether the given message produced the given zip archive. Parameters: Name Type Description Default msg dramatiq . Message The dramatiq message we're checking against required zip_file Path The path to the zip we're verifying required Source code in sym_cps/evaluation/tools.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 def match_msg_to_zip ( msg : dramatiq . Message , zip_file : Path ) -> bool : \"\"\" Checks whether the given message produced the given zip archive. Arguments: msg: The dramatiq message we're checking against zip_file: The path to the zip we're verifying \"\"\" msg_id = msg . message_id metadata = get_zip_metadata ( zip_file ) return metadata and ( 'message_info' in metadata ) and msg_id == metadata [ 'message_info' ][ 'message_id' ]","title":"match_msg_to_zip()"},{"location":"reference/sym_cps/evaluation/tools/#sym_cps.evaluation.tools.wait_on_result","text":"Uses the dramatiq backend mechanism to wait on a result from a worker. EXAMPLE ONLY: DO NOT USE IN PRODUCTION Parameters: Name Type Description Default msg dramatiq . Message The message from the dramatiq send call. required interval int The time, in seconds, to wait between each check of the backend. 10 timeout int The total time, in seconds, to wait for a result before giving up. 600 Source code in sym_cps/evaluation/tools.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def wait_on_result ( msg : dramatiq . Message , interval : int = 10 , timeout : int = 600 ) -> object : \"\"\" Uses the dramatiq backend mechanism to wait on a result from a worker. EXAMPLE ONLY: DO NOT USE IN PRODUCTION Arguments: msg: The message from the dramatiq send call. interval: The time, in seconds, to wait between each check of the backend. timeout: The total time, in seconds, to wait for a result before giving up. \"\"\" elapsed = 0 result = None # Loop until result found while not result : # Try to get Result try : print ( f \"Checking for result @ { elapsed } s\" ) result = msg . get_result ( block = False ) # If no result yet except dramatiq . results . ResultMissing as err : # Check if we're timed out if elapsed >= timeout : raise RuntimeError ( f \"No result found by { elapsed } s\" ) # Else wait another interval elapsed += interval time . sleep ( interval ) return result","title":"wait_on_result()"},{"location":"reference/sym_cps/evaluation/tools/#sym_cps.evaluation.tools.watch_results_dir","text":"Checks directory every interval to see if any of the zip files match the provided message. EXAMPLE ONLY: DO NOT USE IN PRODUCTION Parameters: Name Type Description Default msg dramatiq . Message The message we sent to the broker required results_dir Path dir to look for results archive in required interval int delay between each check of the results_dir 10 timeout int time to search for archive before giving up 600 Source code in sym_cps/evaluation/tools.py 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 def watch_results_dir ( msg : dramatiq . Message , results_dir : Path , interval : int = 10 , timeout : int = 600 ) -> Path : \"\"\" Checks directory every interval to see if any of the zip files match the provided message. EXAMPLE ONLY: DO NOT USE IN PRODUCTION Arguments: msg: The message we sent to the broker results_dir: dir to look for results archive in interval: delay between each check of the results_dir timeout: time to search for archive before giving up \"\"\" elapsed = 0 seen = dict () # Wait till we're out of time or have a result while elapsed <= timeout : print ( f \"Checking for result @ { elapsed } s\" ) for zip_file in results_dir . iterdir (): # Check if file is a valid zip valid_zip = zip_file . is_file () valid_zip = valid_zip and '.zip' == zip_file . suffix valid_zip = valid_zip and zip_file not in seen # Skip further checks if not zip if not valid_zip : continue # return file if match found, else mark as seen. print ( f \"Checking zip file: { str ( zip_file ) } \" ) if match_msg_to_zip ( msg , zip_file ): return zip_file else : seen [ zip_file ] = True # Using seen as set # Wait for next interval elapsed += interval time . sleep ( interval ) raise RuntimeError ( f \"No result found by { elapsed } s\" )","title":"watch_results_dir()"},{"location":"reference/sym_cps/examples/","text":"","title":"examples"},{"location":"reference/sym_cps/examples/design_swri/","text":"Generate design swri files for all designs in the library","title":"design_swri"},{"location":"reference/sym_cps/examples/designs/","text":"export_design_json ( design_name = 'Trowel' , designs_dat_file = 'designs.dat' ) \u00b6 Produce the json file representing the design Source code in sym_cps/examples/designs.py 12 13 14 15 16 17 18 19 20 21 22 23 def export_design_json ( design_name : str = \"Trowel\" , designs_dat_file : str = \"designs.dat\" ): \"\"\"Produce the json file representing the design\"\"\" designs : dict [ str , tuple [ DConcrete , DTopology ]] = load ( designs_dat_file ) # type: ignore d_concrete = designs [ design_name ][ 0 ] save_to_file ( str ( json . dumps ( d_concrete . to_design_swri )), file_name = f \"design_swri.json\" , absolute_folder_path = designs_folder / d_concrete . name , ) print ( f \" { design_name } exported to json\" ) load_design_json ( design_name = 'Trowel' , library_dat_file = 'library.dat' ) \u00b6 Load a design from json format Source code in sym_cps/examples/designs.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def load_design_json ( design_name : str = \"Trowel\" , library_dat_file : str = \"library.dat\" ): \"\"\"Load a design from json format\"\"\" \"\"\"BUG: FIXME: Does not work with new designs, e.g. NewAxe\"\"\" c_library : Library = load ( library_dat_file ) # type: ignore design_swri_path = designs_folder / design_name / \"design_swri.json\" d_concrete : DConcrete = parse_design_from_design_swri ( path = design_swri_path , library = c_library ) d_topology : DTopology = DTopology . from_concrete ( d_concrete ) print ( d_concrete ) print ( d_topology ) print ( f \" { design_name } imported from json\" )","title":"designs"},{"location":"reference/sym_cps/examples/designs/#sym_cps.examples.designs.export_design_json","text":"Produce the json file representing the design Source code in sym_cps/examples/designs.py 12 13 14 15 16 17 18 19 20 21 22 23 def export_design_json ( design_name : str = \"Trowel\" , designs_dat_file : str = \"designs.dat\" ): \"\"\"Produce the json file representing the design\"\"\" designs : dict [ str , tuple [ DConcrete , DTopology ]] = load ( designs_dat_file ) # type: ignore d_concrete = designs [ design_name ][ 0 ] save_to_file ( str ( json . dumps ( d_concrete . to_design_swri )), file_name = f \"design_swri.json\" , absolute_folder_path = designs_folder / d_concrete . name , ) print ( f \" { design_name } exported to json\" )","title":"export_design_json()"},{"location":"reference/sym_cps/examples/designs/#sym_cps.examples.designs.load_design_json","text":"Load a design from json format Source code in sym_cps/examples/designs.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def load_design_json ( design_name : str = \"Trowel\" , library_dat_file : str = \"library.dat\" ): \"\"\"Load a design from json format\"\"\" \"\"\"BUG: FIXME: Does not work with new designs, e.g. NewAxe\"\"\" c_library : Library = load ( library_dat_file ) # type: ignore design_swri_path = designs_folder / design_name / \"design_swri.json\" d_concrete : DConcrete = parse_design_from_design_swri ( path = design_swri_path , library = c_library ) d_topology : DTopology = DTopology . from_concrete ( d_concrete ) print ( d_concrete ) print ( d_topology ) print ( f \" { design_name } imported from json\" )","title":"load_design_json()"},{"location":"reference/sym_cps/examples/evaluation/","text":"","title":"evaluation"},{"location":"reference/sym_cps/examples/library/","text":"export_library ( library_txt_file = 'library.txt' , library_dat_file = 'library.dat' , designs_dat_file = 'designs.dat' ) \u00b6 Export library and seed designs to text files Source code in sym_cps/examples/library.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def export_library ( library_txt_file : str = \"library.txt\" , library_dat_file : str = \"library.dat\" , designs_dat_file : str = \"designs.dat\" ): \"\"\"Export library and seed designs to text files\"\"\" c_library : Library = load ( library_dat_file ) # type: ignore save_to_file ( str ( c_library ), file_name = library_txt_file , absolute_folder_path = library_folder ) \"\"\"In the following we can see some of the 'temporary objects' that have been build while building the components and designs libraries. We will save them to a text file in the output folder\"\"\" # Maps component type to all the LibraryComponent objects belonging to the type save_to_file ( repr_dictionary ( c_library . components_in_type ), \"all_components_in_type.txt\" , folder_name = \"library\" ) # Maps each component type to a set of components type which it can be connected to\"\"\" connectable_components_types : dict [ CType , set [ CType ]] = {} for ctype in c_library . component_types . values (): connectable_components_types [ ctype ] = set ( ctype . compatible_with . values ()) save_to_file ( repr_dictionary ( connectable_components_types ), \"connectable_components_types.txt\" , folder_name = \"library\" ) # Maps connector_id to its LibraryConnector object\"\"\" save_to_file ( repr_dictionary ( c_library . connectors ), \"all_connectors.txt\" , folder_name = \"library\" ) # Maps connector to a set of 'compatible' connectors it can be connected to\"\"\" connectable_connectors : dict [ CConnector , set [ CConnector ]] = {} for connector in c_library . connectors . values (): connectable_connectors [ connector ] = set ( connector . compatible_with . values ()) save_to_file ( repr_dictionary ( connectable_connectors ), \"connectable_connectors.txt\" , folder_name = \"library\" ) # all_parameters_upper_bounds: dict[str, float] = {} # Maps parameter_id to its upper bounds\"\"\" save_to_file ( repr_dictionary ( all_parameters_upper_bounds ), \"all_parameters_upper_bounds.txt\" , folder_name = \"library\" ) # all_parameters_lower_bounds: dict[str, float] = {} # Maps parameter_id to its lower bounds\"\"\" save_to_file ( repr_dictionary ( all_parameters_lower_bounds ), \"all_parameters_lower_bounds.txt\" , folder_name = \"library\" ) # all_parameters: dict[str, CParameterType] = {} # Maps parameter_id to CParameterType object\"\"\" save_to_file ( repr_dictionary ( c_library . parameters ), \"all_parameters.txt\" , folder_name = \"library\" ) # Maps parameter_id to a set of component types it belongs to\"\"\" parameter_to_components_types : dict [ str , set [ str ]] = {} for para_id , parameter in c_library . parameters . items (): if para_id not in parameter_to_components_types . keys (): parameter_to_components_types [ para_id ] = set () parameter_to_components_types [ para_id ] . add ( parameter . belongs_to ) save_to_file ( repr_dictionary ( parameter_to_components_types ), \"parameter_to_components_types.txt\" , folder_name = \"library\" ) designs : dict [ str , tuple [ DConcrete , DTopology ]] = load ( designs_dat_file ) # type: ignore for d_concrete , d_topology in designs . values (): save_to_file ( str ( d_concrete ), file_name = f \"DConcrete\" , absolute_folder_path = designs_folder / d_concrete . name , ) save_to_file ( str ( d_topology ), file_name = f \"DTopology\" , absolute_folder_path = designs_folder / d_concrete . name , ) parse_library ( library_dat_file = 'library.dat' , designs_dat_file = 'designs.dat' ) \u00b6 Loads library of components and seed designs and store them Source code in sym_cps/examples/library.py 14 15 16 17 18 19 def parse_library ( library_dat_file : str = \"library.dat\" , designs_dat_file : str = \"designs.dat\" ): \"\"\"Loads library of components and seed designs and store them\"\"\" c_library , designs = parse_library_and_seed_designs () dump ( c_library , library_dat_file ) dump ( designs , designs_dat_file )","title":"library"},{"location":"reference/sym_cps/examples/library/#sym_cps.examples.library.export_library","text":"Export library and seed designs to text files Source code in sym_cps/examples/library.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def export_library ( library_txt_file : str = \"library.txt\" , library_dat_file : str = \"library.dat\" , designs_dat_file : str = \"designs.dat\" ): \"\"\"Export library and seed designs to text files\"\"\" c_library : Library = load ( library_dat_file ) # type: ignore save_to_file ( str ( c_library ), file_name = library_txt_file , absolute_folder_path = library_folder ) \"\"\"In the following we can see some of the 'temporary objects' that have been build while building the components and designs libraries. We will save them to a text file in the output folder\"\"\" # Maps component type to all the LibraryComponent objects belonging to the type save_to_file ( repr_dictionary ( c_library . components_in_type ), \"all_components_in_type.txt\" , folder_name = \"library\" ) # Maps each component type to a set of components type which it can be connected to\"\"\" connectable_components_types : dict [ CType , set [ CType ]] = {} for ctype in c_library . component_types . values (): connectable_components_types [ ctype ] = set ( ctype . compatible_with . values ()) save_to_file ( repr_dictionary ( connectable_components_types ), \"connectable_components_types.txt\" , folder_name = \"library\" ) # Maps connector_id to its LibraryConnector object\"\"\" save_to_file ( repr_dictionary ( c_library . connectors ), \"all_connectors.txt\" , folder_name = \"library\" ) # Maps connector to a set of 'compatible' connectors it can be connected to\"\"\" connectable_connectors : dict [ CConnector , set [ CConnector ]] = {} for connector in c_library . connectors . values (): connectable_connectors [ connector ] = set ( connector . compatible_with . values ()) save_to_file ( repr_dictionary ( connectable_connectors ), \"connectable_connectors.txt\" , folder_name = \"library\" ) # all_parameters_upper_bounds: dict[str, float] = {} # Maps parameter_id to its upper bounds\"\"\" save_to_file ( repr_dictionary ( all_parameters_upper_bounds ), \"all_parameters_upper_bounds.txt\" , folder_name = \"library\" ) # all_parameters_lower_bounds: dict[str, float] = {} # Maps parameter_id to its lower bounds\"\"\" save_to_file ( repr_dictionary ( all_parameters_lower_bounds ), \"all_parameters_lower_bounds.txt\" , folder_name = \"library\" ) # all_parameters: dict[str, CParameterType] = {} # Maps parameter_id to CParameterType object\"\"\" save_to_file ( repr_dictionary ( c_library . parameters ), \"all_parameters.txt\" , folder_name = \"library\" ) # Maps parameter_id to a set of component types it belongs to\"\"\" parameter_to_components_types : dict [ str , set [ str ]] = {} for para_id , parameter in c_library . parameters . items (): if para_id not in parameter_to_components_types . keys (): parameter_to_components_types [ para_id ] = set () parameter_to_components_types [ para_id ] . add ( parameter . belongs_to ) save_to_file ( repr_dictionary ( parameter_to_components_types ), \"parameter_to_components_types.txt\" , folder_name = \"library\" ) designs : dict [ str , tuple [ DConcrete , DTopology ]] = load ( designs_dat_file ) # type: ignore for d_concrete , d_topology in designs . values (): save_to_file ( str ( d_concrete ), file_name = f \"DConcrete\" , absolute_folder_path = designs_folder / d_concrete . name , ) save_to_file ( str ( d_topology ), file_name = f \"DTopology\" , absolute_folder_path = designs_folder / d_concrete . name , )","title":"export_library()"},{"location":"reference/sym_cps/examples/library/#sym_cps.examples.library.parse_library","text":"Loads library of components and seed designs and store them Source code in sym_cps/examples/library.py 14 15 16 17 18 19 def parse_library ( library_dat_file : str = \"library.dat\" , designs_dat_file : str = \"designs.dat\" ): \"\"\"Loads library of components and seed designs and store them\"\"\" c_library , designs = parse_library_and_seed_designs () dump ( c_library , library_dat_file ) dump ( designs , designs_dat_file )","title":"parse_library()"},{"location":"reference/sym_cps/examples/topology/","text":"random_topology ( design_name = 'Trowel' , designs_dat_file = 'designs.dat' ) \u00b6 Generate Topology DTopology, random strategy Source code in sym_cps/examples/topology.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def random_topology ( design_name : str = \"Trowel\" , designs_dat_file : str = \"designs.dat\" ): \"\"\"Generate Topology DTopology, random strategy\"\"\" d_topology : DTopology = topo_opt . generate_topology ( name = \"RandomDesign\" , strategy = TopologyStrategy . random_strategy ) print ( \"****D_TOPOLOGY****\" ) print ( d_topology ) d_topology . export ( ExportType . TXT ) d_topology . export ( ExportType . DOT ) \"\"\"Refine DTopology to DConcrete, random strategy\"\"\" d_concrete : DConcrete = concr_opt . concretize_topology ( d_topology = d_topology , strategy = ConcreteStrategy . random_strategy ) print ( \" \\n ****D_CONCRETE****\" ) print ( d_concrete ) d_concrete . export ( ExportType . TXT ) d_concrete . export ( ExportType . DOT ) d_concrete . export ( ExportType . JSON ) d_concrete . export ( ExportType . PDF )","title":"topology"},{"location":"reference/sym_cps/examples/topology/#sym_cps.examples.topology.random_topology","text":"Generate Topology DTopology, random strategy Source code in sym_cps/examples/topology.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def random_topology ( design_name : str = \"Trowel\" , designs_dat_file : str = \"designs.dat\" ): \"\"\"Generate Topology DTopology, random strategy\"\"\" d_topology : DTopology = topo_opt . generate_topology ( name = \"RandomDesign\" , strategy = TopologyStrategy . random_strategy ) print ( \"****D_TOPOLOGY****\" ) print ( d_topology ) d_topology . export ( ExportType . TXT ) d_topology . export ( ExportType . DOT ) \"\"\"Refine DTopology to DConcrete, random strategy\"\"\" d_concrete : DConcrete = concr_opt . concretize_topology ( d_topology = d_topology , strategy = ConcreteStrategy . random_strategy ) print ( \" \\n ****D_CONCRETE****\" ) print ( d_concrete ) d_concrete . export ( ExportType . TXT ) d_concrete . export ( ExportType . DOT ) d_concrete . export ( ExportType . JSON ) d_concrete . export ( ExportType . PDF )","title":"random_topology()"},{"location":"reference/sym_cps/grammar/","text":"","title":"grammar"},{"location":"reference/sym_cps/hci/","text":"","title":"hci"},{"location":"reference/sym_cps/optimizers/","text":"","title":"optimizers"},{"location":"reference/sym_cps/optimizers/concrete_opt/","text":"Test ConcreteStrategy \u00b6 Bases: Enum Test Class Source code in sym_cps/optimizers/concrete_opt/__init__.py 16 17 18 19 20 class ConcreteStrategy ( Enum ): \"\"\" Test Class \"\"\" random_strategy = auto ()","title":"concrete_opt"},{"location":"reference/sym_cps/optimizers/concrete_opt/#sym_cps.optimizers.concrete_opt.ConcreteStrategy","text":"Bases: Enum Test Class Source code in sym_cps/optimizers/concrete_opt/__init__.py 16 17 18 19 20 class ConcreteStrategy ( Enum ): \"\"\" Test Class \"\"\" random_strategy = auto ()","title":"ConcreteStrategy"},{"location":"reference/sym_cps/optimizers/params_opt/","text":"","title":"params_opt"},{"location":"reference/sym_cps/optimizers/params_opt/optimizer/","text":"ParametersOptimizer \u00b6 Bases: Optimizer Source code in sym_cps/optimizers/params_opt/optimizer.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class ParametersOptimizer ( Optimizer ): def _vectorize ( self , d_concrete : DConcrete , strategy : ParametersStrategy , constraints : ParametersConstraint ) -> tuple [ list [ Parameter | DesignParameter ], list [ float ]]: \"\"\" Create twos array to help vectorize the parameters and facilitate mapping back the values to the design The first element in the tuple is the list of parameter object that can be set by calling .value The second element in the tuple is the array of the parameter values for optimization \"\"\" if strategy == ParametersStrategy . bayesian_strategy : # create vector for optimization if constraints == ParametersConstraint . design_parameter : params = list ( d_concrete . design_parameters . values ()) param_val_array = [ param . value for param in params ] elif constraints == ParametersConstraint . component_parameter : params = [] for component in d_concrete . components : params . extend ( component . parameters . values ()) param_val_array = [ param . value for param in params ] #debug # for param, val in zip(params, param_val_array): # print(param.id, val) return params , param_val_array def _get_bounds ( self , d_params : list [ DesignParameter ] ) -> list [ tuple [ float , float ]]: bounds = [] for d_param in d_params : min_val = None max_val = None for param in d_param . parameters : try : if min_val is None : min_val = param . min if max_val is None : max_val = param . max if min_val > param . min : min_val = param . min if max_val < param . max : max_val = param . max except : # not specified value in corpus min_val = - 10000 max_val = 10000 bounds . append (( min_val , max_val )) return bounds def optimize ( self , d_concrete : DConcrete , strategy : ParametersStrategy , constraints : ParametersConstraint ) -> DConcrete : problem = ParameterOptimizationProblem ( d_concrete = d_concrete , strategy = strategy , constraint = constraints ) #debug for param , val in zip ( problem . _params , problem . _init_params_val_array ): print ( param . id , val ) print ( problem . _bounds ) if strategy == ParametersStrategy . bayesian_strategy : print ( \"Optimizing Parameters using Bayesian Optimization!\" ) optimizer = BayesianOptimizer ( problem )","title":"optimizer"},{"location":"reference/sym_cps/optimizers/params_opt/optimizer/#sym_cps.optimizers.params_opt.optimizer.ParametersOptimizer","text":"Bases: Optimizer Source code in sym_cps/optimizers/params_opt/optimizer.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class ParametersOptimizer ( Optimizer ): def _vectorize ( self , d_concrete : DConcrete , strategy : ParametersStrategy , constraints : ParametersConstraint ) -> tuple [ list [ Parameter | DesignParameter ], list [ float ]]: \"\"\" Create twos array to help vectorize the parameters and facilitate mapping back the values to the design The first element in the tuple is the list of parameter object that can be set by calling .value The second element in the tuple is the array of the parameter values for optimization \"\"\" if strategy == ParametersStrategy . bayesian_strategy : # create vector for optimization if constraints == ParametersConstraint . design_parameter : params = list ( d_concrete . design_parameters . values ()) param_val_array = [ param . value for param in params ] elif constraints == ParametersConstraint . component_parameter : params = [] for component in d_concrete . components : params . extend ( component . parameters . values ()) param_val_array = [ param . value for param in params ] #debug # for param, val in zip(params, param_val_array): # print(param.id, val) return params , param_val_array def _get_bounds ( self , d_params : list [ DesignParameter ] ) -> list [ tuple [ float , float ]]: bounds = [] for d_param in d_params : min_val = None max_val = None for param in d_param . parameters : try : if min_val is None : min_val = param . min if max_val is None : max_val = param . max if min_val > param . min : min_val = param . min if max_val < param . max : max_val = param . max except : # not specified value in corpus min_val = - 10000 max_val = 10000 bounds . append (( min_val , max_val )) return bounds def optimize ( self , d_concrete : DConcrete , strategy : ParametersStrategy , constraints : ParametersConstraint ) -> DConcrete : problem = ParameterOptimizationProblem ( d_concrete = d_concrete , strategy = strategy , constraint = constraints ) #debug for param , val in zip ( problem . _params , problem . _init_params_val_array ): print ( param . id , val ) print ( problem . _bounds ) if strategy == ParametersStrategy . bayesian_strategy : print ( \"Optimizing Parameters using Bayesian Optimization!\" ) optimizer = BayesianOptimizer ( problem )","title":"ParametersOptimizer"},{"location":"reference/sym_cps/optimizers/params_opt/param_opt_problem/","text":"ParameterOptimizationProblem \u00b6 Bases: ProblemBase Defines the optimization problem for parameter optimization All parameter optimization strategy receives the problem as input. Source code in sym_cps/optimizers/params_opt/param_opt_problem.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 class ParameterOptimizationProblem ( ProblemBase ): \"\"\"Defines the optimization problem for parameter optimization All parameter optimization strategy receives the problem as input. \"\"\" def __init__ ( self , d_concrete : DConcrete , strategy : ParametersStrategy , constraint : ParametersConstraint ): super () . __init__ () self . _d_concrete = d_concrete self . _strategyType = strategy self . _constraintType = constraint self . _bounds = None self . _params = None self . _init_params = None # get bounds, parameters self . _params , self . _init_params_val_array = self . _vectorize_d_concrete ( d_concrete = self . _d_concrete ) # set the attribute from the ProblemBase self . _bounds = self . _get_bounds ( self . _params ) self . _opt_array = np . array ( self . _init_params_val_array ) self . set_obj_dim ( 4 ) # 4 objective : four tests supported self . set_con_dim ( 1 ) # 1 constraint: the design is valid (can have FDM output) or not def set_parameters ( self , parameters : npt . ArrayLike ) -> None : \"\"\"Set the d concrete using the param_val as the value for each design parameter\"\"\" if len ( self . _params ) != parameters . shape [ 0 ]: print ( f \"Mismatched parameter size: { len ( self . _params ) } and { parameters . shape } \" ) raise Exception () for param , val in zip ( self . _params , parameters ): param . value = val def evaluate ( self , parameters : npt . ArrayLike ): # set the parameters self . set_parameters ( parameters ) # export to design_swri self . _d_concrete . export ( ExportType . JSON ) # call the pipeline for evaluation design_json_path = designs_folder / self . _d_concrete . name / \"design_swri.json\" #TODO: Return obj_vals and con_vals ret = evaluate_design ( design_json_path = design_json_path , metadata = { \"extra_info\" : \"full evaluation example\" }, timeout = 800 ) return ret def obj_dominate ( self , obj1 : npt . ArrayLike , obj2 : npt . ArrayLike ): \"\"\"Compare multi-objective\"\"\" return obj1 [ 0 ] > obj2 [ 0 ] def _vectorize_d_concrete ( self , d_concrete : DConcrete ) -> tuple [ list [ Parameter | DesignParameter ], list [ float ]]: \"\"\" Create two arrays to help vectorize the parameters and facilitate mapping back the values to the design The first element in the tuple is the list of parameter object that can be set by calling .value The second element in the tuple is the array of the parameter values for optimization \"\"\" # create vector for optimization if self . _constraintType == ParametersConstraint . design_parameter : params = list ( d_concrete . design_parameters . values ()) param_val_array = [ param . value for param in params ] elif self . _constraintType == ParametersConstraint . component_parameter : params = [] for component in d_concrete . components : params . extend ( component . parameters . values ()) param_val_array = [ param . value for param in params ] #debug # for param, val in zip(params, param_val_array): # print(param.id, val) return params , param_val_array def _get_bounds ( self , d_params : list [ DesignParameter ]) -> list [ tuple [ float , float ]]: bounds = [] for d_param in d_params : min_val = None max_val = None for param in d_param . parameters : try : if min_val is None : min_val = param . min if max_val is None : max_val = param . max if min_val > param . min : min_val = param . min if max_val < param . max : max_val = param . max except : # not specified value in corpus min_val = - 10000 max_val = 10000 bounds . append (( min_val , max_val )) return bounds obj_dominate ( obj1 , obj2 ) \u00b6 Compare multi-objective Source code in sym_cps/optimizers/params_opt/param_opt_problem.py 65 66 67 def obj_dominate ( self , obj1 : npt . ArrayLike , obj2 : npt . ArrayLike ): \"\"\"Compare multi-objective\"\"\" return obj1 [ 0 ] > obj2 [ 0 ] set_parameters ( parameters ) \u00b6 Set the d concrete using the param_val as the value for each design parameter Source code in sym_cps/optimizers/params_opt/param_opt_problem.py 43 44 45 46 47 48 49 def set_parameters ( self , parameters : npt . ArrayLike ) -> None : \"\"\"Set the d concrete using the param_val as the value for each design parameter\"\"\" if len ( self . _params ) != parameters . shape [ 0 ]: print ( f \"Mismatched parameter size: { len ( self . _params ) } and { parameters . shape } \" ) raise Exception () for param , val in zip ( self . _params , parameters ): param . value = val","title":"param_opt_problem"},{"location":"reference/sym_cps/optimizers/params_opt/param_opt_problem/#sym_cps.optimizers.params_opt.param_opt_problem.ParameterOptimizationProblem","text":"Bases: ProblemBase Defines the optimization problem for parameter optimization All parameter optimization strategy receives the problem as input. Source code in sym_cps/optimizers/params_opt/param_opt_problem.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 class ParameterOptimizationProblem ( ProblemBase ): \"\"\"Defines the optimization problem for parameter optimization All parameter optimization strategy receives the problem as input. \"\"\" def __init__ ( self , d_concrete : DConcrete , strategy : ParametersStrategy , constraint : ParametersConstraint ): super () . __init__ () self . _d_concrete = d_concrete self . _strategyType = strategy self . _constraintType = constraint self . _bounds = None self . _params = None self . _init_params = None # get bounds, parameters self . _params , self . _init_params_val_array = self . _vectorize_d_concrete ( d_concrete = self . _d_concrete ) # set the attribute from the ProblemBase self . _bounds = self . _get_bounds ( self . _params ) self . _opt_array = np . array ( self . _init_params_val_array ) self . set_obj_dim ( 4 ) # 4 objective : four tests supported self . set_con_dim ( 1 ) # 1 constraint: the design is valid (can have FDM output) or not def set_parameters ( self , parameters : npt . ArrayLike ) -> None : \"\"\"Set the d concrete using the param_val as the value for each design parameter\"\"\" if len ( self . _params ) != parameters . shape [ 0 ]: print ( f \"Mismatched parameter size: { len ( self . _params ) } and { parameters . shape } \" ) raise Exception () for param , val in zip ( self . _params , parameters ): param . value = val def evaluate ( self , parameters : npt . ArrayLike ): # set the parameters self . set_parameters ( parameters ) # export to design_swri self . _d_concrete . export ( ExportType . JSON ) # call the pipeline for evaluation design_json_path = designs_folder / self . _d_concrete . name / \"design_swri.json\" #TODO: Return obj_vals and con_vals ret = evaluate_design ( design_json_path = design_json_path , metadata = { \"extra_info\" : \"full evaluation example\" }, timeout = 800 ) return ret def obj_dominate ( self , obj1 : npt . ArrayLike , obj2 : npt . ArrayLike ): \"\"\"Compare multi-objective\"\"\" return obj1 [ 0 ] > obj2 [ 0 ] def _vectorize_d_concrete ( self , d_concrete : DConcrete ) -> tuple [ list [ Parameter | DesignParameter ], list [ float ]]: \"\"\" Create two arrays to help vectorize the parameters and facilitate mapping back the values to the design The first element in the tuple is the list of parameter object that can be set by calling .value The second element in the tuple is the array of the parameter values for optimization \"\"\" # create vector for optimization if self . _constraintType == ParametersConstraint . design_parameter : params = list ( d_concrete . design_parameters . values ()) param_val_array = [ param . value for param in params ] elif self . _constraintType == ParametersConstraint . component_parameter : params = [] for component in d_concrete . components : params . extend ( component . parameters . values ()) param_val_array = [ param . value for param in params ] #debug # for param, val in zip(params, param_val_array): # print(param.id, val) return params , param_val_array def _get_bounds ( self , d_params : list [ DesignParameter ]) -> list [ tuple [ float , float ]]: bounds = [] for d_param in d_params : min_val = None max_val = None for param in d_param . parameters : try : if min_val is None : min_val = param . min if max_val is None : max_val = param . max if min_val > param . min : min_val = param . min if max_val < param . max : max_val = param . max except : # not specified value in corpus min_val = - 10000 max_val = 10000 bounds . append (( min_val , max_val )) return bounds","title":"ParameterOptimizationProblem"},{"location":"reference/sym_cps/optimizers/params_opt/param_opt_problem/#sym_cps.optimizers.params_opt.param_opt_problem.ParameterOptimizationProblem.obj_dominate","text":"Compare multi-objective Source code in sym_cps/optimizers/params_opt/param_opt_problem.py 65 66 67 def obj_dominate ( self , obj1 : npt . ArrayLike , obj2 : npt . ArrayLike ): \"\"\"Compare multi-objective\"\"\" return obj1 [ 0 ] > obj2 [ 0 ]","title":"obj_dominate()"},{"location":"reference/sym_cps/optimizers/params_opt/param_opt_problem/#sym_cps.optimizers.params_opt.param_opt_problem.ParameterOptimizationProblem.set_parameters","text":"Set the d concrete using the param_val as the value for each design parameter Source code in sym_cps/optimizers/params_opt/param_opt_problem.py 43 44 45 46 47 48 49 def set_parameters ( self , parameters : npt . ArrayLike ) -> None : \"\"\"Set the d concrete using the param_val as the value for each design parameter\"\"\" if len ( self . _params ) != parameters . shape [ 0 ]: print ( f \"Mismatched parameter size: { len ( self . _params ) } and { parameters . shape } \" ) raise Exception () for param , val in zip ( self . _params , parameters ): param . value = val","title":"set_parameters()"},{"location":"reference/sym_cps/optimizers/tools/","text":"Put all auxilliary optimizer here (global, local optimizer) and serves as interface to optimizer module","title":"tools"},{"location":"reference/sym_cps/optimizers/tools/optimization/","text":"","title":"optimization"},{"location":"reference/sym_cps/optimizers/tools/optimization/bayesian_opt_visualizer/","text":"","title":"bayesian_opt_visualizer"},{"location":"reference/sym_cps/optimizers/tools/optimization/bayesian_optimizer/","text":"BayesianOptimizer \u00b6 Bases: OptimizerBase Optimization usign Bayesian Optimization Taking a optimization problem, performs black box optimization which combines a classifier Input: problem: A ProblemBase object Source code in sym_cps/optimizers/tools/optimization/bayesian_optimizer.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 class BayesianOptimizer ( OptimizerBase ): \"\"\"Optimization usign Bayesian Optimization Taking a optimization problem, performs black box optimization which combines a classifier Input: problem: A ProblemBase object \"\"\" def __init__ ( self , problem : ProblemBase , ** kwarg ): super () . __init__ ( problem = problem ) self . _visualizer = BayesianOptimizationVisualizer () self . _kernel = Matern ( nu = 2.5 , length_scale = 0.05 , length_scale_bounds = \"fixed\" ) self . _acq_function = self . expected_improvement self . _surrogate_model_obj : SurrogateInterface = ScikitGPR self . _surrogate_model_con : SurrogateInterface = LogisticClassifier self . _xi : float = 0.0 self . _rng = np . random . RandomState ( 1234 ) self . _iteration : int = 1000 self . _num_warn_up_samples : int = 10 self . _explore_num_warn_up : int = 20000 self . _explore_num_samples : int = 50 self . _consider_constraint : bool = True self . _plot_debug : bool = False self . _plot_freq : int = 10 self . set_args ( ** kwarg ) if self . _plot_debug : self . _visualizer . initialize_design_space ( self . _problem ) def set_args ( self , ** kwarg ): if \"kernel\" in kwarg . keys (): self . _kernel = kwarg [ \"kernel\" ] if \"acquisition_function\" in kwarg . keys (): self . _acq_function = kwarg [ \"acquisition_function\" ] if \"surrogate_model_obj\" in kwarg . keys (): self . _surrogate_model_obj = kwarg [ \"surrogate_model_obj\" ] if \"surrogate_model_con\" in kwarg . keys (): self . _surrogate_model_con = kwarg [ \"surrogate_model_con\" ] if \"random_generator\" in kwarg . keys (): self . _rng = kwarg [ \"random_generator\" ] if \"iteration\" in kwarg . keys (): self . _iteration = kwarg [ \"iteration\" ] if \"num_warn_up_samples\" in kwarg . keys (): self . _num_warn_up_samples = kwarg [ \"num_warn_up_samples\" ] if \"explore_num_warn_up\" in kwarg . keys (): self . _explore_num_warn_up = kwarg [ \"explore_num_warn_up\" ] if \"explore_num_samples\" in kwarg . keys (): self . _explore_num_samples = kwarg [ \"explore_num_samples\" ] if \"consider_constraint\" in kwarg . keys (): self . _consider_constraint = kwarg [ \"consider_constraint\" ] if \"plot_debug\" in kwarg . keys (): self . _plot_debug = kwarg [ \"plot_debug\" ] if \"plot_freq\" in kwarg . keys (): self . _plot_freq = kwarg [ \"plot_freq\" ] def _get_samples ( self , n_samples ): ubound = np . array ([ u_b for ( _ , u_b ) in self . _problem . bounds ]) lbound = np . array ([ l_b for ( l_b , _ ) in self . _problem . bounds ]) return self . _rng . uniform ( low = lbound , high = ubound , size = ( self . _num_warn_up_samples , self . _problem . dim )) def optimize ( self , ** kwarg ): \"\"\"This function performs maximization!!\"\"\" self . _visualizer . plot_objectives () self . _visualizer . plot_finalize () self . _visualizer . plot_constraints () self . _visualizer . plot_finalize () self . set_args ( ** kwarg ) x_max_valid = None y_max_ind_valid = np . full ( self . _problem . obj_dim , - float ( 'inf' )) #record the best obj value of valid design y_max_valid = np . full ( self . _problem . obj_dim , - float ( 'inf' )) #record the best obj value of valid design #warnup with random samples x_sample = self . _get_samples ( n_samples = self . _num_warn_up_samples ) # evaluate the random samples for x in x_sample : y , v = self . _evaluate ( parameters = x ) valid = np . all ( v ) if valid or not self . _consider_constraint : y_max_ind_valid = np . maximum ( y , y_max_ind_valid ) if self . _problem . obj_dominate ( y , y_max_valid ): #TODO: handle multi-objective parato front y_max_valid = y x_max_valid = x # print(self._hist.hist_params) # print(self._hist.hist_func) # print(self._hist.hist_valid) # start performing bayesian optimization for i in range ( self . _iteration ): self . debug_print ( 1 , \"iteration\" , i ) obj_model = self . _surrogate_model_obj ( kernel = self . _kernel ) con_model = self . _surrogate_model_con () x_explored = self . _hist . hist_params y_explored = self . _hist . hist_func v_explored = self . _hist . hist_valid obj_model . fit ( x_explored , y_explored ) if self . _consider_constraint : con_model . fit ( x_explored , v_explored ) # apply the surrogate x_min = self . _explore_with_surrogate ( obj_model = obj_model , con_model = con_model , y_best = y_max_ind_valid , index = i ) # evaluate the candidate y , v = self . _evaluate ( parameters = x_min ) valid = np . all ( v ) if valid or not self . _consider_constraint : y_max_ind_valid = np . maximum ( y , y_max_ind_valid ) if self . _problem . obj_dominate ( y , y_max_valid ): #TODO: handle multi-objective parato front y_max_valid = y x_max_valid = x return x_max_valid , y_max_valid def _evaluate ( self , parameters : npt . ArrayLike , record : bool = True , idx : int | None = None ) -> tuple [ list [ float ], list [ bool ]]: \"\"\"Evaluates the parameters and returns the objective function value and constraints satisfaction\"\"\" obj_vals , con_vals = self . _problem . evaluate ( parameters ) if idx is not None : obj_vals = obj_vals [ idx ] con_vals = con_vals [ idx ] if record : self . _hist . add_hist ( params = parameters , obj_vals = obj_vals , valid = con_vals ) return obj_vals , con_vals def _explore_with_surrogate ( self , obj_model : SurrogateInterface , con_model : SurrogateInterface , y_best , index ): \"\"\"leverage the surrogate and optimize the acquicistion function\"\"\" # find the maximum of the acquisition function # find minimum of its negative x_min = None y_min = float ( \"inf\" ) def func ( x ): return - self . _acq_function ( obj_model = obj_model , con_model = con_model , x = x , y_best = y_best ) #func2 = lambda x: -self._acquisition_function_backup(gpr, classifier, x, y_best, xi) # generate starting points for global exploration warn_samples = self . _get_samples ( n_samples = self . _explore_num_warn_up ) # warn up for x0 in warn_samples : test_res = func ( x0 ) if test_res < y_min : x_min = x0 y_min = test_res exploring_samples = self . _get_samples ( n_samples = self . _explore_num_samples ) #exploring_samples = np.concatenate(warn_samples, exploring_samples) for x0 in exploring_samples : #print(\"inner\", x0, -func(x0), gpr.predict(x0.reshape(1, -1), return_std = True), classifier.predict_proba(x0.reshape(1, -1))) res = minimize ( func , x0 = x0 , bounds = self . _problem . bounds , method = 'L-BFGS-B' ) #print(\"inner\", res.success, res.x, res.fun) if res . fun < y_min : x_min = res . x y_min = res . fun if self . _plot_debug and index % self . _plot_freq == 0 : self . _visualizer . plot_acquisition ( func , x_min ) self . _visualizer . plot_prediction ( obj_model = obj_model , hist = self . _hist , x_next = x_min ) if self . _consider_constraint : self . _visualizer . plot_classification ( con_model = con_model , hist = self . _hist , x_next = x_min ) #plot_acquisition(self._X_gold, func, x_min) #plot_acquisition(self._X_gold, func2, x_min) #print(f\"xmax = {x_min} y_max = {-y_min}, y_best = {y_best}\") #print(x_min, classifier.predict_proba(x_min.reshape(1, -1))) return x_min def expected_improvement ( self , obj_model , con_model , x , y_best ): x = x . reshape ( 1 , - 1 ) mean , std = obj_model . predict ( x ) #print(mean, std) if std == 0.0 : return 0 if self . _consider_constraint : proba = con_model . predict ( x ) # print(proba) #proba = classifier.predict_proba(x) # compute the expected improvement den = mean - y_best - self . _xi Z = den / std ei = den * norm . cdf ( Z ) + std * norm . pdf ( Z ) #print(proba, classifier.classes_) #print(\"EI:\", ei) # Consider the probability of invalid inputs if self . _consider_constraint : if proba > 0.2 : return ei * proba else : return 0 else : return ei optimize ( ** kwarg ) \u00b6 This function performs maximization!! Source code in sym_cps/optimizers/tools/optimization/bayesian_optimizer.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def optimize ( self , ** kwarg ): \"\"\"This function performs maximization!!\"\"\" self . _visualizer . plot_objectives () self . _visualizer . plot_finalize () self . _visualizer . plot_constraints () self . _visualizer . plot_finalize () self . set_args ( ** kwarg ) x_max_valid = None y_max_ind_valid = np . full ( self . _problem . obj_dim , - float ( 'inf' )) #record the best obj value of valid design y_max_valid = np . full ( self . _problem . obj_dim , - float ( 'inf' )) #record the best obj value of valid design #warnup with random samples x_sample = self . _get_samples ( n_samples = self . _num_warn_up_samples ) # evaluate the random samples for x in x_sample : y , v = self . _evaluate ( parameters = x ) valid = np . all ( v ) if valid or not self . _consider_constraint : y_max_ind_valid = np . maximum ( y , y_max_ind_valid ) if self . _problem . obj_dominate ( y , y_max_valid ): #TODO: handle multi-objective parato front y_max_valid = y x_max_valid = x # print(self._hist.hist_params) # print(self._hist.hist_func) # print(self._hist.hist_valid) # start performing bayesian optimization for i in range ( self . _iteration ): self . debug_print ( 1 , \"iteration\" , i ) obj_model = self . _surrogate_model_obj ( kernel = self . _kernel ) con_model = self . _surrogate_model_con () x_explored = self . _hist . hist_params y_explored = self . _hist . hist_func v_explored = self . _hist . hist_valid obj_model . fit ( x_explored , y_explored ) if self . _consider_constraint : con_model . fit ( x_explored , v_explored ) # apply the surrogate x_min = self . _explore_with_surrogate ( obj_model = obj_model , con_model = con_model , y_best = y_max_ind_valid , index = i ) # evaluate the candidate y , v = self . _evaluate ( parameters = x_min ) valid = np . all ( v ) if valid or not self . _consider_constraint : y_max_ind_valid = np . maximum ( y , y_max_ind_valid ) if self . _problem . obj_dominate ( y , y_max_valid ): #TODO: handle multi-objective parato front y_max_valid = y x_max_valid = x return x_max_valid , y_max_valid","title":"bayesian_optimizer"},{"location":"reference/sym_cps/optimizers/tools/optimization/bayesian_optimizer/#sym_cps.optimizers.tools.optimization.bayesian_optimizer.BayesianOptimizer","text":"Bases: OptimizerBase Optimization usign Bayesian Optimization Taking a optimization problem, performs black box optimization which combines a classifier Input: problem: A ProblemBase object Source code in sym_cps/optimizers/tools/optimization/bayesian_optimizer.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 class BayesianOptimizer ( OptimizerBase ): \"\"\"Optimization usign Bayesian Optimization Taking a optimization problem, performs black box optimization which combines a classifier Input: problem: A ProblemBase object \"\"\" def __init__ ( self , problem : ProblemBase , ** kwarg ): super () . __init__ ( problem = problem ) self . _visualizer = BayesianOptimizationVisualizer () self . _kernel = Matern ( nu = 2.5 , length_scale = 0.05 , length_scale_bounds = \"fixed\" ) self . _acq_function = self . expected_improvement self . _surrogate_model_obj : SurrogateInterface = ScikitGPR self . _surrogate_model_con : SurrogateInterface = LogisticClassifier self . _xi : float = 0.0 self . _rng = np . random . RandomState ( 1234 ) self . _iteration : int = 1000 self . _num_warn_up_samples : int = 10 self . _explore_num_warn_up : int = 20000 self . _explore_num_samples : int = 50 self . _consider_constraint : bool = True self . _plot_debug : bool = False self . _plot_freq : int = 10 self . set_args ( ** kwarg ) if self . _plot_debug : self . _visualizer . initialize_design_space ( self . _problem ) def set_args ( self , ** kwarg ): if \"kernel\" in kwarg . keys (): self . _kernel = kwarg [ \"kernel\" ] if \"acquisition_function\" in kwarg . keys (): self . _acq_function = kwarg [ \"acquisition_function\" ] if \"surrogate_model_obj\" in kwarg . keys (): self . _surrogate_model_obj = kwarg [ \"surrogate_model_obj\" ] if \"surrogate_model_con\" in kwarg . keys (): self . _surrogate_model_con = kwarg [ \"surrogate_model_con\" ] if \"random_generator\" in kwarg . keys (): self . _rng = kwarg [ \"random_generator\" ] if \"iteration\" in kwarg . keys (): self . _iteration = kwarg [ \"iteration\" ] if \"num_warn_up_samples\" in kwarg . keys (): self . _num_warn_up_samples = kwarg [ \"num_warn_up_samples\" ] if \"explore_num_warn_up\" in kwarg . keys (): self . _explore_num_warn_up = kwarg [ \"explore_num_warn_up\" ] if \"explore_num_samples\" in kwarg . keys (): self . _explore_num_samples = kwarg [ \"explore_num_samples\" ] if \"consider_constraint\" in kwarg . keys (): self . _consider_constraint = kwarg [ \"consider_constraint\" ] if \"plot_debug\" in kwarg . keys (): self . _plot_debug = kwarg [ \"plot_debug\" ] if \"plot_freq\" in kwarg . keys (): self . _plot_freq = kwarg [ \"plot_freq\" ] def _get_samples ( self , n_samples ): ubound = np . array ([ u_b for ( _ , u_b ) in self . _problem . bounds ]) lbound = np . array ([ l_b for ( l_b , _ ) in self . _problem . bounds ]) return self . _rng . uniform ( low = lbound , high = ubound , size = ( self . _num_warn_up_samples , self . _problem . dim )) def optimize ( self , ** kwarg ): \"\"\"This function performs maximization!!\"\"\" self . _visualizer . plot_objectives () self . _visualizer . plot_finalize () self . _visualizer . plot_constraints () self . _visualizer . plot_finalize () self . set_args ( ** kwarg ) x_max_valid = None y_max_ind_valid = np . full ( self . _problem . obj_dim , - float ( 'inf' )) #record the best obj value of valid design y_max_valid = np . full ( self . _problem . obj_dim , - float ( 'inf' )) #record the best obj value of valid design #warnup with random samples x_sample = self . _get_samples ( n_samples = self . _num_warn_up_samples ) # evaluate the random samples for x in x_sample : y , v = self . _evaluate ( parameters = x ) valid = np . all ( v ) if valid or not self . _consider_constraint : y_max_ind_valid = np . maximum ( y , y_max_ind_valid ) if self . _problem . obj_dominate ( y , y_max_valid ): #TODO: handle multi-objective parato front y_max_valid = y x_max_valid = x # print(self._hist.hist_params) # print(self._hist.hist_func) # print(self._hist.hist_valid) # start performing bayesian optimization for i in range ( self . _iteration ): self . debug_print ( 1 , \"iteration\" , i ) obj_model = self . _surrogate_model_obj ( kernel = self . _kernel ) con_model = self . _surrogate_model_con () x_explored = self . _hist . hist_params y_explored = self . _hist . hist_func v_explored = self . _hist . hist_valid obj_model . fit ( x_explored , y_explored ) if self . _consider_constraint : con_model . fit ( x_explored , v_explored ) # apply the surrogate x_min = self . _explore_with_surrogate ( obj_model = obj_model , con_model = con_model , y_best = y_max_ind_valid , index = i ) # evaluate the candidate y , v = self . _evaluate ( parameters = x_min ) valid = np . all ( v ) if valid or not self . _consider_constraint : y_max_ind_valid = np . maximum ( y , y_max_ind_valid ) if self . _problem . obj_dominate ( y , y_max_valid ): #TODO: handle multi-objective parato front y_max_valid = y x_max_valid = x return x_max_valid , y_max_valid def _evaluate ( self , parameters : npt . ArrayLike , record : bool = True , idx : int | None = None ) -> tuple [ list [ float ], list [ bool ]]: \"\"\"Evaluates the parameters and returns the objective function value and constraints satisfaction\"\"\" obj_vals , con_vals = self . _problem . evaluate ( parameters ) if idx is not None : obj_vals = obj_vals [ idx ] con_vals = con_vals [ idx ] if record : self . _hist . add_hist ( params = parameters , obj_vals = obj_vals , valid = con_vals ) return obj_vals , con_vals def _explore_with_surrogate ( self , obj_model : SurrogateInterface , con_model : SurrogateInterface , y_best , index ): \"\"\"leverage the surrogate and optimize the acquicistion function\"\"\" # find the maximum of the acquisition function # find minimum of its negative x_min = None y_min = float ( \"inf\" ) def func ( x ): return - self . _acq_function ( obj_model = obj_model , con_model = con_model , x = x , y_best = y_best ) #func2 = lambda x: -self._acquisition_function_backup(gpr, classifier, x, y_best, xi) # generate starting points for global exploration warn_samples = self . _get_samples ( n_samples = self . _explore_num_warn_up ) # warn up for x0 in warn_samples : test_res = func ( x0 ) if test_res < y_min : x_min = x0 y_min = test_res exploring_samples = self . _get_samples ( n_samples = self . _explore_num_samples ) #exploring_samples = np.concatenate(warn_samples, exploring_samples) for x0 in exploring_samples : #print(\"inner\", x0, -func(x0), gpr.predict(x0.reshape(1, -1), return_std = True), classifier.predict_proba(x0.reshape(1, -1))) res = minimize ( func , x0 = x0 , bounds = self . _problem . bounds , method = 'L-BFGS-B' ) #print(\"inner\", res.success, res.x, res.fun) if res . fun < y_min : x_min = res . x y_min = res . fun if self . _plot_debug and index % self . _plot_freq == 0 : self . _visualizer . plot_acquisition ( func , x_min ) self . _visualizer . plot_prediction ( obj_model = obj_model , hist = self . _hist , x_next = x_min ) if self . _consider_constraint : self . _visualizer . plot_classification ( con_model = con_model , hist = self . _hist , x_next = x_min ) #plot_acquisition(self._X_gold, func, x_min) #plot_acquisition(self._X_gold, func2, x_min) #print(f\"xmax = {x_min} y_max = {-y_min}, y_best = {y_best}\") #print(x_min, classifier.predict_proba(x_min.reshape(1, -1))) return x_min def expected_improvement ( self , obj_model , con_model , x , y_best ): x = x . reshape ( 1 , - 1 ) mean , std = obj_model . predict ( x ) #print(mean, std) if std == 0.0 : return 0 if self . _consider_constraint : proba = con_model . predict ( x ) # print(proba) #proba = classifier.predict_proba(x) # compute the expected improvement den = mean - y_best - self . _xi Z = den / std ei = den * norm . cdf ( Z ) + std * norm . pdf ( Z ) #print(proba, classifier.classes_) #print(\"EI:\", ei) # Consider the probability of invalid inputs if self . _consider_constraint : if proba > 0.2 : return ei * proba else : return 0 else : return ei","title":"BayesianOptimizer"},{"location":"reference/sym_cps/optimizers/tools/optimization/bayesian_optimizer/#sym_cps.optimizers.tools.optimization.bayesian_optimizer.BayesianOptimizer.optimize","text":"This function performs maximization!! Source code in sym_cps/optimizers/tools/optimization/bayesian_optimizer.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def optimize ( self , ** kwarg ): \"\"\"This function performs maximization!!\"\"\" self . _visualizer . plot_objectives () self . _visualizer . plot_finalize () self . _visualizer . plot_constraints () self . _visualizer . plot_finalize () self . set_args ( ** kwarg ) x_max_valid = None y_max_ind_valid = np . full ( self . _problem . obj_dim , - float ( 'inf' )) #record the best obj value of valid design y_max_valid = np . full ( self . _problem . obj_dim , - float ( 'inf' )) #record the best obj value of valid design #warnup with random samples x_sample = self . _get_samples ( n_samples = self . _num_warn_up_samples ) # evaluate the random samples for x in x_sample : y , v = self . _evaluate ( parameters = x ) valid = np . all ( v ) if valid or not self . _consider_constraint : y_max_ind_valid = np . maximum ( y , y_max_ind_valid ) if self . _problem . obj_dominate ( y , y_max_valid ): #TODO: handle multi-objective parato front y_max_valid = y x_max_valid = x # print(self._hist.hist_params) # print(self._hist.hist_func) # print(self._hist.hist_valid) # start performing bayesian optimization for i in range ( self . _iteration ): self . debug_print ( 1 , \"iteration\" , i ) obj_model = self . _surrogate_model_obj ( kernel = self . _kernel ) con_model = self . _surrogate_model_con () x_explored = self . _hist . hist_params y_explored = self . _hist . hist_func v_explored = self . _hist . hist_valid obj_model . fit ( x_explored , y_explored ) if self . _consider_constraint : con_model . fit ( x_explored , v_explored ) # apply the surrogate x_min = self . _explore_with_surrogate ( obj_model = obj_model , con_model = con_model , y_best = y_max_ind_valid , index = i ) # evaluate the candidate y , v = self . _evaluate ( parameters = x_min ) valid = np . all ( v ) if valid or not self . _consider_constraint : y_max_ind_valid = np . maximum ( y , y_max_ind_valid ) if self . _problem . obj_dominate ( y , y_max_valid ): #TODO: handle multi-objective parato front y_max_valid = y x_max_valid = x return x_max_valid , y_max_valid","title":"optimize()"},{"location":"reference/sym_cps/optimizers/tools/optimization/optimizer_base/","text":"optimizer_base.py Define the class OptimizerBase as an abstract class for optimizer. OptimizerBase \u00b6 Bases: ABC Define the base class for all optimizer, either a self-implemented optimzer or an interface to other optimization library Source code in sym_cps/optimizers/tools/optimization/optimizer_base.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class OptimizerBase ( ABC ): \"\"\" Define the base class for all optimizer, either a self-implemented optimzer or an interface to other optimization library \"\"\" def __init__ ( self , problem : ProblemBase , debug_level = 1 ): #debug_level 1: print every detail during each iteration #debug_level 2: print every steps in the algorithm self . _problem : ProblemBase = problem self . _debug_level : int = debug_level self . _fail_value : float = float ( \"inf\" ) self . _hist : History = History () self . reset_history () @abstractmethod def set_args ( self , ** kwarg ): \"\"\"Set the arguments before calling optimize\"\"\" @abstractmethod def optimize ( self , ** kwarg ): \"\"\" Abstract method that optimizes a design problem Implementation \"\"\" def reset_history ( self ): \"\"\"Clear all history\"\"\" x_dim = self . _problem . dim self . _hist . reset_history ( x_dim , self . _problem . obj_dim , self . _problem . con_dim ) @property def hist ( self ) -> History : return self . _hist def debug_print ( self , level_constraint : int , * args , ** kwargs ): if self . _debug_level > level_constraint : print ( * args , ** kwargs ) @abstractmethod def _evaluate ( self , parameters : npt . ArrayLike , record : bool = True , idx : int | None = None ) -> tuple [ list [ float ], list [ bool ]]: \"\"\"Evaluates the parameters and returns the objective function value and constraints satisfaction\"\"\" obj_vals , con_vals = self . _problem . evaluete ( parameters ) if record : self . _hist . add_hist ( params = parameters , obj_vals = obj_vals , valid = con_vals ) return obj_vals , con_vals def _update_parameters ( self , parameters : npt . ArrayLike ) -> None : self . _problem . set_parameters ( parameters = parameters ) optimize ( ** kwarg ) abstractmethod \u00b6 Abstract method that optimizes a design problem Implementation Source code in sym_cps/optimizers/tools/optimization/optimizer_base.py 30 31 32 33 34 35 @abstractmethod def optimize ( self , ** kwarg ): \"\"\" Abstract method that optimizes a design problem Implementation \"\"\" reset_history () \u00b6 Clear all history Source code in sym_cps/optimizers/tools/optimization/optimizer_base.py 37 38 39 40 def reset_history ( self ): \"\"\"Clear all history\"\"\" x_dim = self . _problem . dim self . _hist . reset_history ( x_dim , self . _problem . obj_dim , self . _problem . con_dim ) set_args ( ** kwarg ) abstractmethod \u00b6 Set the arguments before calling optimize Source code in sym_cps/optimizers/tools/optimization/optimizer_base.py 26 27 28 @abstractmethod def set_args ( self , ** kwarg ): \"\"\"Set the arguments before calling optimize\"\"\"","title":"optimizer_base"},{"location":"reference/sym_cps/optimizers/tools/optimization/optimizer_base/#sym_cps.optimizers.tools.optimization.optimizer_base.OptimizerBase","text":"Bases: ABC Define the base class for all optimizer, either a self-implemented optimzer or an interface to other optimization library Source code in sym_cps/optimizers/tools/optimization/optimizer_base.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class OptimizerBase ( ABC ): \"\"\" Define the base class for all optimizer, either a self-implemented optimzer or an interface to other optimization library \"\"\" def __init__ ( self , problem : ProblemBase , debug_level = 1 ): #debug_level 1: print every detail during each iteration #debug_level 2: print every steps in the algorithm self . _problem : ProblemBase = problem self . _debug_level : int = debug_level self . _fail_value : float = float ( \"inf\" ) self . _hist : History = History () self . reset_history () @abstractmethod def set_args ( self , ** kwarg ): \"\"\"Set the arguments before calling optimize\"\"\" @abstractmethod def optimize ( self , ** kwarg ): \"\"\" Abstract method that optimizes a design problem Implementation \"\"\" def reset_history ( self ): \"\"\"Clear all history\"\"\" x_dim = self . _problem . dim self . _hist . reset_history ( x_dim , self . _problem . obj_dim , self . _problem . con_dim ) @property def hist ( self ) -> History : return self . _hist def debug_print ( self , level_constraint : int , * args , ** kwargs ): if self . _debug_level > level_constraint : print ( * args , ** kwargs ) @abstractmethod def _evaluate ( self , parameters : npt . ArrayLike , record : bool = True , idx : int | None = None ) -> tuple [ list [ float ], list [ bool ]]: \"\"\"Evaluates the parameters and returns the objective function value and constraints satisfaction\"\"\" obj_vals , con_vals = self . _problem . evaluete ( parameters ) if record : self . _hist . add_hist ( params = parameters , obj_vals = obj_vals , valid = con_vals ) return obj_vals , con_vals def _update_parameters ( self , parameters : npt . ArrayLike ) -> None : self . _problem . set_parameters ( parameters = parameters )","title":"OptimizerBase"},{"location":"reference/sym_cps/optimizers/tools/optimization/optimizer_base/#sym_cps.optimizers.tools.optimization.optimizer_base.OptimizerBase.optimize","text":"Abstract method that optimizes a design problem Implementation Source code in sym_cps/optimizers/tools/optimization/optimizer_base.py 30 31 32 33 34 35 @abstractmethod def optimize ( self , ** kwarg ): \"\"\" Abstract method that optimizes a design problem Implementation \"\"\"","title":"optimize()"},{"location":"reference/sym_cps/optimizers/tools/optimization/optimizer_base/#sym_cps.optimizers.tools.optimization.optimizer_base.OptimizerBase.reset_history","text":"Clear all history Source code in sym_cps/optimizers/tools/optimization/optimizer_base.py 37 38 39 40 def reset_history ( self ): \"\"\"Clear all history\"\"\" x_dim = self . _problem . dim self . _hist . reset_history ( x_dim , self . _problem . obj_dim , self . _problem . con_dim )","title":"reset_history()"},{"location":"reference/sym_cps/optimizers/tools/optimization/optimizer_base/#sym_cps.optimizers.tools.optimization.optimizer_base.OptimizerBase.set_args","text":"Set the arguments before calling optimize Source code in sym_cps/optimizers/tools/optimization/optimizer_base.py 26 27 28 @abstractmethod def set_args ( self , ** kwarg ): \"\"\"Set the arguments before calling optimize\"\"\"","title":"set_args()"},{"location":"reference/sym_cps/optimizers/tools/optimization/problem_base/","text":"ProblemBase \u00b6 Bases: ABC The base class for the Optimization Problem _bounds: list[Tuple[float, float]]the bound (box constraints) for the design problem. The first element of the tuple is the lower bound and the other element is the upper bound For example, [(1,5), (2,4)] can be used to represent the box constraints $1 < x < 5, 2 < y < 4$. _opt_array: the numpy array that are used as initial value. Source code in sym_cps/optimizers/tools/optimization/problem_base.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 class ProblemBase ( ABC ): \"\"\"The base class for the Optimization Problem _bounds: list[Tuple[float, float]]the bound (box constraints) for the design problem. The first element of the tuple is the lower bound and the other element is the upper bound For example, [(1,5), (2,4)] can be used to represent the box constraints $1 < x < 5, 2 < y < 4$. _opt_array: the numpy array that are used as initial value. \"\"\" def __init__ ( self ): self . _bounds : list [ tuple [ float , float ]] = None self . _opt_array : npt . ArrayLike = None self . _obj_dim = 0 self . _con_dim = 0 @property def dim ( self ): \"\"\"Number of optimization variables\"\"\" return len ( self . _bounds ) @property def obj_dim ( self ): return self . _obj_dim def set_obj_dim ( self , dim : int ): self . _obj_dim = dim @property def con_dim ( self ): return self . _con_dim def set_con_dim ( self , dim : int ): self . _con_dim = dim @abstractmethod def obj_dominate ( self , obj1 : npt . ArrayLike , obj2 : npt . ArrayLike ): pass @property def bounds ( self ): \"\"\"The bounds of the optimization problem\"\"\" return self . _bounds @abstractmethod def evaluate ( self , parameters : npt . ArrayLike ): \"\"\"return the objective function or invalid parameters\"\"\" pass @abstractmethod def set_parameters ( self , parameters : npt . ArrayLike ) -> None : pass bounds () property \u00b6 The bounds of the optimization problem Source code in sym_cps/optimizers/tools/optimization/problem_base.py 40 41 42 43 @property def bounds ( self ): \"\"\"The bounds of the optimization problem\"\"\" return self . _bounds dim () property \u00b6 Number of optimization variables Source code in sym_cps/optimizers/tools/optimization/problem_base.py 17 18 19 20 @property def dim ( self ): \"\"\"Number of optimization variables\"\"\" return len ( self . _bounds ) evaluate ( parameters ) abstractmethod \u00b6 return the objective function or invalid parameters Source code in sym_cps/optimizers/tools/optimization/problem_base.py 46 47 48 49 @abstractmethod def evaluate ( self , parameters : npt . ArrayLike ): \"\"\"return the objective function or invalid parameters\"\"\" pass","title":"problem_base"},{"location":"reference/sym_cps/optimizers/tools/optimization/problem_base/#sym_cps.optimizers.tools.optimization.problem_base.ProblemBase","text":"Bases: ABC The base class for the Optimization Problem _bounds: list[Tuple[float, float]]the bound (box constraints) for the design problem. The first element of the tuple is the lower bound and the other element is the upper bound For example, [(1,5), (2,4)] can be used to represent the box constraints $1 < x < 5, 2 < y < 4$. _opt_array: the numpy array that are used as initial value. Source code in sym_cps/optimizers/tools/optimization/problem_base.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 class ProblemBase ( ABC ): \"\"\"The base class for the Optimization Problem _bounds: list[Tuple[float, float]]the bound (box constraints) for the design problem. The first element of the tuple is the lower bound and the other element is the upper bound For example, [(1,5), (2,4)] can be used to represent the box constraints $1 < x < 5, 2 < y < 4$. _opt_array: the numpy array that are used as initial value. \"\"\" def __init__ ( self ): self . _bounds : list [ tuple [ float , float ]] = None self . _opt_array : npt . ArrayLike = None self . _obj_dim = 0 self . _con_dim = 0 @property def dim ( self ): \"\"\"Number of optimization variables\"\"\" return len ( self . _bounds ) @property def obj_dim ( self ): return self . _obj_dim def set_obj_dim ( self , dim : int ): self . _obj_dim = dim @property def con_dim ( self ): return self . _con_dim def set_con_dim ( self , dim : int ): self . _con_dim = dim @abstractmethod def obj_dominate ( self , obj1 : npt . ArrayLike , obj2 : npt . ArrayLike ): pass @property def bounds ( self ): \"\"\"The bounds of the optimization problem\"\"\" return self . _bounds @abstractmethod def evaluate ( self , parameters : npt . ArrayLike ): \"\"\"return the objective function or invalid parameters\"\"\" pass @abstractmethod def set_parameters ( self , parameters : npt . ArrayLike ) -> None : pass","title":"ProblemBase"},{"location":"reference/sym_cps/optimizers/tools/optimization/problem_base/#sym_cps.optimizers.tools.optimization.problem_base.ProblemBase.bounds","text":"The bounds of the optimization problem Source code in sym_cps/optimizers/tools/optimization/problem_base.py 40 41 42 43 @property def bounds ( self ): \"\"\"The bounds of the optimization problem\"\"\" return self . _bounds","title":"bounds()"},{"location":"reference/sym_cps/optimizers/tools/optimization/problem_base/#sym_cps.optimizers.tools.optimization.problem_base.ProblemBase.dim","text":"Number of optimization variables Source code in sym_cps/optimizers/tools/optimization/problem_base.py 17 18 19 20 @property def dim ( self ): \"\"\"Number of optimization variables\"\"\" return len ( self . _bounds )","title":"dim()"},{"location":"reference/sym_cps/optimizers/tools/optimization/problem_base/#sym_cps.optimizers.tools.optimization.problem_base.ProblemBase.evaluate","text":"return the objective function or invalid parameters Source code in sym_cps/optimizers/tools/optimization/problem_base.py 46 47 48 49 @abstractmethod def evaluate ( self , parameters : npt . ArrayLike ): \"\"\"return the objective function or invalid parameters\"\"\" pass","title":"evaluate()"},{"location":"reference/sym_cps/optimizers/tools/optimization/test_optimization/","text":"","title":"test_optimization"},{"location":"reference/sym_cps/optimizers/tools/optimization/test_optimization/test_bayesian_opt/","text":"TestProblem \u00b6 Bases: ProblemBase Source code in sym_cps/optimizers/tools/optimization/test_optimization/test_bayesian_opt.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class TestProblem ( ProblemBase ): def __init__ ( self , bounds , opt_array , obj_dim , con_dim , obj_func , con_func ): self . _bounds : list [ tuple [ float , float ]] = bounds self . _opt_array : npt . ArrayLike = opt_array self . _obj_dim = obj_dim self . _con_dim = con_dim self . _obj_func = obj_func self . _con_func = con_func def obj_dominate ( self , obj1 : npt . ArrayLike , obj2 : npt . ArrayLike ): return obj1 [ 0 ] > obj2 [ 0 ] def evaluate ( self , parameters : npt . ArrayLike ): \"\"\"return the objective function or invalid parameters\"\"\" return self . _obj_func ( parameters ), self . _con_func ( parameters ) def set_parameters ( self , parameters : npt . ArrayLike ) -> None : pass evaluate ( parameters ) \u00b6 return the objective function or invalid parameters Source code in sym_cps/optimizers/tools/optimization/test_optimization/test_bayesian_opt.py 21 22 23 def evaluate ( self , parameters : npt . ArrayLike ): \"\"\"return the objective function or invalid parameters\"\"\" return self . _obj_func ( parameters ), self . _con_func ( parameters ) drop_wave_equation_1d ( x ) \u00b6 1 dimensional simplification of drop wave equation from https://www.sfu.ca/~ssurjano/drop.html The drop wave equation has multiple local minima Source code in sym_cps/optimizers/tools/optimization/test_optimization/test_bayesian_opt.py 29 30 31 32 33 34 def drop_wave_equation_1d ( x ): \"\"\" 1 dimensional simplification of drop wave equation from https://www.sfu.ca/~ssurjano/drop.html The drop wave equation has multiple local minima \"\"\" return - ( 1 + np . cos ( 12 * np . sqrt ( x ** 2 ))) / (( 0.5 * x ** 2 ) + 2 )","title":"test_bayesian_opt"},{"location":"reference/sym_cps/optimizers/tools/optimization/test_optimization/test_bayesian_opt/#sym_cps.optimizers.tools.optimization.test_optimization.test_bayesian_opt.TestProblem","text":"Bases: ProblemBase Source code in sym_cps/optimizers/tools/optimization/test_optimization/test_bayesian_opt.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class TestProblem ( ProblemBase ): def __init__ ( self , bounds , opt_array , obj_dim , con_dim , obj_func , con_func ): self . _bounds : list [ tuple [ float , float ]] = bounds self . _opt_array : npt . ArrayLike = opt_array self . _obj_dim = obj_dim self . _con_dim = con_dim self . _obj_func = obj_func self . _con_func = con_func def obj_dominate ( self , obj1 : npt . ArrayLike , obj2 : npt . ArrayLike ): return obj1 [ 0 ] > obj2 [ 0 ] def evaluate ( self , parameters : npt . ArrayLike ): \"\"\"return the objective function or invalid parameters\"\"\" return self . _obj_func ( parameters ), self . _con_func ( parameters ) def set_parameters ( self , parameters : npt . ArrayLike ) -> None : pass","title":"TestProblem"},{"location":"reference/sym_cps/optimizers/tools/optimization/test_optimization/test_bayesian_opt/#sym_cps.optimizers.tools.optimization.test_optimization.test_bayesian_opt.TestProblem.evaluate","text":"return the objective function or invalid parameters Source code in sym_cps/optimizers/tools/optimization/test_optimization/test_bayesian_opt.py 21 22 23 def evaluate ( self , parameters : npt . ArrayLike ): \"\"\"return the objective function or invalid parameters\"\"\" return self . _obj_func ( parameters ), self . _con_func ( parameters )","title":"evaluate()"},{"location":"reference/sym_cps/optimizers/tools/optimization/test_optimization/test_bayesian_opt/#sym_cps.optimizers.tools.optimization.test_optimization.test_bayesian_opt.drop_wave_equation_1d","text":"1 dimensional simplification of drop wave equation from https://www.sfu.ca/~ssurjano/drop.html The drop wave equation has multiple local minima Source code in sym_cps/optimizers/tools/optimization/test_optimization/test_bayesian_opt.py 29 30 31 32 33 34 def drop_wave_equation_1d ( x ): \"\"\" 1 dimensional simplification of drop wave equation from https://www.sfu.ca/~ssurjano/drop.html The drop wave equation has multiple local minima \"\"\" return - ( 1 + np . cos ( 12 * np . sqrt ( x ** 2 ))) / (( 0.5 * x ** 2 ) + 2 )","title":"drop_wave_equation_1d()"},{"location":"reference/sym_cps/optimizers/tools/optimization/util/","text":"","title":"util"},{"location":"reference/sym_cps/optimizers/tools/optimization/util/exceptions/","text":"InValidDesignException \u00b6 Bases: Exception Class Invalid Design Exception Source code in sym_cps/optimizers/tools/optimization/util/exceptions.py 1 2 class InValidDesignException ( Exception ): \"\"\"Class Invalid Design Exception\"\"\"","title":"exceptions"},{"location":"reference/sym_cps/optimizers/tools/optimization/util/exceptions/#sym_cps.optimizers.tools.optimization.util.exceptions.InValidDesignException","text":"Bases: Exception Class Invalid Design Exception Source code in sym_cps/optimizers/tools/optimization/util/exceptions.py 1 2 class InValidDesignException ( Exception ): \"\"\"Class Invalid Design Exception\"\"\"","title":"InValidDesignException"},{"location":"reference/sym_cps/optimizers/tools/optimization/util/history/","text":"History \u00b6 Source code in sym_cps/optimizers/tools/optimization/util/history.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class History (): def __init__ ( self ): self . _hist_p = None # params self . _hist_f = None # func values self . _hist_v = None # valid def reset_history ( self , p_dim , num_obj , num_con ): \"\"\"Clear all history\"\"\" self . _hist_d = [] self . _hist_p = np . array ([]) . reshape (( 0 , p_dim )) self . _hist_f = np . array ([]) . reshape (( 0 , num_obj )) self . _hist_v = np . array ([]) . reshape (( 0 , num_con )) def add_hist ( self , params , obj_vals , valid ): \"\"\"Push a data point to the history\"\"\" obj_vals = np . array ( obj_vals ) valid = np . array ( valid ) self . _hist_p = np . concatenate (( self . _hist_p , params . reshape ( 1 , - 1 ))) self . _hist_f = np . concatenate (( self . _hist_f , obj_vals . reshape ( 1 , - 1 ))) self . _hist_v = np . concatenate (( self . _hist_v , valid . reshape ( 1 , - 1 ))) @property def length ( self ): return len ( self . _hist_d ) @property def hist_params ( self ): return self . _hist_p @property def hist_func ( self ): return self . _hist_f @property def hist_valid ( self ): return self . _hist_v @property def hist ( self ): return self . hist_params , self . hist_func , self . hist_valid add_hist ( params , obj_vals , valid ) \u00b6 Push a data point to the history Source code in sym_cps/optimizers/tools/optimization/util/history.py 16 17 18 19 20 21 22 def add_hist ( self , params , obj_vals , valid ): \"\"\"Push a data point to the history\"\"\" obj_vals = np . array ( obj_vals ) valid = np . array ( valid ) self . _hist_p = np . concatenate (( self . _hist_p , params . reshape ( 1 , - 1 ))) self . _hist_f = np . concatenate (( self . _hist_f , obj_vals . reshape ( 1 , - 1 ))) self . _hist_v = np . concatenate (( self . _hist_v , valid . reshape ( 1 , - 1 ))) reset_history ( p_dim , num_obj , num_con ) \u00b6 Clear all history Source code in sym_cps/optimizers/tools/optimization/util/history.py 9 10 11 12 13 14 def reset_history ( self , p_dim , num_obj , num_con ): \"\"\"Clear all history\"\"\" self . _hist_d = [] self . _hist_p = np . array ([]) . reshape (( 0 , p_dim )) self . _hist_f = np . array ([]) . reshape (( 0 , num_obj )) self . _hist_v = np . array ([]) . reshape (( 0 , num_con ))","title":"history"},{"location":"reference/sym_cps/optimizers/tools/optimization/util/history/#sym_cps.optimizers.tools.optimization.util.history.History","text":"Source code in sym_cps/optimizers/tools/optimization/util/history.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class History (): def __init__ ( self ): self . _hist_p = None # params self . _hist_f = None # func values self . _hist_v = None # valid def reset_history ( self , p_dim , num_obj , num_con ): \"\"\"Clear all history\"\"\" self . _hist_d = [] self . _hist_p = np . array ([]) . reshape (( 0 , p_dim )) self . _hist_f = np . array ([]) . reshape (( 0 , num_obj )) self . _hist_v = np . array ([]) . reshape (( 0 , num_con )) def add_hist ( self , params , obj_vals , valid ): \"\"\"Push a data point to the history\"\"\" obj_vals = np . array ( obj_vals ) valid = np . array ( valid ) self . _hist_p = np . concatenate (( self . _hist_p , params . reshape ( 1 , - 1 ))) self . _hist_f = np . concatenate (( self . _hist_f , obj_vals . reshape ( 1 , - 1 ))) self . _hist_v = np . concatenate (( self . _hist_v , valid . reshape ( 1 , - 1 ))) @property def length ( self ): return len ( self . _hist_d ) @property def hist_params ( self ): return self . _hist_p @property def hist_func ( self ): return self . _hist_f @property def hist_valid ( self ): return self . _hist_v @property def hist ( self ): return self . hist_params , self . hist_func , self . hist_valid","title":"History"},{"location":"reference/sym_cps/optimizers/tools/optimization/util/history/#sym_cps.optimizers.tools.optimization.util.history.History.add_hist","text":"Push a data point to the history Source code in sym_cps/optimizers/tools/optimization/util/history.py 16 17 18 19 20 21 22 def add_hist ( self , params , obj_vals , valid ): \"\"\"Push a data point to the history\"\"\" obj_vals = np . array ( obj_vals ) valid = np . array ( valid ) self . _hist_p = np . concatenate (( self . _hist_p , params . reshape ( 1 , - 1 ))) self . _hist_f = np . concatenate (( self . _hist_f , obj_vals . reshape ( 1 , - 1 ))) self . _hist_v = np . concatenate (( self . _hist_v , valid . reshape ( 1 , - 1 )))","title":"add_hist()"},{"location":"reference/sym_cps/optimizers/tools/optimization/util/history/#sym_cps.optimizers.tools.optimization.util.history.History.reset_history","text":"Clear all history Source code in sym_cps/optimizers/tools/optimization/util/history.py 9 10 11 12 13 14 def reset_history ( self , p_dim , num_obj , num_con ): \"\"\"Clear all history\"\"\" self . _hist_d = [] self . _hist_p = np . array ([]) . reshape (( 0 , p_dim )) self . _hist_f = np . array ([]) . reshape (( 0 , num_obj )) self . _hist_v = np . array ([]) . reshape (( 0 , num_con ))","title":"reset_history()"},{"location":"reference/sym_cps/optimizers/tools/optimization/util/surrogate/","text":"SurrogateInterface \u00b6 Bases: ABC Source code in sym_cps/optimizers/tools/optimization/util/surrogate.py 6 7 8 9 10 11 12 13 14 15 16 class SurrogateInterface ( ABC ): def __init__ ( self ): pass @abstractmethod def fit ( self , X , Y ): \"\"\"Built the surrogate model\"\"\" @abstractmethod def predict ( self , x ): \"\"\"Access the model\"\"\" fit ( X , Y ) abstractmethod \u00b6 Built the surrogate model Source code in sym_cps/optimizers/tools/optimization/util/surrogate.py 10 11 12 @abstractmethod def fit ( self , X , Y ): \"\"\"Built the surrogate model\"\"\" predict ( x ) abstractmethod \u00b6 Access the model Source code in sym_cps/optimizers/tools/optimization/util/surrogate.py 14 15 16 @abstractmethod def predict ( self , x ): \"\"\"Access the model\"\"\"","title":"surrogate"},{"location":"reference/sym_cps/optimizers/tools/optimization/util/surrogate/#sym_cps.optimizers.tools.optimization.util.surrogate.SurrogateInterface","text":"Bases: ABC Source code in sym_cps/optimizers/tools/optimization/util/surrogate.py 6 7 8 9 10 11 12 13 14 15 16 class SurrogateInterface ( ABC ): def __init__ ( self ): pass @abstractmethod def fit ( self , X , Y ): \"\"\"Built the surrogate model\"\"\" @abstractmethod def predict ( self , x ): \"\"\"Access the model\"\"\"","title":"SurrogateInterface"},{"location":"reference/sym_cps/optimizers/tools/optimization/util/surrogate/#sym_cps.optimizers.tools.optimization.util.surrogate.SurrogateInterface.fit","text":"Built the surrogate model Source code in sym_cps/optimizers/tools/optimization/util/surrogate.py 10 11 12 @abstractmethod def fit ( self , X , Y ): \"\"\"Built the surrogate model\"\"\"","title":"fit()"},{"location":"reference/sym_cps/optimizers/tools/optimization/util/surrogate/#sym_cps.optimizers.tools.optimization.util.surrogate.SurrogateInterface.predict","text":"Access the model Source code in sym_cps/optimizers/tools/optimization/util/surrogate.py 14 15 16 @abstractmethod def predict ( self , x ): \"\"\"Access the model\"\"\"","title":"predict()"},{"location":"reference/sym_cps/optimizers/tools/optimization/util/visualize/","text":"visualize.py Define the class ContinuousDesignProblemVisualizer for visualing the continous optimization problem ContinuousProblemVisualizer \u00b6 Bases: object Used for visualizing the design problem and design space Source code in sym_cps/optimizers/tools/optimization/util/visualize.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 class ContinuousProblemVisualizer ( object ): \"\"\"Used for visualizing the design problem and design space\"\"\" def __init__ ( self , resolution : int = 100 ): self . _problem = None self . _res = resolution self . _x = None self . _y = None self . _xv = None self . _yv = None self . _f_gold = None self . _x_valid = None self . _dim = None @property def res ( self ) -> int : return self . _res @res . setter def res ( self , res ): self . _res = res def initialize_design_space ( self , problem : ProblemBase ): \"\"\"Plot the design space (Only apply to 1d or 2d design space)\"\"\" self . _problem = problem lbound = [ l_b for ( l_b , _ ) in problem . bounds ] ubound = [ u_b for ( _ , u_b ) in problem . bounds ] if self . _problem . dim == 1 : self . _dim = 1 self . _x = np . linspace ( lbound [ 0 ], ubound [ 0 ], self . res ) self . _f_gold = self . _get_F_1d ( self . _x ) # function value self . _x_valid = self . _get_valid_1d ( self . _x ) elif self . _problem . dim == 2 : self . _dim = 2 self . _x = np . linspace ( lbound [ 0 ], ubound [ 0 ], self . res ) self . _y = np . linspace ( lbound [ 1 ], ubound [ 1 ], self . res ) self . _xv , self . _yv = np . meshgrid ( self . _x , self . _y ) self . _f_gold = self . _get_F_2d ( self . _xv , self . _yv ) # function value self . _x_valid = self . _get_valid_2d ( self . _xv , self . _yv ) else : raise Exception ( \"Not supported for high dimension\" ) def _get_F_1d ( self , x_array : npt . ArrayLike ): \"\"\"Get all objectives in the design space\"\"\" problem_dim = self . _problem . obj_dim f_shape = ( * ( x_array . shape ), problem_dim ) # adding dimensions, each element becomes multiple objectives f_array = np . zeros ( f_shape ) for i , _x in enumerate ( x_array ): obj_vals , con_vals = self . _problem . evaluate ( np . array ([ _x ])) f_array [ i ] = obj_vals . flatten () return f_array def _get_F_2d ( self , xv_array : npt . ArrayLike , yv_array : npt . ArrayLike ): problem_dim = self . _problem . obj_dim f_shape = ( * ( xv_array . shape ), problem_dim ) # adding dimensions, each element becomes multiple objectives f_array = np . zeros ( f_shape ) for i in range ( xv_array . shape [ 0 ]): for j in range ( xv_array . shape [ 1 ]): obj_vals , con_vals = self . _problem . evaluate ( np . array ([ xv_array [ i , j ], yv_array [ i , j ]])) f_array [ i , j ] = obj_vals . flatten () return f_array def _get_valid_1d ( self , x_array : npt . ArrayLike ): \"\"\"Get all constraints in the design space\"\"\" constraint_dim = self . _problem . con_dim x_valid_shape = ( * ( x_array . shape ), constraint_dim ) # adding dimensions, each element becomes multiple objectives x_valid = np . zeros ( x_valid_shape ) for i , _x in enumerate ( x_array ): obj_vals , con_vals = self . _problem . evaluate ( np . array ([ _x ])) x_valid [ i ] = con_vals . flatten () return x_valid def _get_valid_2d ( self , xv_array : npt . ArrayLike , yv_array : npt . ArrayLike ): constraint_dim = self . _problem . con_dim x_valid_shape = ( * ( xv_array . shape ), constraint_dim ) # adding dimensions, each element becomes multiple objectives x_valid_array = np . zeros ( x_valid_shape ) for i in range ( xv_array . shape [ 0 ]): for j in range ( xv_array . shape [ 1 ]): obj_vals , con_vals = self . _problem . evaluate ( np . array ([ xv_array [ i , j ], yv_array [ i , j ]])) x_valid_array [ i , j ] = con_vals . flatten () return x_valid_array def plot_objectives ( self , show : bool = False , idx : int = None ): if self . _dim == 1 : self . _plot_objectives_1d ( idx = idx ) elif self . _dim == 2 : self . _plot_objectives_2d ( idx = idx ) else : raise Exception ( f \"Dimension ( { self . _dim } ) not supported!\" ) if show : self . plot_finalize () def plot_constraints ( self , show : bool = False , idx : int = None ): if self . _dim == 1 : self . _plot_constraints_1d ( idx = idx ) elif self . _dim == 2 : self . _plot_constraints_2d ( idx = idx ) else : raise Exception ( f \"Dimension ( { self . _dim } ) not supported!\" ) if show : self . plot_finalize () def plot_optimizer_hist_params_1d ( self , optimizer : OptimizerBase ): \"\"\"Plot the searched point of 1d\"\"\" hist = optimizer . hist p_hist = hist . hist_params f_hist = hist . hist_func plt . scatter ( p_hist , f_hist , color = cm . Greys ( np . linspace ( 0 , 1 , hist . length )), marker = 'x' ) plt . legend () def plot_optimizer_hist_params_2d ( self , optimizer : OptimizerBase ): \"\"\"Plot the searched point of 2d\"\"\" hist = optimizer . hist p_hist = hist . hist_params plt . scatter ( p_hist [:, 0 ], p_hist [:, 1 ], color = cm . Greys ( np . linspace ( 0 , 1 , hist . length )), marker = \"x\" ) #plt.legend() def plot_best_params_1d ( self , best_param , best_f ): plt . scatter ( best_param , best_f , c = \"cyan\" , marker = \"*\" , label = \"Best\" ) plt . legend () def plot_best_params_2d ( self , best_param ): plt . scatter ( best_param [ 0 ], best_param [ 1 ], c = \"cyan\" , marker = \"*\" , label = \"Best\" ) plt . legend () def plot_optimizer_convergence ( self , optimizer : OptimizerBase ): f_hist = optimizer . hist . hist_func v_hist = optimizer . hist . hist_valid f_best = float ( \"inf\" ) f_best_hist = np . zeros ( f_hist . shape ) for i , f in enumerate ( f_hist ): if f < f_best and v_hist [ i ]: f_best = f f_best_hist [ i ] = f_best plt . plot ( np . arange ( 1 , f_hist . shape [ 0 ] + 1 ), f_best_hist . flatten () - f_best , label = \"convergence\" ) plt . yscale ( \"log\" ) plt . legend () plt . title ( \"Convergence\" ) plt . show () # def plot_history_1d(self, hist_x: npt.ArrayLike, hist_f: npt.ArrayLike): # \"\"\"Plot the 1d history provided in the space\"\"\" # plt.plot(hist_x, hist_f, color=cm.Greys(np.linspace(0, 1, hist_x.shape[0])), marker='x', mew=3, label='samples') # def plot_history_2d(self, hist_x: npt.ArrayLike): # \"\"\"Plot the 2d history provided in the space\"\"\" # plt.scatter(hist_x[:, 0], hist_x[:, 1], color=cm.Greys(np.linspace(0, 1, hist_x.shape[0])), marker = \"x\") # def plot_best_point_1d(self, best_pos: npt.ArrayLike, best_val: float): # \"\"\"Plot the optimal point finded in the space\"\"\" # plt.scatter(best_pos, best_val, c = \"cyan\", marker=\"*\") # def plot_best_point_2d(self, best_pos: npt.ArrayLike): # \"\"\"Plot the optimal point finded in the space\"\"\" # plt.scatter(best_pos[0], best_pos[1], c = \"cyan\", marker=\"*\") def plot_finalize ( self ): plt . show () def _plot_objectives_1d ( self , idx : int = None ): if idx is None : for idx in range ( self . _f_gold . shape [ - 1 ]): plt . plot ( self . _x , self . _f_gold [:, idx ], 'y--' , lw = 1 , label = f 'objective { idx } ' ) else : plt . plot ( self . _x , self . _f_gold [:, idx ], 'y--' , lw = 1 , label = f 'objective { idx } ' ) plt . legend () def _plot_objectives_2d ( self , idx : int = None ): if idx is None : for idx in range ( self . _f_gold . shape [ - 1 ]): c = plt . pcolormesh ( self . _xv , self . _yv , self . _f_gold [ 1 :, 1 :, idx ], cmap = 'coolwarm' , shading = 'flat' , label = f 'objective { idx } ' ) plt . colorbar ( c ) else : c = plt . pcolormesh ( self . _xv , self . _yv , self . _f_gold [ 1 :, 1 :, idx ], cmap = 'coolwarm' , shading = 'flat' , label = f 'objective { idx } ' ) plt . colorbar ( c ) def _plot_constraints_1d ( self , idx : int = None ): if idx is None : for idx in range ( self . _x_valid . shape [ - 1 ]): plt . plot ( self . _x , self . _x_valid [:, idx ], 'y--' , lw = 1 , label = f 'constraint { idx } ' ) else : plt . plot ( self . _x , self . _x_valid [:, idx ], 'y--' , lw = 1 , label = f 'constraint { idx } ' ) plt . legend () def _plot_constraints_2d ( self , idx : int = None ): if idx is None : for idx in range ( self . _x_valid . shape [ - 1 ]): c = plt . pcolormesh ( self . _xv , self . _yv , self . _x_valid [ 1 :, 1 :, idx ], cmap = 'coolwarm' , shading = 'flat' , label = f 'constraint { idx } ' ) plt . colorbar ( c ) else : c = plt . pcolormesh ( self . _xv , self . _yv , self . _x_valid [ 1 :, 1 :, idx ], cmap = 'coolwarm' , shading = 'flat' , label = f 'constraint { idx } ' ) plt . colorbar ( c ) initialize_design_space ( problem ) \u00b6 Plot the design space (Only apply to 1d or 2d design space) Source code in sym_cps/optimizers/tools/optimization/util/visualize.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 def initialize_design_space ( self , problem : ProblemBase ): \"\"\"Plot the design space (Only apply to 1d or 2d design space)\"\"\" self . _problem = problem lbound = [ l_b for ( l_b , _ ) in problem . bounds ] ubound = [ u_b for ( _ , u_b ) in problem . bounds ] if self . _problem . dim == 1 : self . _dim = 1 self . _x = np . linspace ( lbound [ 0 ], ubound [ 0 ], self . res ) self . _f_gold = self . _get_F_1d ( self . _x ) # function value self . _x_valid = self . _get_valid_1d ( self . _x ) elif self . _problem . dim == 2 : self . _dim = 2 self . _x = np . linspace ( lbound [ 0 ], ubound [ 0 ], self . res ) self . _y = np . linspace ( lbound [ 1 ], ubound [ 1 ], self . res ) self . _xv , self . _yv = np . meshgrid ( self . _x , self . _y ) self . _f_gold = self . _get_F_2d ( self . _xv , self . _yv ) # function value self . _x_valid = self . _get_valid_2d ( self . _xv , self . _yv ) else : raise Exception ( \"Not supported for high dimension\" ) plot_optimizer_hist_params_1d ( optimizer ) \u00b6 Plot the searched point of 1d Source code in sym_cps/optimizers/tools/optimization/util/visualize.py 122 123 124 125 126 127 128 129 def plot_optimizer_hist_params_1d ( self , optimizer : OptimizerBase ): \"\"\"Plot the searched point of 1d\"\"\" hist = optimizer . hist p_hist = hist . hist_params f_hist = hist . hist_func plt . scatter ( p_hist , f_hist , color = cm . Greys ( np . linspace ( 0 , 1 , hist . length )), marker = 'x' ) plt . legend () plot_optimizer_hist_params_2d ( optimizer ) \u00b6 Plot the searched point of 2d Source code in sym_cps/optimizers/tools/optimization/util/visualize.py 131 132 133 134 135 136 def plot_optimizer_hist_params_2d ( self , optimizer : OptimizerBase ): \"\"\"Plot the searched point of 2d\"\"\" hist = optimizer . hist p_hist = hist . hist_params plt . scatter ( p_hist [:, 0 ], p_hist [:, 1 ], color = cm . Greys ( np . linspace ( 0 , 1 , hist . length )), marker = \"x\" )","title":"visualize"},{"location":"reference/sym_cps/optimizers/tools/optimization/util/visualize/#sym_cps.optimizers.tools.optimization.util.visualize.ContinuousProblemVisualizer","text":"Bases: object Used for visualizing the design problem and design space Source code in sym_cps/optimizers/tools/optimization/util/visualize.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 class ContinuousProblemVisualizer ( object ): \"\"\"Used for visualizing the design problem and design space\"\"\" def __init__ ( self , resolution : int = 100 ): self . _problem = None self . _res = resolution self . _x = None self . _y = None self . _xv = None self . _yv = None self . _f_gold = None self . _x_valid = None self . _dim = None @property def res ( self ) -> int : return self . _res @res . setter def res ( self , res ): self . _res = res def initialize_design_space ( self , problem : ProblemBase ): \"\"\"Plot the design space (Only apply to 1d or 2d design space)\"\"\" self . _problem = problem lbound = [ l_b for ( l_b , _ ) in problem . bounds ] ubound = [ u_b for ( _ , u_b ) in problem . bounds ] if self . _problem . dim == 1 : self . _dim = 1 self . _x = np . linspace ( lbound [ 0 ], ubound [ 0 ], self . res ) self . _f_gold = self . _get_F_1d ( self . _x ) # function value self . _x_valid = self . _get_valid_1d ( self . _x ) elif self . _problem . dim == 2 : self . _dim = 2 self . _x = np . linspace ( lbound [ 0 ], ubound [ 0 ], self . res ) self . _y = np . linspace ( lbound [ 1 ], ubound [ 1 ], self . res ) self . _xv , self . _yv = np . meshgrid ( self . _x , self . _y ) self . _f_gold = self . _get_F_2d ( self . _xv , self . _yv ) # function value self . _x_valid = self . _get_valid_2d ( self . _xv , self . _yv ) else : raise Exception ( \"Not supported for high dimension\" ) def _get_F_1d ( self , x_array : npt . ArrayLike ): \"\"\"Get all objectives in the design space\"\"\" problem_dim = self . _problem . obj_dim f_shape = ( * ( x_array . shape ), problem_dim ) # adding dimensions, each element becomes multiple objectives f_array = np . zeros ( f_shape ) for i , _x in enumerate ( x_array ): obj_vals , con_vals = self . _problem . evaluate ( np . array ([ _x ])) f_array [ i ] = obj_vals . flatten () return f_array def _get_F_2d ( self , xv_array : npt . ArrayLike , yv_array : npt . ArrayLike ): problem_dim = self . _problem . obj_dim f_shape = ( * ( xv_array . shape ), problem_dim ) # adding dimensions, each element becomes multiple objectives f_array = np . zeros ( f_shape ) for i in range ( xv_array . shape [ 0 ]): for j in range ( xv_array . shape [ 1 ]): obj_vals , con_vals = self . _problem . evaluate ( np . array ([ xv_array [ i , j ], yv_array [ i , j ]])) f_array [ i , j ] = obj_vals . flatten () return f_array def _get_valid_1d ( self , x_array : npt . ArrayLike ): \"\"\"Get all constraints in the design space\"\"\" constraint_dim = self . _problem . con_dim x_valid_shape = ( * ( x_array . shape ), constraint_dim ) # adding dimensions, each element becomes multiple objectives x_valid = np . zeros ( x_valid_shape ) for i , _x in enumerate ( x_array ): obj_vals , con_vals = self . _problem . evaluate ( np . array ([ _x ])) x_valid [ i ] = con_vals . flatten () return x_valid def _get_valid_2d ( self , xv_array : npt . ArrayLike , yv_array : npt . ArrayLike ): constraint_dim = self . _problem . con_dim x_valid_shape = ( * ( xv_array . shape ), constraint_dim ) # adding dimensions, each element becomes multiple objectives x_valid_array = np . zeros ( x_valid_shape ) for i in range ( xv_array . shape [ 0 ]): for j in range ( xv_array . shape [ 1 ]): obj_vals , con_vals = self . _problem . evaluate ( np . array ([ xv_array [ i , j ], yv_array [ i , j ]])) x_valid_array [ i , j ] = con_vals . flatten () return x_valid_array def plot_objectives ( self , show : bool = False , idx : int = None ): if self . _dim == 1 : self . _plot_objectives_1d ( idx = idx ) elif self . _dim == 2 : self . _plot_objectives_2d ( idx = idx ) else : raise Exception ( f \"Dimension ( { self . _dim } ) not supported!\" ) if show : self . plot_finalize () def plot_constraints ( self , show : bool = False , idx : int = None ): if self . _dim == 1 : self . _plot_constraints_1d ( idx = idx ) elif self . _dim == 2 : self . _plot_constraints_2d ( idx = idx ) else : raise Exception ( f \"Dimension ( { self . _dim } ) not supported!\" ) if show : self . plot_finalize () def plot_optimizer_hist_params_1d ( self , optimizer : OptimizerBase ): \"\"\"Plot the searched point of 1d\"\"\" hist = optimizer . hist p_hist = hist . hist_params f_hist = hist . hist_func plt . scatter ( p_hist , f_hist , color = cm . Greys ( np . linspace ( 0 , 1 , hist . length )), marker = 'x' ) plt . legend () def plot_optimizer_hist_params_2d ( self , optimizer : OptimizerBase ): \"\"\"Plot the searched point of 2d\"\"\" hist = optimizer . hist p_hist = hist . hist_params plt . scatter ( p_hist [:, 0 ], p_hist [:, 1 ], color = cm . Greys ( np . linspace ( 0 , 1 , hist . length )), marker = \"x\" ) #plt.legend() def plot_best_params_1d ( self , best_param , best_f ): plt . scatter ( best_param , best_f , c = \"cyan\" , marker = \"*\" , label = \"Best\" ) plt . legend () def plot_best_params_2d ( self , best_param ): plt . scatter ( best_param [ 0 ], best_param [ 1 ], c = \"cyan\" , marker = \"*\" , label = \"Best\" ) plt . legend () def plot_optimizer_convergence ( self , optimizer : OptimizerBase ): f_hist = optimizer . hist . hist_func v_hist = optimizer . hist . hist_valid f_best = float ( \"inf\" ) f_best_hist = np . zeros ( f_hist . shape ) for i , f in enumerate ( f_hist ): if f < f_best and v_hist [ i ]: f_best = f f_best_hist [ i ] = f_best plt . plot ( np . arange ( 1 , f_hist . shape [ 0 ] + 1 ), f_best_hist . flatten () - f_best , label = \"convergence\" ) plt . yscale ( \"log\" ) plt . legend () plt . title ( \"Convergence\" ) plt . show () # def plot_history_1d(self, hist_x: npt.ArrayLike, hist_f: npt.ArrayLike): # \"\"\"Plot the 1d history provided in the space\"\"\" # plt.plot(hist_x, hist_f, color=cm.Greys(np.linspace(0, 1, hist_x.shape[0])), marker='x', mew=3, label='samples') # def plot_history_2d(self, hist_x: npt.ArrayLike): # \"\"\"Plot the 2d history provided in the space\"\"\" # plt.scatter(hist_x[:, 0], hist_x[:, 1], color=cm.Greys(np.linspace(0, 1, hist_x.shape[0])), marker = \"x\") # def plot_best_point_1d(self, best_pos: npt.ArrayLike, best_val: float): # \"\"\"Plot the optimal point finded in the space\"\"\" # plt.scatter(best_pos, best_val, c = \"cyan\", marker=\"*\") # def plot_best_point_2d(self, best_pos: npt.ArrayLike): # \"\"\"Plot the optimal point finded in the space\"\"\" # plt.scatter(best_pos[0], best_pos[1], c = \"cyan\", marker=\"*\") def plot_finalize ( self ): plt . show () def _plot_objectives_1d ( self , idx : int = None ): if idx is None : for idx in range ( self . _f_gold . shape [ - 1 ]): plt . plot ( self . _x , self . _f_gold [:, idx ], 'y--' , lw = 1 , label = f 'objective { idx } ' ) else : plt . plot ( self . _x , self . _f_gold [:, idx ], 'y--' , lw = 1 , label = f 'objective { idx } ' ) plt . legend () def _plot_objectives_2d ( self , idx : int = None ): if idx is None : for idx in range ( self . _f_gold . shape [ - 1 ]): c = plt . pcolormesh ( self . _xv , self . _yv , self . _f_gold [ 1 :, 1 :, idx ], cmap = 'coolwarm' , shading = 'flat' , label = f 'objective { idx } ' ) plt . colorbar ( c ) else : c = plt . pcolormesh ( self . _xv , self . _yv , self . _f_gold [ 1 :, 1 :, idx ], cmap = 'coolwarm' , shading = 'flat' , label = f 'objective { idx } ' ) plt . colorbar ( c ) def _plot_constraints_1d ( self , idx : int = None ): if idx is None : for idx in range ( self . _x_valid . shape [ - 1 ]): plt . plot ( self . _x , self . _x_valid [:, idx ], 'y--' , lw = 1 , label = f 'constraint { idx } ' ) else : plt . plot ( self . _x , self . _x_valid [:, idx ], 'y--' , lw = 1 , label = f 'constraint { idx } ' ) plt . legend () def _plot_constraints_2d ( self , idx : int = None ): if idx is None : for idx in range ( self . _x_valid . shape [ - 1 ]): c = plt . pcolormesh ( self . _xv , self . _yv , self . _x_valid [ 1 :, 1 :, idx ], cmap = 'coolwarm' , shading = 'flat' , label = f 'constraint { idx } ' ) plt . colorbar ( c ) else : c = plt . pcolormesh ( self . _xv , self . _yv , self . _x_valid [ 1 :, 1 :, idx ], cmap = 'coolwarm' , shading = 'flat' , label = f 'constraint { idx } ' ) plt . colorbar ( c )","title":"ContinuousProblemVisualizer"},{"location":"reference/sym_cps/optimizers/tools/optimization/util/visualize/#sym_cps.optimizers.tools.optimization.util.visualize.ContinuousProblemVisualizer.initialize_design_space","text":"Plot the design space (Only apply to 1d or 2d design space) Source code in sym_cps/optimizers/tools/optimization/util/visualize.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 def initialize_design_space ( self , problem : ProblemBase ): \"\"\"Plot the design space (Only apply to 1d or 2d design space)\"\"\" self . _problem = problem lbound = [ l_b for ( l_b , _ ) in problem . bounds ] ubound = [ u_b for ( _ , u_b ) in problem . bounds ] if self . _problem . dim == 1 : self . _dim = 1 self . _x = np . linspace ( lbound [ 0 ], ubound [ 0 ], self . res ) self . _f_gold = self . _get_F_1d ( self . _x ) # function value self . _x_valid = self . _get_valid_1d ( self . _x ) elif self . _problem . dim == 2 : self . _dim = 2 self . _x = np . linspace ( lbound [ 0 ], ubound [ 0 ], self . res ) self . _y = np . linspace ( lbound [ 1 ], ubound [ 1 ], self . res ) self . _xv , self . _yv = np . meshgrid ( self . _x , self . _y ) self . _f_gold = self . _get_F_2d ( self . _xv , self . _yv ) # function value self . _x_valid = self . _get_valid_2d ( self . _xv , self . _yv ) else : raise Exception ( \"Not supported for high dimension\" )","title":"initialize_design_space()"},{"location":"reference/sym_cps/optimizers/tools/optimization/util/visualize/#sym_cps.optimizers.tools.optimization.util.visualize.ContinuousProblemVisualizer.plot_optimizer_hist_params_1d","text":"Plot the searched point of 1d Source code in sym_cps/optimizers/tools/optimization/util/visualize.py 122 123 124 125 126 127 128 129 def plot_optimizer_hist_params_1d ( self , optimizer : OptimizerBase ): \"\"\"Plot the searched point of 1d\"\"\" hist = optimizer . hist p_hist = hist . hist_params f_hist = hist . hist_func plt . scatter ( p_hist , f_hist , color = cm . Greys ( np . linspace ( 0 , 1 , hist . length )), marker = 'x' ) plt . legend ()","title":"plot_optimizer_hist_params_1d()"},{"location":"reference/sym_cps/optimizers/tools/optimization/util/visualize/#sym_cps.optimizers.tools.optimization.util.visualize.ContinuousProblemVisualizer.plot_optimizer_hist_params_2d","text":"Plot the searched point of 2d Source code in sym_cps/optimizers/tools/optimization/util/visualize.py 131 132 133 134 135 136 def plot_optimizer_hist_params_2d ( self , optimizer : OptimizerBase ): \"\"\"Plot the searched point of 2d\"\"\" hist = optimizer . hist p_hist = hist . hist_params plt . scatter ( p_hist [:, 0 ], p_hist [:, 1 ], color = cm . Greys ( np . linspace ( 0 , 1 , hist . length )), marker = \"x\" )","title":"plot_optimizer_hist_params_2d()"},{"location":"reference/sym_cps/optimizers/topo_opt/","text":"","title":"topo_opt"},{"location":"reference/sym_cps/representation/","text":"","title":"representation"},{"location":"reference/sym_cps/representation/design/","text":"","title":"design"},{"location":"reference/sym_cps/representation/design/concrete/","text":"Test Documentation DConcrete dataclass \u00b6 A class representing a Concrete Design ... Attributes \u00b6 str name of the design dict[str, DesignParameter] design parameters Source code in sym_cps/representation/design/concrete/__init__.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 @dataclass class DConcrete : \"\"\" A class representing a Concrete Design ... Attributes ---------- name : str name of the design design_parameters : dict[str, DesignParameter] design parameters \"\"\" name : str design_parameters : dict [ str , DesignParameter ] = field ( default_factory = dict ) def __post_init__ ( self ): self . _graph = Graph () @property def graph ( self ) -> Graph : return self . _graph @property def nodes ( self ) -> list [ igraph . Vertex ]: return list ( self . graph . vs ) @property def edges ( self ) -> list [ igraph . Edge ]: return list ( self . graph . es ) def get_vertex_by_id ( self , vid : int ) -> igraph . Vertex : return self . graph . vs [ vid ] @property def n_nodes ( self ) -> int : return len ( self . graph . vs ) @property def n_edges ( self ) -> int : return len ( self . graph . es ) def add_node ( self , component : Component ) -> igraph . Vertex : return self . graph . add_vertex ( instance = component . id , library_component = component . library_component , c_type = component . c_type , component = component , ) def remove_node ( self ): \"\"\"TODO\"\"\" raise NotImplementedError def add_edge ( self , node_id_a : int , node_id_b : int , connection : Connection ): self . graph . add_edge ( source = node_id_a , target = node_id_b , connection = connection ) def connect ( self , connection : Connection ): a = self . get_node_by_instance ( connection . component_a . id ) . index b = self . get_node_by_instance ( connection . component_b . id ) . index self . add_edge ( a , b , connection ) def remove_edge ( self ): \"\"\"TODO. Tip: self.graph.delete_edges\"\"\" raise NotImplementedError def disconnect ( self , connection : Connection ): \"\"\"TODO. Might want to remove a Connection, retrieve the node_id from the Connection\"\"\" raise NotImplementedError @property def components ( self ) -> set [ Component | None ]: if self . n_nodes > 0 : return set ( self . graph . vs ()[ \"component\" ]) return set () @property def connections ( self ) -> set [ Connection | None ]: if self . n_nodes > 0 : if self . n_edges > 0 : return set ( self . graph . es ()[ \"connection\" ]) return set () def get_node_by_instance ( self , instance : str ) -> igraph . Vertex | None : if self . n_nodes > 0 : nodes = self . graph . vs . select ( instance = instance ) if len ( nodes ) == 1 : return nodes [ 0 ] return None def get_instance ( self , instance : str ) -> Component | None : if self . n_nodes > 0 : nodes = self . graph . vs . select ( instance = instance ) if len ( nodes ) == 1 : return nodes [ \"component\" ][ 0 ] return None def select ( self , library_component : LibraryComponent | None = None , component_type : CType | None = None , ) -> set [ Component ]: components = set () if library_component is not None : return set ( self . graph . vs . select ( library_component = library_component )[ \"component\" ] ) if component_type is not None : return set ( self . graph . vs . select ( component_type = component_type )[ \"component\" ]) return components @property def all_library_components_component_class ( self , ) -> dict [ CType , set [ LibraryComponent ]]: \"\"\"Returns all LibraryComponent for each Component class in the design\"\"\" comp_types_n : dict [ CType , set [ LibraryComponent ]] = {} for component in self . components : if component . c_type in comp_types_n . keys (): comp_types_n [ component . c_type ] . add ( component . library_component ) else : comp_types_n [ component . c_type ] = { component . library_component } return comp_types_n @property def all_components_by_library_components ( self , ) -> dict [ LibraryComponent , set [ Component ]]: \"\"\"Returns all Components for each LibraryComponent in the design\"\"\" comp_types_n : dict [ LibraryComponent , set [ Component ]] = {} for component in self . components : if component . library_component in comp_types_n . keys (): comp_types_n [ component . library_component ] . add ( component ) else : comp_types_n [ component . library_component ] = { component } return comp_types_n def validate ( self ): \"\"\"Validates the Parameters of the Design\"\"\" raise NotImplementedError def evaluate ( self ): \"\"\"Sends the Design for evaluation\"\"\" raise NotImplementedError def evaluation ( self , evaluation_results_json : str ): \"\"\"Parse and update the evaluation of the Design\"\"\" raise NotImplementedError def export_to_cad ( self ): \"\"\"Generates a CAD representation of the Design\"\"\" raise NotImplementedError @property def to_design_swri ( self ) -> dict [ str , str ]: \"\"\"Generate design_swri.json format file from a concrete design design: the concrete design exporting to design_swri.json file output_path: file path for the export file. \"\"\" design_swri_data = {} \"\"\" Storing the design name\"\"\" design_swri_data [ \"name\" ] = self . name \"\"\"Storing parameters\"\"\" data_parameters : list = [] for component in self . components : for parameter_id , parameter in component . parameters . items (): data_parameters . append ( { \"parameter_name\" : f \" { component . id } _ { parameter . c_parameter . name } \" , \"value\" : str ( int ( parameter . value )), \"component_properties\" : [ { \"component_name\" : component . id , \"component_property\" : parameter . c_parameter . name , } ], } ) design_swri_data [ \"parameters\" ] = data_parameters \"\"\"Storing components\"\"\" data_components : list [ dict [ str , str ]] = [] for component in self . components : data_components . append ( { \"component_instance\" : component . id , \"component_type\" : component . c_type . id , \"component_choice\" : component . model , } ) design_swri_data [ \"components\" ] = data_components \"\"\"Storing connections\"\"\" data_connections : list [ dict [ str , str ]] = [] for connection in self . connections : data_connections . append ( { \"from_ci\" : connection . component_a . id , \"from_conn\" : connection . connector_a . name , \"to_ci\" : connection . component_b . id , \"to_conn\" : connection . connector_b . name , } ) data_connections . append ( { \"from_ci\" : connection . component_b . id , \"from_conn\" : connection . connector_b . name , \"to_ci\" : connection . component_a . id , \"to_conn\" : connection . connector_a . name , } ) design_swri_data [ \"connections\" ] = data_connections return design_swri_data def export ( self , file_type : ExportType ): absolute_folder = designs_folder / self . name if file_type == ExportType . TXT : save_to_file ( str ( self ), file_name = f \"DTopology\" , absolute_folder_path = absolute_folder , ) elif file_type == ExportType . JSON : save_to_file ( str ( json . dumps ( self . to_design_swri )), file_name = f \"design_swri.json\" , absolute_folder_path = absolute_folder , ) elif file_type == ExportType . DOT : self . graph . write_dot ( f = str ( absolute_folder / \"concrete_graph.dot\" )) elif file_type == ExportType . PDF : if self . n_nodes > 0 : layout = self . graph . layout ( \"kk\" ) \"\"\"Adding labels to nodes\"\"\" self . graph . vs [ \"label\" ] = self . graph . vs [ \"c_type\" ] fig , ax = plt . subplots () plot ( self . graph , layout = layout , target = ax ) plt . savefig ( absolute_folder / \"concrete_graph.pdf\" ) else : raise Exception ( \"File type not supported\" ) print ( f \" { file_type } file saved in { absolute_folder } \" ) def draw ( self , name ): if self . n_nodes > 0 : layout = self . graph . layout ( \"kk\" ) fig , ax = plt . subplots () plot ( self . graph , layout = layout , target = ax ) file_name_path = output_folder / \"graphs\" / name plt . savefig ( f \" { file_name_path } .pdf\" ) def __eq__ ( self , other : object ): pass def __ne__ ( self , other : object ): if not isinstance ( other , DConcrete ): return NotImplementedError return not self . __eq__ ( other ) def __str__ ( self ): n_library_component_by_class = [] for k , v in self . all_library_components_component_class . items (): n_library_component_by_class . append ( f \" \\t { k } : { len ( v ) } \" ) n_library_component_by_class_str = \" \\n \" . join ( n_library_component_by_class ) components_list = [] for ( components_class , library_components , ) in self . all_library_components_component_class . items (): components_list . append ( tab ( f \"COMPONENT type: { components_class } \" )) for library_component in library_components : components_list . append ( tab ( tab ( f \"LIBRARY COMPONENT: { library_component . id } \" )) ) components = self . select ( library_component = library_component ) for component in components : components_list . append ( tab ( tab ( tab ( f \"COMPONENT: { component . id } \" )))) components_list . append ( tab ( tab ( tab ( component )))) components_list . append ( \" \\n\\t +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\" ) connection_list = [] for connection in self . connections : connection_list . append ( str ( connection )) components_str = \" \\n \" . join ( components_list ) connection_str = \" \\n \" . join ( connection_list ) s1 = ( f \"name: { self . name } \\n \" f \"#_components: { len ( self . components ) } \\n \" f \"#_connections: { len ( self . connections ) } \\n \" f \"#_component_classes: \\n { n_library_component_by_class_str } \\n \" f \" \\n\\n connections: \\n { connection_str } \\n \" f \" \\n\\n components: \\n { components_str } \\n \" ) return s1 all_components_by_library_components () property \u00b6 Returns all Components for each LibraryComponent in the design Source code in sym_cps/representation/design/concrete/__init__.py 148 149 150 151 152 153 154 155 156 157 158 159 @property def all_components_by_library_components ( self , ) -> dict [ LibraryComponent , set [ Component ]]: \"\"\"Returns all Components for each LibraryComponent in the design\"\"\" comp_types_n : dict [ LibraryComponent , set [ Component ]] = {} for component in self . components : if component . library_component in comp_types_n . keys (): comp_types_n [ component . library_component ] . add ( component ) else : comp_types_n [ component . library_component ] = { component } return comp_types_n all_library_components_component_class () property \u00b6 Returns all LibraryComponent for each Component class in the design Source code in sym_cps/representation/design/concrete/__init__.py 135 136 137 138 139 140 141 142 143 144 145 146 @property def all_library_components_component_class ( self , ) -> dict [ CType , set [ LibraryComponent ]]: \"\"\"Returns all LibraryComponent for each Component class in the design\"\"\" comp_types_n : dict [ CType , set [ LibraryComponent ]] = {} for component in self . components : if component . c_type in comp_types_n . keys (): comp_types_n [ component . c_type ] . add ( component . library_component ) else : comp_types_n [ component . c_type ] = { component . library_component } return comp_types_n disconnect ( connection ) \u00b6 TODO. Might want to remove a Connection, retrieve the node_id from the Connection Source code in sym_cps/representation/design/concrete/__init__.py 90 91 92 def disconnect ( self , connection : Connection ): \"\"\"TODO. Might want to remove a Connection, retrieve the node_id from the Connection\"\"\" raise NotImplementedError evaluate () \u00b6 Sends the Design for evaluation Source code in sym_cps/representation/design/concrete/__init__.py 165 166 167 def evaluate ( self ): \"\"\"Sends the Design for evaluation\"\"\" raise NotImplementedError evaluation ( evaluation_results_json ) \u00b6 Parse and update the evaluation of the Design Source code in sym_cps/representation/design/concrete/__init__.py 169 170 171 def evaluation ( self , evaluation_results_json : str ): \"\"\"Parse and update the evaluation of the Design\"\"\" raise NotImplementedError export_to_cad () \u00b6 Generates a CAD representation of the Design Source code in sym_cps/representation/design/concrete/__init__.py 173 174 175 def export_to_cad ( self ): \"\"\"Generates a CAD representation of the Design\"\"\" raise NotImplementedError remove_edge () \u00b6 TODO. Tip: self.graph.delete_edges Source code in sym_cps/representation/design/concrete/__init__.py 86 87 88 def remove_edge ( self ): \"\"\"TODO. Tip: self.graph.delete_edges\"\"\" raise NotImplementedError remove_node () \u00b6 TODO Source code in sym_cps/representation/design/concrete/__init__.py 74 75 76 def remove_node ( self ): \"\"\"TODO\"\"\" raise NotImplementedError to_design_swri () property \u00b6 Generate design_swri.json format file from a concrete design design: the concrete design exporting to design_swri.json file output_path: file path for the export file. Source code in sym_cps/representation/design/concrete/__init__.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 @property def to_design_swri ( self ) -> dict [ str , str ]: \"\"\"Generate design_swri.json format file from a concrete design design: the concrete design exporting to design_swri.json file output_path: file path for the export file. \"\"\" design_swri_data = {} \"\"\" Storing the design name\"\"\" design_swri_data [ \"name\" ] = self . name \"\"\"Storing parameters\"\"\" data_parameters : list = [] for component in self . components : for parameter_id , parameter in component . parameters . items (): data_parameters . append ( { \"parameter_name\" : f \" { component . id } _ { parameter . c_parameter . name } \" , \"value\" : str ( int ( parameter . value )), \"component_properties\" : [ { \"component_name\" : component . id , \"component_property\" : parameter . c_parameter . name , } ], } ) design_swri_data [ \"parameters\" ] = data_parameters \"\"\"Storing components\"\"\" data_components : list [ dict [ str , str ]] = [] for component in self . components : data_components . append ( { \"component_instance\" : component . id , \"component_type\" : component . c_type . id , \"component_choice\" : component . model , } ) design_swri_data [ \"components\" ] = data_components \"\"\"Storing connections\"\"\" data_connections : list [ dict [ str , str ]] = [] for connection in self . connections : data_connections . append ( { \"from_ci\" : connection . component_a . id , \"from_conn\" : connection . connector_a . name , \"to_ci\" : connection . component_b . id , \"to_conn\" : connection . connector_b . name , } ) data_connections . append ( { \"from_ci\" : connection . component_b . id , \"from_conn\" : connection . connector_b . name , \"to_ci\" : connection . component_a . id , \"to_conn\" : connection . connector_a . name , } ) design_swri_data [ \"connections\" ] = data_connections return design_swri_data validate () \u00b6 Validates the Parameters of the Design Source code in sym_cps/representation/design/concrete/__init__.py 161 162 163 def validate ( self ): \"\"\"Validates the Parameters of the Design\"\"\" raise NotImplementedError","title":"concrete"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete","text":"A class representing a Concrete Design ...","title":"DConcrete"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete--attributes","text":"str name of the design dict[str, DesignParameter] design parameters Source code in sym_cps/representation/design/concrete/__init__.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 @dataclass class DConcrete : \"\"\" A class representing a Concrete Design ... Attributes ---------- name : str name of the design design_parameters : dict[str, DesignParameter] design parameters \"\"\" name : str design_parameters : dict [ str , DesignParameter ] = field ( default_factory = dict ) def __post_init__ ( self ): self . _graph = Graph () @property def graph ( self ) -> Graph : return self . _graph @property def nodes ( self ) -> list [ igraph . Vertex ]: return list ( self . graph . vs ) @property def edges ( self ) -> list [ igraph . Edge ]: return list ( self . graph . es ) def get_vertex_by_id ( self , vid : int ) -> igraph . Vertex : return self . graph . vs [ vid ] @property def n_nodes ( self ) -> int : return len ( self . graph . vs ) @property def n_edges ( self ) -> int : return len ( self . graph . es ) def add_node ( self , component : Component ) -> igraph . Vertex : return self . graph . add_vertex ( instance = component . id , library_component = component . library_component , c_type = component . c_type , component = component , ) def remove_node ( self ): \"\"\"TODO\"\"\" raise NotImplementedError def add_edge ( self , node_id_a : int , node_id_b : int , connection : Connection ): self . graph . add_edge ( source = node_id_a , target = node_id_b , connection = connection ) def connect ( self , connection : Connection ): a = self . get_node_by_instance ( connection . component_a . id ) . index b = self . get_node_by_instance ( connection . component_b . id ) . index self . add_edge ( a , b , connection ) def remove_edge ( self ): \"\"\"TODO. Tip: self.graph.delete_edges\"\"\" raise NotImplementedError def disconnect ( self , connection : Connection ): \"\"\"TODO. Might want to remove a Connection, retrieve the node_id from the Connection\"\"\" raise NotImplementedError @property def components ( self ) -> set [ Component | None ]: if self . n_nodes > 0 : return set ( self . graph . vs ()[ \"component\" ]) return set () @property def connections ( self ) -> set [ Connection | None ]: if self . n_nodes > 0 : if self . n_edges > 0 : return set ( self . graph . es ()[ \"connection\" ]) return set () def get_node_by_instance ( self , instance : str ) -> igraph . Vertex | None : if self . n_nodes > 0 : nodes = self . graph . vs . select ( instance = instance ) if len ( nodes ) == 1 : return nodes [ 0 ] return None def get_instance ( self , instance : str ) -> Component | None : if self . n_nodes > 0 : nodes = self . graph . vs . select ( instance = instance ) if len ( nodes ) == 1 : return nodes [ \"component\" ][ 0 ] return None def select ( self , library_component : LibraryComponent | None = None , component_type : CType | None = None , ) -> set [ Component ]: components = set () if library_component is not None : return set ( self . graph . vs . select ( library_component = library_component )[ \"component\" ] ) if component_type is not None : return set ( self . graph . vs . select ( component_type = component_type )[ \"component\" ]) return components @property def all_library_components_component_class ( self , ) -> dict [ CType , set [ LibraryComponent ]]: \"\"\"Returns all LibraryComponent for each Component class in the design\"\"\" comp_types_n : dict [ CType , set [ LibraryComponent ]] = {} for component in self . components : if component . c_type in comp_types_n . keys (): comp_types_n [ component . c_type ] . add ( component . library_component ) else : comp_types_n [ component . c_type ] = { component . library_component } return comp_types_n @property def all_components_by_library_components ( self , ) -> dict [ LibraryComponent , set [ Component ]]: \"\"\"Returns all Components for each LibraryComponent in the design\"\"\" comp_types_n : dict [ LibraryComponent , set [ Component ]] = {} for component in self . components : if component . library_component in comp_types_n . keys (): comp_types_n [ component . library_component ] . add ( component ) else : comp_types_n [ component . library_component ] = { component } return comp_types_n def validate ( self ): \"\"\"Validates the Parameters of the Design\"\"\" raise NotImplementedError def evaluate ( self ): \"\"\"Sends the Design for evaluation\"\"\" raise NotImplementedError def evaluation ( self , evaluation_results_json : str ): \"\"\"Parse and update the evaluation of the Design\"\"\" raise NotImplementedError def export_to_cad ( self ): \"\"\"Generates a CAD representation of the Design\"\"\" raise NotImplementedError @property def to_design_swri ( self ) -> dict [ str , str ]: \"\"\"Generate design_swri.json format file from a concrete design design: the concrete design exporting to design_swri.json file output_path: file path for the export file. \"\"\" design_swri_data = {} \"\"\" Storing the design name\"\"\" design_swri_data [ \"name\" ] = self . name \"\"\"Storing parameters\"\"\" data_parameters : list = [] for component in self . components : for parameter_id , parameter in component . parameters . items (): data_parameters . append ( { \"parameter_name\" : f \" { component . id } _ { parameter . c_parameter . name } \" , \"value\" : str ( int ( parameter . value )), \"component_properties\" : [ { \"component_name\" : component . id , \"component_property\" : parameter . c_parameter . name , } ], } ) design_swri_data [ \"parameters\" ] = data_parameters \"\"\"Storing components\"\"\" data_components : list [ dict [ str , str ]] = [] for component in self . components : data_components . append ( { \"component_instance\" : component . id , \"component_type\" : component . c_type . id , \"component_choice\" : component . model , } ) design_swri_data [ \"components\" ] = data_components \"\"\"Storing connections\"\"\" data_connections : list [ dict [ str , str ]] = [] for connection in self . connections : data_connections . append ( { \"from_ci\" : connection . component_a . id , \"from_conn\" : connection . connector_a . name , \"to_ci\" : connection . component_b . id , \"to_conn\" : connection . connector_b . name , } ) data_connections . append ( { \"from_ci\" : connection . component_b . id , \"from_conn\" : connection . connector_b . name , \"to_ci\" : connection . component_a . id , \"to_conn\" : connection . connector_a . name , } ) design_swri_data [ \"connections\" ] = data_connections return design_swri_data def export ( self , file_type : ExportType ): absolute_folder = designs_folder / self . name if file_type == ExportType . TXT : save_to_file ( str ( self ), file_name = f \"DTopology\" , absolute_folder_path = absolute_folder , ) elif file_type == ExportType . JSON : save_to_file ( str ( json . dumps ( self . to_design_swri )), file_name = f \"design_swri.json\" , absolute_folder_path = absolute_folder , ) elif file_type == ExportType . DOT : self . graph . write_dot ( f = str ( absolute_folder / \"concrete_graph.dot\" )) elif file_type == ExportType . PDF : if self . n_nodes > 0 : layout = self . graph . layout ( \"kk\" ) \"\"\"Adding labels to nodes\"\"\" self . graph . vs [ \"label\" ] = self . graph . vs [ \"c_type\" ] fig , ax = plt . subplots () plot ( self . graph , layout = layout , target = ax ) plt . savefig ( absolute_folder / \"concrete_graph.pdf\" ) else : raise Exception ( \"File type not supported\" ) print ( f \" { file_type } file saved in { absolute_folder } \" ) def draw ( self , name ): if self . n_nodes > 0 : layout = self . graph . layout ( \"kk\" ) fig , ax = plt . subplots () plot ( self . graph , layout = layout , target = ax ) file_name_path = output_folder / \"graphs\" / name plt . savefig ( f \" { file_name_path } .pdf\" ) def __eq__ ( self , other : object ): pass def __ne__ ( self , other : object ): if not isinstance ( other , DConcrete ): return NotImplementedError return not self . __eq__ ( other ) def __str__ ( self ): n_library_component_by_class = [] for k , v in self . all_library_components_component_class . items (): n_library_component_by_class . append ( f \" \\t { k } : { len ( v ) } \" ) n_library_component_by_class_str = \" \\n \" . join ( n_library_component_by_class ) components_list = [] for ( components_class , library_components , ) in self . all_library_components_component_class . items (): components_list . append ( tab ( f \"COMPONENT type: { components_class } \" )) for library_component in library_components : components_list . append ( tab ( tab ( f \"LIBRARY COMPONENT: { library_component . id } \" )) ) components = self . select ( library_component = library_component ) for component in components : components_list . append ( tab ( tab ( tab ( f \"COMPONENT: { component . id } \" )))) components_list . append ( tab ( tab ( tab ( component )))) components_list . append ( \" \\n\\t +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\" ) connection_list = [] for connection in self . connections : connection_list . append ( str ( connection )) components_str = \" \\n \" . join ( components_list ) connection_str = \" \\n \" . join ( connection_list ) s1 = ( f \"name: { self . name } \\n \" f \"#_components: { len ( self . components ) } \\n \" f \"#_connections: { len ( self . connections ) } \\n \" f \"#_component_classes: \\n { n_library_component_by_class_str } \\n \" f \" \\n\\n connections: \\n { connection_str } \\n \" f \" \\n\\n components: \\n { components_str } \\n \" ) return s1","title":"Attributes"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.all_components_by_library_components","text":"Returns all Components for each LibraryComponent in the design Source code in sym_cps/representation/design/concrete/__init__.py 148 149 150 151 152 153 154 155 156 157 158 159 @property def all_components_by_library_components ( self , ) -> dict [ LibraryComponent , set [ Component ]]: \"\"\"Returns all Components for each LibraryComponent in the design\"\"\" comp_types_n : dict [ LibraryComponent , set [ Component ]] = {} for component in self . components : if component . library_component in comp_types_n . keys (): comp_types_n [ component . library_component ] . add ( component ) else : comp_types_n [ component . library_component ] = { component } return comp_types_n","title":"all_components_by_library_components()"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.all_library_components_component_class","text":"Returns all LibraryComponent for each Component class in the design Source code in sym_cps/representation/design/concrete/__init__.py 135 136 137 138 139 140 141 142 143 144 145 146 @property def all_library_components_component_class ( self , ) -> dict [ CType , set [ LibraryComponent ]]: \"\"\"Returns all LibraryComponent for each Component class in the design\"\"\" comp_types_n : dict [ CType , set [ LibraryComponent ]] = {} for component in self . components : if component . c_type in comp_types_n . keys (): comp_types_n [ component . c_type ] . add ( component . library_component ) else : comp_types_n [ component . c_type ] = { component . library_component } return comp_types_n","title":"all_library_components_component_class()"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.disconnect","text":"TODO. Might want to remove a Connection, retrieve the node_id from the Connection Source code in sym_cps/representation/design/concrete/__init__.py 90 91 92 def disconnect ( self , connection : Connection ): \"\"\"TODO. Might want to remove a Connection, retrieve the node_id from the Connection\"\"\" raise NotImplementedError","title":"disconnect()"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.evaluate","text":"Sends the Design for evaluation Source code in sym_cps/representation/design/concrete/__init__.py 165 166 167 def evaluate ( self ): \"\"\"Sends the Design for evaluation\"\"\" raise NotImplementedError","title":"evaluate()"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.evaluation","text":"Parse and update the evaluation of the Design Source code in sym_cps/representation/design/concrete/__init__.py 169 170 171 def evaluation ( self , evaluation_results_json : str ): \"\"\"Parse and update the evaluation of the Design\"\"\" raise NotImplementedError","title":"evaluation()"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.export_to_cad","text":"Generates a CAD representation of the Design Source code in sym_cps/representation/design/concrete/__init__.py 173 174 175 def export_to_cad ( self ): \"\"\"Generates a CAD representation of the Design\"\"\" raise NotImplementedError","title":"export_to_cad()"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.remove_edge","text":"TODO. Tip: self.graph.delete_edges Source code in sym_cps/representation/design/concrete/__init__.py 86 87 88 def remove_edge ( self ): \"\"\"TODO. Tip: self.graph.delete_edges\"\"\" raise NotImplementedError","title":"remove_edge()"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.remove_node","text":"TODO Source code in sym_cps/representation/design/concrete/__init__.py 74 75 76 def remove_node ( self ): \"\"\"TODO\"\"\" raise NotImplementedError","title":"remove_node()"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.to_design_swri","text":"Generate design_swri.json format file from a concrete design design: the concrete design exporting to design_swri.json file output_path: file path for the export file. Source code in sym_cps/representation/design/concrete/__init__.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 @property def to_design_swri ( self ) -> dict [ str , str ]: \"\"\"Generate design_swri.json format file from a concrete design design: the concrete design exporting to design_swri.json file output_path: file path for the export file. \"\"\" design_swri_data = {} \"\"\" Storing the design name\"\"\" design_swri_data [ \"name\" ] = self . name \"\"\"Storing parameters\"\"\" data_parameters : list = [] for component in self . components : for parameter_id , parameter in component . parameters . items (): data_parameters . append ( { \"parameter_name\" : f \" { component . id } _ { parameter . c_parameter . name } \" , \"value\" : str ( int ( parameter . value )), \"component_properties\" : [ { \"component_name\" : component . id , \"component_property\" : parameter . c_parameter . name , } ], } ) design_swri_data [ \"parameters\" ] = data_parameters \"\"\"Storing components\"\"\" data_components : list [ dict [ str , str ]] = [] for component in self . components : data_components . append ( { \"component_instance\" : component . id , \"component_type\" : component . c_type . id , \"component_choice\" : component . model , } ) design_swri_data [ \"components\" ] = data_components \"\"\"Storing connections\"\"\" data_connections : list [ dict [ str , str ]] = [] for connection in self . connections : data_connections . append ( { \"from_ci\" : connection . component_a . id , \"from_conn\" : connection . connector_a . name , \"to_ci\" : connection . component_b . id , \"to_conn\" : connection . connector_b . name , } ) data_connections . append ( { \"from_ci\" : connection . component_b . id , \"from_conn\" : connection . connector_b . name , \"to_ci\" : connection . component_a . id , \"to_conn\" : connection . connector_a . name , } ) design_swri_data [ \"connections\" ] = data_connections return design_swri_data","title":"to_design_swri()"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.validate","text":"Validates the Parameters of the Design Source code in sym_cps/representation/design/concrete/__init__.py 161 162 163 def validate ( self ): \"\"\"Validates the Parameters of the Design\"\"\" raise NotImplementedError","title":"validate()"},{"location":"reference/sym_cps/representation/design/concrete/elements/","text":"","title":"elements"},{"location":"reference/sym_cps/representation/design/concrete/elements/component/","text":"Component dataclass \u00b6 Source code in sym_cps/representation/design/concrete/elements/component.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 @dataclass ( frozen = True ) class Component : id : str library_component : LibraryComponent parameters : dict [ str , Parameter ] = field ( default_factory = dict ) def __post_init__ ( self ): \"\"\"Fill up all the parameters with the assigned_value, or default_value\"\"\" for parameter_accepted in self . configurable_parameters : if parameter_accepted . id not in self . parameters . keys (): if \"assigned_val\" in parameter_accepted . values . keys (): new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"assigned_val\" ]), c_parameter = parameter_accepted , component = self , ) elif \"default_val\" in parameter_accepted . values . keys (): new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"default_val\" ]), c_parameter = parameter_accepted , component = self , ) else : # raise Exception( # f\"Parameter {parameter_accepted.id} does not have assigned_val nor default_val\" # ) new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"min_val\" ]), c_parameter = parameter_accepted , component = self , ) self . parameters [ parameter_accepted . id ] = new_parameter for parameter in self . parameters . values (): parameter . component = self @property def model ( self ) -> str : return self . library_component . id @property def c_type ( self ) -> CType : return self . library_component . comp_type @property def properties ( self ) -> dict [ str , CProperty ]: return self . library_component . properties @property def configurable_parameters ( self ) -> set [ CParameter ]: \"\"\"Returns the set of all ParameterType that can be configured in the Component\"\"\" return set ( self . library_component . parameters . values ()) @property def params_props_values ( self ) -> dict [ str , float | str ]: \"\"\"Returns dictionary: with the values of each parameter and property of the component\"\"\" params_props_values : dict [ str , float | str ] = {} for param_id , parameter in self . parameters . items (): params_props_values [ param_id ] = parameter . value for property_id , property in self . properties . items (): params_props_values [ property_id ] = property . value return params_props_values def _edit_field ( self , name , value ): object . __setattr__ ( self , name , value ) def _update_field ( self , name , value ): attr = object . __getattribute__ ( self , name ) attr . update ( value ) object . __setattr__ ( self , name , attr ) def __eq__ ( self , other : object ): if not isinstance ( other , Component ): return NotImplemented if self . library_component != other . library_component : return False if self . params_props_values != self . params_props_values : return False return True def __ne__ ( self , other : object ): if not isinstance ( other , Component ): return NotImplemented return not self . __eq__ ( other ) def __hash__ ( self ): return abs ( hash ( self . id )) def __str__ ( self ): s1 = f \"name: { self . model } \\n \" f \"type: { self . c_type } \\n \" parameters_str = [] for k , v in self . parameters . items (): parameters_str . append ( f \" \\t { k } : { v } \" ) parameters = \" \\n \" . join ( parameters_str ) if len ( parameters_str ) != 0 : s2 = f \"parameters: \\n { parameters } \\n \" else : s2 = \"\" return s1 + s2 __post_init__ () \u00b6 Fill up all the parameters with the assigned_value, or default_value Source code in sym_cps/representation/design/concrete/elements/component.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def __post_init__ ( self ): \"\"\"Fill up all the parameters with the assigned_value, or default_value\"\"\" for parameter_accepted in self . configurable_parameters : if parameter_accepted . id not in self . parameters . keys (): if \"assigned_val\" in parameter_accepted . values . keys (): new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"assigned_val\" ]), c_parameter = parameter_accepted , component = self , ) elif \"default_val\" in parameter_accepted . values . keys (): new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"default_val\" ]), c_parameter = parameter_accepted , component = self , ) else : # raise Exception( # f\"Parameter {parameter_accepted.id} does not have assigned_val nor default_val\" # ) new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"min_val\" ]), c_parameter = parameter_accepted , component = self , ) self . parameters [ parameter_accepted . id ] = new_parameter for parameter in self . parameters . values (): parameter . component = self configurable_parameters () property \u00b6 Returns the set of all ParameterType that can be configured in the Component Source code in sym_cps/representation/design/concrete/elements/component.py 61 62 63 64 @property def configurable_parameters ( self ) -> set [ CParameter ]: \"\"\"Returns the set of all ParameterType that can be configured in the Component\"\"\" return set ( self . library_component . parameters . values ()) params_props_values () property \u00b6 Returns dictionary: with the values of each parameter and property of the component Source code in sym_cps/representation/design/concrete/elements/component.py 66 67 68 69 70 71 72 73 74 75 76 @property def params_props_values ( self ) -> dict [ str , float | str ]: \"\"\"Returns dictionary: with the values of each parameter and property of the component\"\"\" params_props_values : dict [ str , float | str ] = {} for param_id , parameter in self . parameters . items (): params_props_values [ param_id ] = parameter . value for property_id , property in self . properties . items (): params_props_values [ property_id ] = property . value return params_props_values","title":"component"},{"location":"reference/sym_cps/representation/design/concrete/elements/component/#sym_cps.representation.design.concrete.elements.component.Component","text":"Source code in sym_cps/representation/design/concrete/elements/component.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 @dataclass ( frozen = True ) class Component : id : str library_component : LibraryComponent parameters : dict [ str , Parameter ] = field ( default_factory = dict ) def __post_init__ ( self ): \"\"\"Fill up all the parameters with the assigned_value, or default_value\"\"\" for parameter_accepted in self . configurable_parameters : if parameter_accepted . id not in self . parameters . keys (): if \"assigned_val\" in parameter_accepted . values . keys (): new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"assigned_val\" ]), c_parameter = parameter_accepted , component = self , ) elif \"default_val\" in parameter_accepted . values . keys (): new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"default_val\" ]), c_parameter = parameter_accepted , component = self , ) else : # raise Exception( # f\"Parameter {parameter_accepted.id} does not have assigned_val nor default_val\" # ) new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"min_val\" ]), c_parameter = parameter_accepted , component = self , ) self . parameters [ parameter_accepted . id ] = new_parameter for parameter in self . parameters . values (): parameter . component = self @property def model ( self ) -> str : return self . library_component . id @property def c_type ( self ) -> CType : return self . library_component . comp_type @property def properties ( self ) -> dict [ str , CProperty ]: return self . library_component . properties @property def configurable_parameters ( self ) -> set [ CParameter ]: \"\"\"Returns the set of all ParameterType that can be configured in the Component\"\"\" return set ( self . library_component . parameters . values ()) @property def params_props_values ( self ) -> dict [ str , float | str ]: \"\"\"Returns dictionary: with the values of each parameter and property of the component\"\"\" params_props_values : dict [ str , float | str ] = {} for param_id , parameter in self . parameters . items (): params_props_values [ param_id ] = parameter . value for property_id , property in self . properties . items (): params_props_values [ property_id ] = property . value return params_props_values def _edit_field ( self , name , value ): object . __setattr__ ( self , name , value ) def _update_field ( self , name , value ): attr = object . __getattribute__ ( self , name ) attr . update ( value ) object . __setattr__ ( self , name , attr ) def __eq__ ( self , other : object ): if not isinstance ( other , Component ): return NotImplemented if self . library_component != other . library_component : return False if self . params_props_values != self . params_props_values : return False return True def __ne__ ( self , other : object ): if not isinstance ( other , Component ): return NotImplemented return not self . __eq__ ( other ) def __hash__ ( self ): return abs ( hash ( self . id )) def __str__ ( self ): s1 = f \"name: { self . model } \\n \" f \"type: { self . c_type } \\n \" parameters_str = [] for k , v in self . parameters . items (): parameters_str . append ( f \" \\t { k } : { v } \" ) parameters = \" \\n \" . join ( parameters_str ) if len ( parameters_str ) != 0 : s2 = f \"parameters: \\n { parameters } \\n \" else : s2 = \"\" return s1 + s2","title":"Component"},{"location":"reference/sym_cps/representation/design/concrete/elements/component/#sym_cps.representation.design.concrete.elements.component.Component.__post_init__","text":"Fill up all the parameters with the assigned_value, or default_value Source code in sym_cps/representation/design/concrete/elements/component.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def __post_init__ ( self ): \"\"\"Fill up all the parameters with the assigned_value, or default_value\"\"\" for parameter_accepted in self . configurable_parameters : if parameter_accepted . id not in self . parameters . keys (): if \"assigned_val\" in parameter_accepted . values . keys (): new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"assigned_val\" ]), c_parameter = parameter_accepted , component = self , ) elif \"default_val\" in parameter_accepted . values . keys (): new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"default_val\" ]), c_parameter = parameter_accepted , component = self , ) else : # raise Exception( # f\"Parameter {parameter_accepted.id} does not have assigned_val nor default_val\" # ) new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"min_val\" ]), c_parameter = parameter_accepted , component = self , ) self . parameters [ parameter_accepted . id ] = new_parameter for parameter in self . parameters . values (): parameter . component = self","title":"__post_init__()"},{"location":"reference/sym_cps/representation/design/concrete/elements/component/#sym_cps.representation.design.concrete.elements.component.Component.configurable_parameters","text":"Returns the set of all ParameterType that can be configured in the Component Source code in sym_cps/representation/design/concrete/elements/component.py 61 62 63 64 @property def configurable_parameters ( self ) -> set [ CParameter ]: \"\"\"Returns the set of all ParameterType that can be configured in the Component\"\"\" return set ( self . library_component . parameters . values ())","title":"configurable_parameters()"},{"location":"reference/sym_cps/representation/design/concrete/elements/component/#sym_cps.representation.design.concrete.elements.component.Component.params_props_values","text":"Returns dictionary: with the values of each parameter and property of the component Source code in sym_cps/representation/design/concrete/elements/component.py 66 67 68 69 70 71 72 73 74 75 76 @property def params_props_values ( self ) -> dict [ str , float | str ]: \"\"\"Returns dictionary: with the values of each parameter and property of the component\"\"\" params_props_values : dict [ str , float | str ] = {} for param_id , parameter in self . parameters . items (): params_props_values [ param_id ] = parameter . value for property_id , property in self . properties . items (): params_props_values [ property_id ] = property . value return params_props_values","title":"params_props_values()"},{"location":"reference/sym_cps/representation/design/concrete/elements/connection/","text":"Connection dataclass \u00b6 Models the connection between two 'Component'. Each Connection is symmetric, i.e. Connection(A,B) = Connection(B,A) Source code in sym_cps/representation/design/concrete/elements/connection.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 @dataclass ( frozen = True ) class Connection : \"\"\"Models the connection between two 'Component'. Each Connection is symmetric, i.e. Connection(A,B) = Connection(B,A)\"\"\" component_a : Component connector_a : CConnector component_b : Component connector_b : CConnector def __post_init__ ( self ): \"\"\"TODO: is connection legal?\"\"\" @property def components_and_connectors ( self ) -> set [ tuple [ Component , CConnector ]]: \"\"\"Returns a set of two tuples, where each tuple is formed by a Component and a CConnector\"\"\" connections = set () connections . add (( self . component_a , self . connector_a )) connections . add (( self . component_b , self . connector_b )) return connections @property def components ( self ) -> tuple [ Component , Component ]: \"\"\"Returns the two components connected\"\"\" return self . component_a , self . component_b @property def key ( self ) -> str : a1 = self . component_a . id a2 = self . connector_a . id b1 = self . component_b . id b2 = self . connector_b . id if ( a1 + a2 ) >= ( b1 + b2 ): return f \" { a1 } - { a2 } - { b1 } - { b2 } \" return f \" { b1 } - { b2 } - { a1 } - { a2 } \" def __eq__ ( self , other : object ): if not isinstance ( other , Connection ): return NotImplementedError return self . key == other . key def __ne__ ( self , other : object ): if not isinstance ( other , Connection ): return NotImplementedError return not self . __eq__ ( other ) def __str__ ( self ): a1 = self . component_a . id a2 = self . connector_a . id b1 = self . component_b . id b2 = self . connector_b . id s1 = f \"FROM \\n\\t COMPONENT \\t { a1 } \\n\\t CONNECTOR \\t { a2 } \\n \" s2 = f \"TO \\n\\t COMPONENT \\t { b1 } \\n\\t CONNECTOR \\t { b2 } \\n \" return f \" { s1 }{ s2 } \" def __hash__ ( self ): return abs ( hash ( self . key )) __post_init__ () \u00b6 Todo is connection legal? Source code in sym_cps/representation/design/concrete/elements/connection.py 21 22 def __post_init__ ( self ): \"\"\"TODO: is connection legal?\"\"\" components () property \u00b6 Returns the two components connected Source code in sym_cps/representation/design/concrete/elements/connection.py 33 34 35 36 37 @property def components ( self ) -> tuple [ Component , Component ]: \"\"\"Returns the two components connected\"\"\" return self . component_a , self . component_b components_and_connectors () property \u00b6 Returns a set of two tuples, where each tuple is formed by a Component and a CConnector Source code in sym_cps/representation/design/concrete/elements/connection.py 24 25 26 27 28 29 30 31 @property def components_and_connectors ( self ) -> set [ tuple [ Component , CConnector ]]: \"\"\"Returns a set of two tuples, where each tuple is formed by a Component and a CConnector\"\"\" connections = set () connections . add (( self . component_a , self . connector_a )) connections . add (( self . component_b , self . connector_b )) return connections","title":"connection"},{"location":"reference/sym_cps/representation/design/concrete/elements/connection/#sym_cps.representation.design.concrete.elements.connection.Connection","text":"Models the connection between two 'Component'. Each Connection is symmetric, i.e. Connection(A,B) = Connection(B,A) Source code in sym_cps/representation/design/concrete/elements/connection.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 @dataclass ( frozen = True ) class Connection : \"\"\"Models the connection between two 'Component'. Each Connection is symmetric, i.e. Connection(A,B) = Connection(B,A)\"\"\" component_a : Component connector_a : CConnector component_b : Component connector_b : CConnector def __post_init__ ( self ): \"\"\"TODO: is connection legal?\"\"\" @property def components_and_connectors ( self ) -> set [ tuple [ Component , CConnector ]]: \"\"\"Returns a set of two tuples, where each tuple is formed by a Component and a CConnector\"\"\" connections = set () connections . add (( self . component_a , self . connector_a )) connections . add (( self . component_b , self . connector_b )) return connections @property def components ( self ) -> tuple [ Component , Component ]: \"\"\"Returns the two components connected\"\"\" return self . component_a , self . component_b @property def key ( self ) -> str : a1 = self . component_a . id a2 = self . connector_a . id b1 = self . component_b . id b2 = self . connector_b . id if ( a1 + a2 ) >= ( b1 + b2 ): return f \" { a1 } - { a2 } - { b1 } - { b2 } \" return f \" { b1 } - { b2 } - { a1 } - { a2 } \" def __eq__ ( self , other : object ): if not isinstance ( other , Connection ): return NotImplementedError return self . key == other . key def __ne__ ( self , other : object ): if not isinstance ( other , Connection ): return NotImplementedError return not self . __eq__ ( other ) def __str__ ( self ): a1 = self . component_a . id a2 = self . connector_a . id b1 = self . component_b . id b2 = self . connector_b . id s1 = f \"FROM \\n\\t COMPONENT \\t { a1 } \\n\\t CONNECTOR \\t { a2 } \\n \" s2 = f \"TO \\n\\t COMPONENT \\t { b1 } \\n\\t CONNECTOR \\t { b2 } \\n \" return f \" { s1 }{ s2 } \" def __hash__ ( self ): return abs ( hash ( self . key ))","title":"Connection"},{"location":"reference/sym_cps/representation/design/concrete/elements/connection/#sym_cps.representation.design.concrete.elements.connection.Connection.__post_init__","text":"Todo is connection legal? Source code in sym_cps/representation/design/concrete/elements/connection.py 21 22 def __post_init__ ( self ): \"\"\"TODO: is connection legal?\"\"\"","title":"__post_init__()"},{"location":"reference/sym_cps/representation/design/concrete/elements/connection/#sym_cps.representation.design.concrete.elements.connection.Connection.components","text":"Returns the two components connected Source code in sym_cps/representation/design/concrete/elements/connection.py 33 34 35 36 37 @property def components ( self ) -> tuple [ Component , Component ]: \"\"\"Returns the two components connected\"\"\" return self . component_a , self . component_b","title":"components()"},{"location":"reference/sym_cps/representation/design/concrete/elements/connection/#sym_cps.representation.design.concrete.elements.connection.Connection.components_and_connectors","text":"Returns a set of two tuples, where each tuple is formed by a Component and a CConnector Source code in sym_cps/representation/design/concrete/elements/connection.py 24 25 26 27 28 29 30 31 @property def components_and_connectors ( self ) -> set [ tuple [ Component , CConnector ]]: \"\"\"Returns a set of two tuples, where each tuple is formed by a Component and a CConnector\"\"\" connections = set () connections . add (( self . component_a , self . connector_a )) connections . add (( self . component_b , self . connector_b )) return connections","title":"components_and_connectors()"},{"location":"reference/sym_cps/representation/design/concrete/elements/design_parameters/","text":"","title":"design_parameters"},{"location":"reference/sym_cps/representation/design/concrete/elements/parameter/","text":"","title":"parameter"},{"location":"reference/sym_cps/representation/design/topology/","text":"DTopology dataclass \u00b6 Source code in sym_cps/representation/design/topology/__init__.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 @dataclass class DTopology : name : str def __post_init__ ( self ): self . _graph = Graph () @property def graph ( self ) -> Graph : return self . _graph @classmethod def from_concrete ( cls , d_concrete : DConcrete ) -> DTopology : # Create all the vertexes with the same id in d_concrete: d_topology = cls ( name = d_concrete . name ) for i in range ( d_concrete . n_nodes ): vertex = d_concrete . get_vertex_by_id ( i ) component : Component = vertex [ \"component\" ] d_topology . add_node ( c_type = component . library_component . comp_type ) # print(f\"{vertex.index} - {new_vertex.index}\") for edge in d_concrete . edges : d_topology . add_edge ( edge . source , edge . target ) return d_topology @property def nodes ( self ) -> list [ igraph . Vertex ]: return list ( self . graph . vs ) def get_vertex_by_id ( self , vid : int ) -> igraph . Vertex : return self . graph . vs [ vid ] @property def edges ( self ) -> list [ igraph . Edge ]: return list ( self . graph . es ) @property def n_nodes ( self ) -> int : return len ( self . graph . vs ) def add_node ( self , c_type : CType ) -> igraph . Vertex : return self . graph . add_vertex ( c_type = c_type , label = c_type . id ) def remove_node ( self ): \"\"\"TODO\"\"\" raise NotImplementedError def add_edge ( self , node_id_a : int , node_id_b : int ): self . graph . add_edge ( source = node_id_a , target = node_id_b ) def remove_edge ( self ): \"\"\"TODO. Tip: self.graph.delete_edges\"\"\" raise NotImplementedError @property def components ( self ) -> set [ CType ]: if self . n_nodes > 0 : return set ( self . graph . vs ()[ \"c_type\" ]) return set () @property def edges ( self ) -> list [ igraph . Edge ]: return list ( self . graph . es ) def draw_random_node ( self ) -> igraph . Vertex | None : if self . n_nodes == 0 : return None return choice ( self . nodes ) def export ( self , file_type : ExportType ): absolute_folder = designs_folder / self . name if file_type == ExportType . TXT : save_to_file ( str ( self ), file_name = f \"DTopology\" , absolute_folder_path = absolute_folder , ) elif file_type == ExportType . JSON : raise Exception ( \"Can't create JSON from DTopology. It must be from DConcrete.\" ) elif file_type == ExportType . DOT : self . graph . write_dot ( f = str ( absolute_folder / \"topo_graph.dot\" )) else : raise Exception ( \"File type not supported\" ) print ( f \" { file_type } file saved in { absolute_folder } \" ) def __str__ ( self ): ret = str ( self . graph ) ret += \" \\n \" for node in self . nodes : ret += f \" { node . index } : { node [ 'c_type' ] } \\n \" return ret remove_edge () \u00b6 TODO. Tip: self.graph.delete_edges Source code in sym_cps/representation/design/topology/__init__.py 68 69 70 def remove_edge ( self ): \"\"\"TODO. Tip: self.graph.delete_edges\"\"\" raise NotImplementedError remove_node () \u00b6 TODO Source code in sym_cps/representation/design/topology/__init__.py 61 62 63 def remove_node ( self ): \"\"\"TODO\"\"\" raise NotImplementedError","title":"topology"},{"location":"reference/sym_cps/representation/design/topology/#sym_cps.representation.design.topology.DTopology","text":"Source code in sym_cps/representation/design/topology/__init__.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 @dataclass class DTopology : name : str def __post_init__ ( self ): self . _graph = Graph () @property def graph ( self ) -> Graph : return self . _graph @classmethod def from_concrete ( cls , d_concrete : DConcrete ) -> DTopology : # Create all the vertexes with the same id in d_concrete: d_topology = cls ( name = d_concrete . name ) for i in range ( d_concrete . n_nodes ): vertex = d_concrete . get_vertex_by_id ( i ) component : Component = vertex [ \"component\" ] d_topology . add_node ( c_type = component . library_component . comp_type ) # print(f\"{vertex.index} - {new_vertex.index}\") for edge in d_concrete . edges : d_topology . add_edge ( edge . source , edge . target ) return d_topology @property def nodes ( self ) -> list [ igraph . Vertex ]: return list ( self . graph . vs ) def get_vertex_by_id ( self , vid : int ) -> igraph . Vertex : return self . graph . vs [ vid ] @property def edges ( self ) -> list [ igraph . Edge ]: return list ( self . graph . es ) @property def n_nodes ( self ) -> int : return len ( self . graph . vs ) def add_node ( self , c_type : CType ) -> igraph . Vertex : return self . graph . add_vertex ( c_type = c_type , label = c_type . id ) def remove_node ( self ): \"\"\"TODO\"\"\" raise NotImplementedError def add_edge ( self , node_id_a : int , node_id_b : int ): self . graph . add_edge ( source = node_id_a , target = node_id_b ) def remove_edge ( self ): \"\"\"TODO. Tip: self.graph.delete_edges\"\"\" raise NotImplementedError @property def components ( self ) -> set [ CType ]: if self . n_nodes > 0 : return set ( self . graph . vs ()[ \"c_type\" ]) return set () @property def edges ( self ) -> list [ igraph . Edge ]: return list ( self . graph . es ) def draw_random_node ( self ) -> igraph . Vertex | None : if self . n_nodes == 0 : return None return choice ( self . nodes ) def export ( self , file_type : ExportType ): absolute_folder = designs_folder / self . name if file_type == ExportType . TXT : save_to_file ( str ( self ), file_name = f \"DTopology\" , absolute_folder_path = absolute_folder , ) elif file_type == ExportType . JSON : raise Exception ( \"Can't create JSON from DTopology. It must be from DConcrete.\" ) elif file_type == ExportType . DOT : self . graph . write_dot ( f = str ( absolute_folder / \"topo_graph.dot\" )) else : raise Exception ( \"File type not supported\" ) print ( f \" { file_type } file saved in { absolute_folder } \" ) def __str__ ( self ): ret = str ( self . graph ) ret += \" \\n \" for node in self . nodes : ret += f \" { node . index } : { node [ 'c_type' ] } \\n \" return ret","title":"DTopology"},{"location":"reference/sym_cps/representation/design/topology/#sym_cps.representation.design.topology.DTopology.remove_edge","text":"TODO. Tip: self.graph.delete_edges Source code in sym_cps/representation/design/topology/__init__.py 68 69 70 def remove_edge ( self ): \"\"\"TODO. Tip: self.graph.delete_edges\"\"\" raise NotImplementedError","title":"remove_edge()"},{"location":"reference/sym_cps/representation/design/topology/#sym_cps.representation.design.topology.DTopology.remove_node","text":"TODO Source code in sym_cps/representation/design/topology/__init__.py 61 62 63 def remove_node ( self ): \"\"\"TODO\"\"\" raise NotImplementedError","title":"remove_node()"},{"location":"reference/sym_cps/representation/library/","text":"","title":"library"},{"location":"reference/sym_cps/representation/library/elements/","text":"","title":"elements"},{"location":"reference/sym_cps/representation/library/elements/c_connector/","text":"","title":"c_connector"},{"location":"reference/sym_cps/representation/library/elements/c_parameter/","text":"CParameter dataclass \u00b6 Indicates the possible values and type of a component parameter. Parameters are associated to component classes. Source code in sym_cps/representation/library/elements/c_parameter.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 @dataclass ( frozen = True ) class CParameter : \"\"\"Indicates the possible values and type of a component parameter. Parameters are associated to component classes. \"\"\" name : str belongs_to : CType = field ( init = False ) _values : dict = field ( init = False , default_factory = dict ) def _edit_field ( self , name , value ): object . __setattr__ ( self , name , value ) def _update_field ( self , name , value ): attr = object . __getattribute__ ( self , name ) attr . update ( value ) object . __setattr__ ( self , name , attr ) def __post_init__ ( self ): vals : dict [ str , float | None ] = { \"min_val\" : None , \"max_val\" : None , \"default_val\" : None , \"assigned_val\" : None , } self . _edit_field ( \"_values\" , vals ) @property def values ( self ) -> dict [ str , float ]: \"\"\"Filters out None component\"\"\" return { key : value for key , value in self . _values . items () if value is not None } def _edit_values ( self , values : dict ): for key in values . keys (): if key in self . _values . keys (): if values [ key ] != \"\" : self . _values [ key ] = float ( values [ key ]) @property def id ( self ) -> str : \"\"\"Internal ID\"\"\" return parameter_id ( self . name , str ( self . belongs_to )) def __str__ ( self ): values = \", \" . join ([ f \" { k } : { v } \" for k , v in self . values . items ()]) return f \" { self . name } \\t { values } \" def __hash__ ( self ): return abs ( hash ( self . id )) id () property \u00b6 Internal ID Source code in sym_cps/representation/library/elements/c_parameter.py 52 53 54 55 @property def id ( self ) -> str : \"\"\"Internal ID\"\"\" return parameter_id ( self . name , str ( self . belongs_to )) values () property \u00b6 Filters out None component Source code in sym_cps/representation/library/elements/c_parameter.py 41 42 43 44 @property def values ( self ) -> dict [ str , float ]: \"\"\"Filters out None component\"\"\" return { key : value for key , value in self . _values . items () if value is not None }","title":"c_parameter"},{"location":"reference/sym_cps/representation/library/elements/c_parameter/#sym_cps.representation.library.elements.c_parameter.CParameter","text":"Indicates the possible values and type of a component parameter. Parameters are associated to component classes. Source code in sym_cps/representation/library/elements/c_parameter.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 @dataclass ( frozen = True ) class CParameter : \"\"\"Indicates the possible values and type of a component parameter. Parameters are associated to component classes. \"\"\" name : str belongs_to : CType = field ( init = False ) _values : dict = field ( init = False , default_factory = dict ) def _edit_field ( self , name , value ): object . __setattr__ ( self , name , value ) def _update_field ( self , name , value ): attr = object . __getattribute__ ( self , name ) attr . update ( value ) object . __setattr__ ( self , name , attr ) def __post_init__ ( self ): vals : dict [ str , float | None ] = { \"min_val\" : None , \"max_val\" : None , \"default_val\" : None , \"assigned_val\" : None , } self . _edit_field ( \"_values\" , vals ) @property def values ( self ) -> dict [ str , float ]: \"\"\"Filters out None component\"\"\" return { key : value for key , value in self . _values . items () if value is not None } def _edit_values ( self , values : dict ): for key in values . keys (): if key in self . _values . keys (): if values [ key ] != \"\" : self . _values [ key ] = float ( values [ key ]) @property def id ( self ) -> str : \"\"\"Internal ID\"\"\" return parameter_id ( self . name , str ( self . belongs_to )) def __str__ ( self ): values = \", \" . join ([ f \" { k } : { v } \" for k , v in self . values . items ()]) return f \" { self . name } \\t { values } \" def __hash__ ( self ): return abs ( hash ( self . id ))","title":"CParameter"},{"location":"reference/sym_cps/representation/library/elements/c_parameter/#sym_cps.representation.library.elements.c_parameter.CParameter.id","text":"Internal ID Source code in sym_cps/representation/library/elements/c_parameter.py 52 53 54 55 @property def id ( self ) -> str : \"\"\"Internal ID\"\"\" return parameter_id ( self . name , str ( self . belongs_to ))","title":"id()"},{"location":"reference/sym_cps/representation/library/elements/c_parameter/#sym_cps.representation.library.elements.c_parameter.CParameter.values","text":"Filters out None component Source code in sym_cps/representation/library/elements/c_parameter.py 41 42 43 44 @property def values ( self ) -> dict [ str , float ]: \"\"\"Filters out None component\"\"\" return { key : value for key , value in self . _values . items () if value is not None }","title":"values()"},{"location":"reference/sym_cps/representation/library/elements/c_property/","text":"","title":"c_property"},{"location":"reference/sym_cps/representation/library/elements/c_type/","text":"CType dataclass \u00b6 Source code in sym_cps/representation/library/elements/c_type.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 @dataclass ( frozen = True ) class CType : id : str \"\"\"Configurable parameters\"\"\" parameters : dict [ str , CParameter ] = field ( init = False , default_factory = dict ) \"\"\"Accepted connectors\"\"\" connectors : dict [ str , CConnector ] = field ( init = False , default_factory = dict ) \"\"\"Compatible CType to be connected to\"\"\" compatible_with : dict [ str , CType ] = field ( init = False , default_factory = dict ) \"\"\"Library components of CType\"\"\" belongs_to : dict [ str , LibraryComponent ] = field ( init = False , default_factory = dict ) def _edit_field ( self , name , value ): object . __setattr__ ( self , name , value ) def _update_field ( self , name , value ): attr = object . __getattribute__ ( self , name ) if len ( attr ) == 0 : object . __setattr__ ( self , name , value ) return attr . update ( value ) object . __setattr__ ( self , name , attr ) def _remove_from_field ( self , name , value ): if value not in self . belongs_to . keys (): return attr = object . __getattribute__ ( self , name ) if len ( attr ) == 0 : return del attr [ value ] object . __setattr__ ( self , name , attr ) def __str__ ( self ) -> str : return self . id def __hash__ ( self ) -> int : return hash ( self . id ) compatible_with : dict [ str , CType ] = field ( init = False , default_factory = dict ) class-attribute \u00b6 Library components of CType connectors : dict [ str , CConnector ] = field ( init = False , default_factory = dict ) class-attribute \u00b6 Compatible CType to be connected to id : str class-attribute \u00b6 Configurable parameters parameters : dict [ str , CParameter ] = field ( init = False , default_factory = dict ) class-attribute \u00b6 Accepted connectors","title":"c_type"},{"location":"reference/sym_cps/representation/library/elements/c_type/#sym_cps.representation.library.elements.c_type.CType","text":"Source code in sym_cps/representation/library/elements/c_type.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 @dataclass ( frozen = True ) class CType : id : str \"\"\"Configurable parameters\"\"\" parameters : dict [ str , CParameter ] = field ( init = False , default_factory = dict ) \"\"\"Accepted connectors\"\"\" connectors : dict [ str , CConnector ] = field ( init = False , default_factory = dict ) \"\"\"Compatible CType to be connected to\"\"\" compatible_with : dict [ str , CType ] = field ( init = False , default_factory = dict ) \"\"\"Library components of CType\"\"\" belongs_to : dict [ str , LibraryComponent ] = field ( init = False , default_factory = dict ) def _edit_field ( self , name , value ): object . __setattr__ ( self , name , value ) def _update_field ( self , name , value ): attr = object . __getattribute__ ( self , name ) if len ( attr ) == 0 : object . __setattr__ ( self , name , value ) return attr . update ( value ) object . __setattr__ ( self , name , attr ) def _remove_from_field ( self , name , value ): if value not in self . belongs_to . keys (): return attr = object . __getattribute__ ( self , name ) if len ( attr ) == 0 : return del attr [ value ] object . __setattr__ ( self , name , attr ) def __str__ ( self ) -> str : return self . id def __hash__ ( self ) -> int : return hash ( self . id )","title":"CType"},{"location":"reference/sym_cps/representation/library/elements/c_type/#sym_cps.representation.library.elements.c_type.CType.compatible_with","text":"Library components of CType","title":"compatible_with"},{"location":"reference/sym_cps/representation/library/elements/c_type/#sym_cps.representation.library.elements.c_type.CType.connectors","text":"Compatible CType to be connected to","title":"connectors"},{"location":"reference/sym_cps/representation/library/elements/c_type/#sym_cps.representation.library.elements.c_type.CType.id","text":"Configurable parameters","title":"id"},{"location":"reference/sym_cps/representation/library/elements/c_type/#sym_cps.representation.library.elements.c_type.CType.parameters","text":"Accepted connectors","title":"parameters"},{"location":"reference/sym_cps/representation/library/elements/library_component/","text":"LibraryComponent dataclass \u00b6 Represent and model of component in the components_library. It has fixed properties and can have parameters and connectors. Source code in sym_cps/representation/library/elements/library_component.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 @dataclass ( frozen = True ) class LibraryComponent : \"\"\"Represent and model of component in the components_library. It has fixed properties and can have parameters and connectors.\"\"\" \"\"\"Component Model Name\"\"\" id : str comp_type : CType properties : dict [ str , CProperty ] = field ( init = False , default_factory = dict ) @property def parameters ( self ) -> dict [ str , CParameter ]: return self . comp_type . parameters @property def connectors ( self ) -> dict [ str , CConnector ]: return self . comp_type . connectors def _edit_field ( self , name , value ): object . __setattr__ ( self , name , value ) def _update_field ( self , name , value ): attr = object . __getattribute__ ( self , name ) attr . update ( value ) object . __setattr__ ( self , name , attr ) def __hash__ ( self ): return hash ( str ( self . id )) def __str__ ( self ) -> str : s1 = f \"name: { self . id } \\n \" f \"type: { str ( self . comp_type ) } \\n \" properties_str = [] for e in list ( self . properties . values ()): properties_str . append ( tab ( e )) properties = \" \\n \" . join ( properties_str ) parameters_str = [] for e in list ( self . parameters . values ()): parameters_str . append ( tab ( e )) parameters = \" \\n \" . join ( parameters_str ) connectors_str = [] for e in list ( self . connectors . values ()): connectors_str . append ( tab ( e )) connectors = \" \\n \" . join ( connectors_str ) s2 = f \"properties: \\n { properties } \\n \" s3 = f \"connectors: \\n { connectors } \\n \" s4 = f \"parameters: \\n { parameters } \\n \" return s1 + s2 + s3 + s4","title":"library_component"},{"location":"reference/sym_cps/representation/library/elements/library_component/#sym_cps.representation.library.elements.library_component.LibraryComponent","text":"Represent and model of component in the components_library. It has fixed properties and can have parameters and connectors. Source code in sym_cps/representation/library/elements/library_component.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 @dataclass ( frozen = True ) class LibraryComponent : \"\"\"Represent and model of component in the components_library. It has fixed properties and can have parameters and connectors.\"\"\" \"\"\"Component Model Name\"\"\" id : str comp_type : CType properties : dict [ str , CProperty ] = field ( init = False , default_factory = dict ) @property def parameters ( self ) -> dict [ str , CParameter ]: return self . comp_type . parameters @property def connectors ( self ) -> dict [ str , CConnector ]: return self . comp_type . connectors def _edit_field ( self , name , value ): object . __setattr__ ( self , name , value ) def _update_field ( self , name , value ): attr = object . __getattribute__ ( self , name ) attr . update ( value ) object . __setattr__ ( self , name , attr ) def __hash__ ( self ): return hash ( str ( self . id )) def __str__ ( self ) -> str : s1 = f \"name: { self . id } \\n \" f \"type: { str ( self . comp_type ) } \\n \" properties_str = [] for e in list ( self . properties . values ()): properties_str . append ( tab ( e )) properties = \" \\n \" . join ( properties_str ) parameters_str = [] for e in list ( self . parameters . values ()): parameters_str . append ( tab ( e )) parameters = \" \\n \" . join ( parameters_str ) connectors_str = [] for e in list ( self . connectors . values ()): connectors_str . append ( tab ( e )) connectors = \" \\n \" . join ( connectors_str ) s2 = f \"properties: \\n { properties } \\n \" s3 = f \"connectors: \\n { connectors } \\n \" s4 = f \"parameters: \\n { parameters } \\n \" return s1 + s2 + s3 + s4","title":"LibraryComponent"},{"location":"reference/sym_cps/representation/tools/","text":"","title":"tools"},{"location":"reference/sym_cps/representation/tools/analyze/","text":"","title":"analyze"},{"location":"reference/sym_cps/representation/tools/connectors/","text":"","title":"connectors"},{"location":"reference/sym_cps/representation/tools/ids/","text":"","title":"ids"},{"location":"reference/sym_cps/representation/tools/export/","text":"","title":"export"},{"location":"reference/sym_cps/representation/tools/export/design_swri/","text":"","title":"design_swri"},{"location":"reference/sym_cps/representation/tools/parsers/","text":"","title":"parsers"},{"location":"reference/sym_cps/representation/tools/parsers/learn_from_designs/","text":"","title":"learn_from_designs"},{"location":"reference/sym_cps/representation/tools/parsers/parse/","text":"parse_library_and_seed_designs () \u00b6 Generates a Components Library Source code in sym_cps/representation/tools/parsers/parse.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def parse_library_and_seed_designs () -> tuple [ Library , dict [ str , tuple [ DConcrete , DTopology ]] ]: \"\"\"Generates a Components Library\"\"\" c_library : Library = Library () . from_folder ( path = component_library_root_path_default ) \"\"\"Learn information form existing designs\"\"\" ( connectable_connectors , connectable_components_types , design_parameters , ) = parse_connections_and_parameters_from_designs ( design_library_root_path_default , library = c_library ) \"\"\"Update information to the library\"\"\" c_library . update_information ( connectable_connectors , connectable_components_types , design_parameters ) \"\"\"Load Seed Designs\"\"\" designs = parse_designs_from_folder ( design_library_root_path_default , library = c_library ) return c_library , designs","title":"parse"},{"location":"reference/sym_cps/representation/tools/parsers/parse/#sym_cps.representation.tools.parsers.parse.parse_library_and_seed_designs","text":"Generates a Components Library Source code in sym_cps/representation/tools/parsers/parse.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def parse_library_and_seed_designs () -> tuple [ Library , dict [ str , tuple [ DConcrete , DTopology ]] ]: \"\"\"Generates a Components Library\"\"\" c_library : Library = Library () . from_folder ( path = component_library_root_path_default ) \"\"\"Learn information form existing designs\"\"\" ( connectable_connectors , connectable_components_types , design_parameters , ) = parse_connections_and_parameters_from_designs ( design_library_root_path_default , library = c_library ) \"\"\"Update information to the library\"\"\" c_library . update_information ( connectable_connectors , connectable_components_types , design_parameters ) \"\"\"Load Seed Designs\"\"\" designs = parse_designs_from_folder ( design_library_root_path_default , library = c_library ) return c_library , designs","title":"parse_library_and_seed_designs()"},{"location":"reference/sym_cps/representation/tools/parsers/parsing_designs/","text":"parse_design_from_design_swri ( path , library ) \u00b6 Initialize a DConcrete from a design_swri file data Source code in sym_cps/representation/tools/parsers/parsing_designs.py 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 def parse_design_from_design_swri ( path : Path , library : Library ) -> DConcrete : \"\"\"Initialize a DConcrete from a design_swri file data\"\"\" \"\"\"Read design_swri file\"\"\" with open ( path , \"r\" ) as design_swri_file : design_swri_data = json . load ( design_swri_file ) \"\"\"Read the design name\"\"\" design_name = design_swri_data [ \"name\" ] new_design = DConcrete ( name = design_name ) \"\"\"Read the components and parameters\"\"\" # maps component instance name to library component component_map : dict [ str , tuple [ str , dict [ str , Parameter ]]] = {} for component_data in design_swri_data [ \"components\" ]: component_instance_str = component_data [ \"component_instance\" ] library_component_str = component_data [ \"component_choice\" ] component_map [ component_instance_str ] = ( library_component_str , {}) for parameter_data in design_swri_data [ \"parameters\" ]: parameter_name = parameter_data [ \"parameter_name\" ] parameter_value = parameter_data [ \"value\" ] component_properties = parameter_data [ \"component_properties\" ] parameters : dict [ str , Parameter ] = {} for prop in component_properties : component_name = prop [ \"component_name\" ] component_property = prop [ \"component_property\" ] library_component_str = component_map [ component_name ][ 0 ] param_id = parameter_id ( component_property , library . components [ library_component_str ] . comp_type . id ) for p , para in library . parameters . items (): print ( p ) try : param_type = library . parameters [ param_id ] except : print ( \"wasda\" ) param_type = library . parameters [ param_id ] parameter = Parameter ( parameter_value , param_type ) parameters [ param_id ] = parameter component_map [ component_name ][ 1 ][ param_id ] = parameter for p in parameters . values (): if isinstance ( p . component , str ): print ( \"ERRORRRR\" ) new_design . design_parameters [ parameter_name ] = DesignParameter ( id = parameter_name , parameters = set ( parameters . values ()) ) for component_name , ( library_component_str , parameters ) in component_map . items (): new_component = Component ( id = component_name , library_component = library . components [ library_component_str ], parameters = parameters , ) new_design . add_node ( new_component ) \"\"\"Read the connection\"\"\" for connection_data in design_swri_data [ \"connections\" ]: instance_s = connection_data [ \"from_ci\" ] instance_t = connection_data [ \"to_ci\" ] component_choice_s = component_map [ instance_s ][ 0 ] component_choice_t = component_map [ instance_t ][ 0 ] connector_id_s = connector_id ( name = connection_data [ \"from_conn\" ], component_type = str ( library . components [ component_choice_s ] . comp_type ), ) connector_id_t = connector_id ( name = connection_data [ \"to_conn\" ], component_type = str ( library . components [ component_choice_t ] . comp_type ), ) connection = Connection ( component_a = new_design . get_instance ( instance_s ), connector_a = library . connectors [ connector_id_s ], component_b = new_design . get_instance ( instance_t ), connector_b = library . connectors [ connector_id_t ], ) try : new_design . connect ( connection ) except : pass # d_concrete = new_design # d_topology = DTopology.from_concrete(new_design) \"\"\"TODO: Update connectable connectors\"\"\" # for key, value in connectable_connectors.items(): # for output_connector in value: # type: ignore # # print(f\"{key} -> {output_connector}\") # all_connectors[key]._update_field(\"compatible_with\", {all_connectors[output_connector].id: all_connectors[output_connector]}) return new_design","title":"parsing_designs"},{"location":"reference/sym_cps/representation/tools/parsers/parsing_designs/#sym_cps.representation.tools.parsers.parsing_designs.parse_design_from_design_swri","text":"Initialize a DConcrete from a design_swri file data Source code in sym_cps/representation/tools/parsers/parsing_designs.py 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 def parse_design_from_design_swri ( path : Path , library : Library ) -> DConcrete : \"\"\"Initialize a DConcrete from a design_swri file data\"\"\" \"\"\"Read design_swri file\"\"\" with open ( path , \"r\" ) as design_swri_file : design_swri_data = json . load ( design_swri_file ) \"\"\"Read the design name\"\"\" design_name = design_swri_data [ \"name\" ] new_design = DConcrete ( name = design_name ) \"\"\"Read the components and parameters\"\"\" # maps component instance name to library component component_map : dict [ str , tuple [ str , dict [ str , Parameter ]]] = {} for component_data in design_swri_data [ \"components\" ]: component_instance_str = component_data [ \"component_instance\" ] library_component_str = component_data [ \"component_choice\" ] component_map [ component_instance_str ] = ( library_component_str , {}) for parameter_data in design_swri_data [ \"parameters\" ]: parameter_name = parameter_data [ \"parameter_name\" ] parameter_value = parameter_data [ \"value\" ] component_properties = parameter_data [ \"component_properties\" ] parameters : dict [ str , Parameter ] = {} for prop in component_properties : component_name = prop [ \"component_name\" ] component_property = prop [ \"component_property\" ] library_component_str = component_map [ component_name ][ 0 ] param_id = parameter_id ( component_property , library . components [ library_component_str ] . comp_type . id ) for p , para in library . parameters . items (): print ( p ) try : param_type = library . parameters [ param_id ] except : print ( \"wasda\" ) param_type = library . parameters [ param_id ] parameter = Parameter ( parameter_value , param_type ) parameters [ param_id ] = parameter component_map [ component_name ][ 1 ][ param_id ] = parameter for p in parameters . values (): if isinstance ( p . component , str ): print ( \"ERRORRRR\" ) new_design . design_parameters [ parameter_name ] = DesignParameter ( id = parameter_name , parameters = set ( parameters . values ()) ) for component_name , ( library_component_str , parameters ) in component_map . items (): new_component = Component ( id = component_name , library_component = library . components [ library_component_str ], parameters = parameters , ) new_design . add_node ( new_component ) \"\"\"Read the connection\"\"\" for connection_data in design_swri_data [ \"connections\" ]: instance_s = connection_data [ \"from_ci\" ] instance_t = connection_data [ \"to_ci\" ] component_choice_s = component_map [ instance_s ][ 0 ] component_choice_t = component_map [ instance_t ][ 0 ] connector_id_s = connector_id ( name = connection_data [ \"from_conn\" ], component_type = str ( library . components [ component_choice_s ] . comp_type ), ) connector_id_t = connector_id ( name = connection_data [ \"to_conn\" ], component_type = str ( library . components [ component_choice_t ] . comp_type ), ) connection = Connection ( component_a = new_design . get_instance ( instance_s ), connector_a = library . connectors [ connector_id_s ], component_b = new_design . get_instance ( instance_t ), connector_b = library . connectors [ connector_id_t ], ) try : new_design . connect ( connection ) except : pass # d_concrete = new_design # d_topology = DTopology.from_concrete(new_design) \"\"\"TODO: Update connectable connectors\"\"\" # for key, value in connectable_connectors.items(): # for output_connector in value: # type: ignore # # print(f\"{key} -> {output_connector}\") # all_connectors[key]._update_field(\"compatible_with\", {all_connectors[output_connector].id: all_connectors[output_connector]}) return new_design","title":"parse_design_from_design_swri()"},{"location":"reference/sym_cps/representation/tools/parsers/parsing_library/","text":"parse_parameter_bounds () \u00b6 Parse design expert parameter bounds from 'lower_bound_file' 'lower_bound_file' Source code in sym_cps/representation/tools/parsers/parsing_library.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def parse_parameter_bounds () -> None : \"\"\"Parse design expert parameter bounds from 'lower_bound_file' 'lower_bound_file'\"\"\" if len ( all_parameters_lower_bounds ) == 0 : file = open ( lower_bound_file , \"r\" ) for line in file : k , v = line . strip () . split ( \":\" ) all_parameters_lower_bounds [ k . strip ()] = float ( v . strip ()) if len ( all_parameters_upper_bounds ) == 0 : file = open ( upper_bound_file , \"r\" ) for line in file : k , v = line . strip () . split ( \":\" ) all_parameters_upper_bounds [ k . strip ()] = float ( v . strip ())","title":"parsing_library"},{"location":"reference/sym_cps/representation/tools/parsers/parsing_library/#sym_cps.representation.tools.parsers.parsing_library.parse_parameter_bounds","text":"Parse design expert parameter bounds from 'lower_bound_file' 'lower_bound_file' Source code in sym_cps/representation/tools/parsers/parsing_library.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def parse_parameter_bounds () -> None : \"\"\"Parse design expert parameter bounds from 'lower_bound_file' 'lower_bound_file'\"\"\" if len ( all_parameters_lower_bounds ) == 0 : file = open ( lower_bound_file , \"r\" ) for line in file : k , v = line . strip () . split ( \":\" ) all_parameters_lower_bounds [ k . strip ()] = float ( v . strip ()) if len ( all_parameters_upper_bounds ) == 0 : file = open ( upper_bound_file , \"r\" ) for line in file : k , v = line . strip () . split ( \":\" ) all_parameters_upper_bounds [ k . strip ()] = float ( v . strip ())","title":"parse_parameter_bounds()"},{"location":"reference/sym_cps/representation/tools/parsers/temp_objects/","text":"","title":"temp_objects"},{"location":"reference/sym_cps/shared/","text":"","title":"shared"},{"location":"reference/sym_cps/shared/paths/","text":"","title":"paths"},{"location":"reference/sym_cps/tools/","text":"","title":"tools"},{"location":"reference/sym_cps/tools/io/","text":"","title":"io"},{"location":"reference/sym_cps/tools/persistance/","text":"","title":"persistance"},{"location":"reference/sym_cps/tools/strings/","text":"","title":"strings"},{"location":"coverage/","text":".md-content { max-width: none !important; } article h1, article > a { display: none; } var coviframe = document.getElementById(\"coviframe\"); function resizeIframe() { coviframe.style.height = coviframe.contentWindow.document.documentElement.offsetHeight + 'px'; } coviframe.contentWindow.document.body.onclick = function() { coviframe.contentWindow.location.reload(); }","title":"Coverage report"}]}