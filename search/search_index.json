{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"sym-cps \u00b6 Symbiotic Design for Cyber Physical Systems Project description available here Documentation available here Installation \u00b6 System Requirements \u00b6 pdm conda Access to the INPUT folder on Google Drive. Copy data and output directories in the root of the repo Dependencies \u00b6 To install the dependencies and environment, simply run: make setup The setup script will: * Pull the submodules * Install dependencies via pdm * Create a new conda environment and install the conda dependencies Activate conda \u00b6 Once script terminates successfully you can activate the environment: conda activate ./.venv Configure AWS \u00b6 Download the aws-cvpn-config.ovpn configuration file from the INPUT folder on Google Drive and use it to connect to the AWS VPN. Here are the instructions for Linux , MacOS and Windows . Create ./output/aws if it does not exist already. (Optional) notify your IDE to exclude the aws folder from being indexed. For example in PyCharm do Right Click on aws - Mark directory as - Excluded Mount the shared folder in ./output/aws . Instructions here . Suggestion: from the root folder of the repo, you can try one of the following commands, according to your OS and preferences sudo mount -t nfs 10.0.137.113:/fsx/ ./output/aws sudo mount_nfs -o resvport 10.0.137.113:/fsx/ ./output/aws After have successfully installed the dependencies and activated the conda environment. Launch the following command from the root of the repo pdm run suam-config install --no-symlink --input = ./eval_pipeline/docs/assets/config/broker.conf.yaml Launch examples \u00b6 Check the example folder and look at the code of the python files to get familiar with the API. Here's some example you can launch. Populate the library of components from the data folder python src/sym_cps/examples/library.py Extracts the seed designs python src/sym_cps/examples/designs.py Create a new design from scratch. First choosing and topology and then concretize it. python src/sym_cps/examples/topology.py Evaluate designs python src/sym_cps/examples/evaluation.py Troubleshooting \u00b6 NOTE: If you have problems with the environment you can clean up the files and folders created by pdm and conda by running make uninstall Then try make setup again. Note Install PDM manually. You can install it with: python3 -m pip install --user pipx pipx install pdm Now you can try running make setup again. Note Problems installing dependencies Look at the setup script located in scripts/setup.sh and launch the commands individually. You can make a clean installation by first running make uninstall and then make setup again. Note Apple Silicon Make sure that you are running a x86 terminal. You can run x86 terminal commands with Apple\u2019s Rosetta 2 by launching: arch -x86_64 /bin/bash Note Conda for Mac with Apple Silicon Some of the packages in conda do not support arm64 architecture. To install all the dependencies correctly on a Mac with Apple Silicon, make sure that you are running conda for x86_64 architecture. You can install miniconda for MacOSX x86_64 by running the following commands curl -L https://repo.anaconda.com/miniconda/Miniconda3-latest-MacOSX-x86_64.sh > Miniconda3-latest-MacOSX-x86_64.sh sh Miniconda3-latest-MacOSX-x86_64.sh Note Working with PEP 582 With PEP 582, dependencies will be installed into pypackages directory under the project root. With PEP 582 enabled globally, you can also use the project interpreter to run scripts directly. Check pdm documentation on PEP 582. To configure VSCode to support PEP 582, open .vscode/settings.json (create one if it does not exist) and add the following entries: { \"python.autoComplete.extraPaths\" : [ \"__pypackages__/3.10/lib\" ], \"python.analysis.extraPaths\" : [ \"__pypackages__/3.10/lib\" ] } Note VSCode and Apple Silicon To run a x86 terminal by default in VSCode. Add the following to your settings.json ```json \"terminal.integrated.profiles.osx\": { \"x86 bash\": { \"path\": \"/usr/bin/arch\", \"args\": [\"-arch\", \"x86_64\", \"/bin/bash\"] } }, \"terminal.integrated.defaultProfile.osx\": \"x86 bash\" NOTE: PyCharm and Apple Silicon Go to Preferences/Tools/Terminal and set the shell path to be: ```bash env /usr/bin/arch -x86_64 /bin/zsh --login License \u00b6 MIT Features and Credits \u00b6 Fully typed with annotations and checked with mypy, PEP561 compatible","title":"Overview"},{"location":"#sym-cps","text":"Symbiotic Design for Cyber Physical Systems Project description available here Documentation available here","title":"sym-cps"},{"location":"#installation","text":"","title":"Installation"},{"location":"#system-requirements","text":"pdm conda Access to the INPUT folder on Google Drive. Copy data and output directories in the root of the repo","title":"System Requirements"},{"location":"#dependencies","text":"To install the dependencies and environment, simply run: make setup The setup script will: * Pull the submodules * Install dependencies via pdm * Create a new conda environment and install the conda dependencies","title":"Dependencies"},{"location":"#activate-conda","text":"Once script terminates successfully you can activate the environment: conda activate ./.venv","title":"Activate conda"},{"location":"#configure-aws","text":"Download the aws-cvpn-config.ovpn configuration file from the INPUT folder on Google Drive and use it to connect to the AWS VPN. Here are the instructions for Linux , MacOS and Windows . Create ./output/aws if it does not exist already. (Optional) notify your IDE to exclude the aws folder from being indexed. For example in PyCharm do Right Click on aws - Mark directory as - Excluded Mount the shared folder in ./output/aws . Instructions here . Suggestion: from the root folder of the repo, you can try one of the following commands, according to your OS and preferences sudo mount -t nfs 10.0.137.113:/fsx/ ./output/aws sudo mount_nfs -o resvport 10.0.137.113:/fsx/ ./output/aws After have successfully installed the dependencies and activated the conda environment. Launch the following command from the root of the repo pdm run suam-config install --no-symlink --input = ./eval_pipeline/docs/assets/config/broker.conf.yaml","title":"Configure AWS"},{"location":"#launch-examples","text":"Check the example folder and look at the code of the python files to get familiar with the API. Here's some example you can launch. Populate the library of components from the data folder python src/sym_cps/examples/library.py Extracts the seed designs python src/sym_cps/examples/designs.py Create a new design from scratch. First choosing and topology and then concretize it. python src/sym_cps/examples/topology.py Evaluate designs python src/sym_cps/examples/evaluation.py","title":"Launch examples"},{"location":"#troubleshooting","text":"NOTE: If you have problems with the environment you can clean up the files and folders created by pdm and conda by running make uninstall Then try make setup again. Note Install PDM manually. You can install it with: python3 -m pip install --user pipx pipx install pdm Now you can try running make setup again. Note Problems installing dependencies Look at the setup script located in scripts/setup.sh and launch the commands individually. You can make a clean installation by first running make uninstall and then make setup again. Note Apple Silicon Make sure that you are running a x86 terminal. You can run x86 terminal commands with Apple\u2019s Rosetta 2 by launching: arch -x86_64 /bin/bash Note Conda for Mac with Apple Silicon Some of the packages in conda do not support arm64 architecture. To install all the dependencies correctly on a Mac with Apple Silicon, make sure that you are running conda for x86_64 architecture. You can install miniconda for MacOSX x86_64 by running the following commands curl -L https://repo.anaconda.com/miniconda/Miniconda3-latest-MacOSX-x86_64.sh > Miniconda3-latest-MacOSX-x86_64.sh sh Miniconda3-latest-MacOSX-x86_64.sh Note Working with PEP 582 With PEP 582, dependencies will be installed into pypackages directory under the project root. With PEP 582 enabled globally, you can also use the project interpreter to run scripts directly. Check pdm documentation on PEP 582. To configure VSCode to support PEP 582, open .vscode/settings.json (create one if it does not exist) and add the following entries: { \"python.autoComplete.extraPaths\" : [ \"__pypackages__/3.10/lib\" ], \"python.analysis.extraPaths\" : [ \"__pypackages__/3.10/lib\" ] } Note VSCode and Apple Silicon To run a x86 terminal by default in VSCode. Add the following to your settings.json ```json \"terminal.integrated.profiles.osx\": { \"x86 bash\": { \"path\": \"/usr/bin/arch\", \"args\": [\"-arch\", \"x86_64\", \"/bin/bash\"] } }, \"terminal.integrated.defaultProfile.osx\": \"x86 bash\" NOTE: PyCharm and Apple Silicon Go to Preferences/Tools/Terminal and set the shell path to be: ```bash env /usr/bin/arch -x86_64 /bin/zsh --login","title":"Troubleshooting"},{"location":"#license","text":"MIT","title":"License"},{"location":"#features-and-credits","text":"Fully typed with annotations and checked with mypy, PEP561 compatible","title":"Features and Credits"},{"location":"changelog/","text":"Changelog \u00b6 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"contributing/","text":"Contributing \u00b6 Contributions are welcome, and they are greatly appreciated! Tasks \u00b6 This project uses duty to run tasks. A Makefile is also provided. Once the project is installed ( make setup ), run make help to see all available tasks Development \u00b6 We use pdm to manage the dependencies. Use pdm add to install new packages. Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) if you updated the documentation or the project dependencies: run make docs-serve go to http://localhost:8000 and check that everything looks good Activate Pre-Commit Hooks pre-commit install","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated!","title":"Contributing"},{"location":"contributing/#tasks","text":"This project uses duty to run tasks. A Makefile is also provided. Once the project is installed ( make setup ), run make help to see all available tasks","title":"Tasks"},{"location":"contributing/#development","text":"We use pdm to manage the dependencies. Use pdm add to install new packages. Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) if you updated the documentation or the project dependencies: run make docs-serve go to http://localhost:8000 and check that everything looks good Activate Pre-Commit Hooks pre-commit install","title":"Development"},{"location":"credits/","text":"Traceback ( most recent call last ): File \"/Users/pier/Projects/berkeley-cps-symbiotic-design_PUBLIC/__pypackages__/3.10/lib/markdown_exec/formatters/python.py\" , line 23 , in _run_python exec ( code , exec_globals ) # noqa: S102 File \"<executed code block>\" , line 59 , in < module > prod_dependencies = get_deps ( File \"<executed code block>\" , line 42 , in get_deps deps [ dep_name ] = { \"license\" : get_license ( dep_name ), ** parsed , ** lock_pkgs [ dep_name ]} KeyError : 'eval-pipeline'","title":"Credits"},{"location":"license/","text":"ISC License Copyright (c) 2021, LOGiCS Team Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies. THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.","title":"License"},{"location":"reference/SUMMARY/","text":"sym_cps classifier cli control database evaluation cli tools examples design_swri designs evaluation library topology grammar hci optimizers concrete_opt params_opt topo_opt representation design concrete elements component connection design_parameters parameter topology library elements c_connector c_parameter c_property c_type library_component tools analyze connectors export design_swri ids parsers learn_from_designs parse parsing_designs parsing_library temp_objects shared paths tools io persistance strings","title":"SUMMARY"},{"location":"reference/sym_cps/","text":"sym_cps package. Develop AI-based approaches to enable correct-by-construction design of Cyber Physical Systems","title":"sym_cps"},{"location":"reference/sym_cps/cli/","text":"Module that contains the command line application. get_parser () \u00b6 Return the CLI argument parser. Returns: Type Description argparse . ArgumentParser An argparse parser. Source code in sym_cps/cli.py 10 11 12 13 14 15 16 17 def get_parser () -> argparse . ArgumentParser : \"\"\" Return the CLI argument parser. Returns: An argparse parser. \"\"\" return argparse . ArgumentParser ( prog = \"sym-cps\" )","title":"cli"},{"location":"reference/sym_cps/cli/#sym_cps.cli.get_parser","text":"Return the CLI argument parser. Returns: Type Description argparse . ArgumentParser An argparse parser. Source code in sym_cps/cli.py 10 11 12 13 14 15 16 17 def get_parser () -> argparse . ArgumentParser : \"\"\" Return the CLI argument parser. Returns: An argparse parser. \"\"\" return argparse . ArgumentParser ( prog = \"sym-cps\" )","title":"get_parser()"},{"location":"reference/sym_cps/classifier/","text":"","title":"classifier"},{"location":"reference/sym_cps/control/","text":"","title":"control"},{"location":"reference/sym_cps/database/","text":"","title":"database"},{"location":"reference/sym_cps/evaluation/","text":"File adapted from: https://github.com/LOGiCS-Project/swri-simple-uam-example evaluate_design ( design_json_path , metadata = None , timeout = 800 , info_only = False ) \u00b6 Evaluate a design_swri.json provided at location 'design_json_path' Metadata to include with the operation, becomes part of metadata.json in the result. Source code in sym_cps/evaluation/__init__.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def evaluate_design ( design_json_path : Path , metadata : Path | dict | None = None , timeout : int = 800 , info_only : bool = False ): \"\"\" Evaluate a design_swri.json provided at location 'design_json_path' Metadata to include with the operation, becomes part of metadata.json in the result. \"\"\" print ( f \"Input file: { design_json_path } \" ) # Load the design from file print ( \"Loading Design\" ) design = load_design ( design_json_path ) # Load the metadata from file print ( \"Loading Metadata (if provided)\" ) metadata = load_metadata ( metadata ) # Send the design to worker print ( \"Sending Design to Broker\" ) if info_only : print ( \"Generating info...\" ) msg = direct2cad . gen_info_files . send ( design , metadata = metadata ) else : print ( \"Processing design...\" ) msg = direct2cad . process_design . send ( design , metadata = metadata ) print ( \"Waiting for results...\" ) result_path = polling_results ( msg , timeout ) print ( f \"Command completed. Results can be found at: { result_path } \" )","title":"evaluation"},{"location":"reference/sym_cps/evaluation/#sym_cps.evaluation.evaluate_design","text":"Evaluate a design_swri.json provided at location 'design_json_path' Metadata to include with the operation, becomes part of metadata.json in the result. Source code in sym_cps/evaluation/__init__.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def evaluate_design ( design_json_path : Path , metadata : Path | dict | None = None , timeout : int = 800 , info_only : bool = False ): \"\"\" Evaluate a design_swri.json provided at location 'design_json_path' Metadata to include with the operation, becomes part of metadata.json in the result. \"\"\" print ( f \"Input file: { design_json_path } \" ) # Load the design from file print ( \"Loading Design\" ) design = load_design ( design_json_path ) # Load the metadata from file print ( \"Loading Metadata (if provided)\" ) metadata = load_metadata ( metadata ) # Send the design to worker print ( \"Sending Design to Broker\" ) if info_only : print ( \"Generating info...\" ) msg = direct2cad . gen_info_files . send ( design , metadata = metadata ) else : print ( \"Processing design...\" ) msg = direct2cad . process_design . send ( design , metadata = metadata ) print ( \"Waiting for results...\" ) result_path = polling_results ( msg , timeout ) print ( f \"Command completed. Results can be found at: { result_path } \" )","title":"evaluate_design()"},{"location":"reference/sym_cps/evaluation/cli/","text":"File adapted from: https://github.com/LOGiCS-Project/swri-simple-uam-example get_args () \u00b6 Creates a parser and returns the arguments for this utility. Source code in sym_cps/evaluation/cli.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def get_args (): \"\"\" Creates a parser and returns the arguments for this utility. \"\"\" parser = argparse . ArgumentParser ( description = 'Process a design' ) parser . add_argument ( '-results_dir' , type = Path , help = 'The directory that will be checked when looking for new results.' , ) parser . add_argument ( '-design_file' , type = Path , help = 'The design file to process' , ) parser . add_argument ( '-m' , '--metadata' , default = None , help = \"Metadata to include with the operation, becomes part of metadata.json in the result.\" , ) parser . add_argument ( '-c' , '--command' , choices = [ 'info' , 'process' ], default = 'info' , help = \"Which command to perform: 'info' = gen info files, 'process' = process design.\" , ) parser . add_argument ( '-w' , '--watch' , choices = [ 'best' , 'backend' , 'polling' ], default = 'best' , help = \"How to wait for results, via backend, polling, or best available.\" , ) parser . add_argument ( '-t' , '--timeout' , type = int , default = 600 , help = \"Timeout, in seconds, before giving up on the command.\" , ) return parser . parse_args ()","title":"cli"},{"location":"reference/sym_cps/evaluation/cli/#sym_cps.evaluation.cli.get_args","text":"Creates a parser and returns the arguments for this utility. Source code in sym_cps/evaluation/cli.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def get_args (): \"\"\" Creates a parser and returns the arguments for this utility. \"\"\" parser = argparse . ArgumentParser ( description = 'Process a design' ) parser . add_argument ( '-results_dir' , type = Path , help = 'The directory that will be checked when looking for new results.' , ) parser . add_argument ( '-design_file' , type = Path , help = 'The design file to process' , ) parser . add_argument ( '-m' , '--metadata' , default = None , help = \"Metadata to include with the operation, becomes part of metadata.json in the result.\" , ) parser . add_argument ( '-c' , '--command' , choices = [ 'info' , 'process' ], default = 'info' , help = \"Which command to perform: 'info' = gen info files, 'process' = process design.\" , ) parser . add_argument ( '-w' , '--watch' , choices = [ 'best' , 'backend' , 'polling' ], default = 'best' , help = \"How to wait for results, via backend, polling, or best available.\" , ) parser . add_argument ( '-t' , '--timeout' , type = int , default = 600 , help = \"Timeout, in seconds, before giving up on the command.\" , ) return parser . parse_args ()","title":"get_args()"},{"location":"reference/sym_cps/evaluation/tools/","text":"File adapted from: https://github.com/LOGiCS-Project/swri-simple-uam-example get_result_archive_path ( result , results_dir ) \u00b6 Get the name of the specific result archive from the backend produced result. Parameters: Name Type Description Default result object The result object returned by wait_on_result required results_dir Path The directory in which all the results will appear. required Source code in sym_cps/evaluation/tools.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def get_result_archive_path ( result : object , results_dir : Path ) -> Path : \"\"\" Get the name of the specific result archive from the backend produced result. Arguments: result: The result object returned by `wait_on_result` results_dir: The directory in which all the results will appear. \"\"\" raw_path = Path ( result [ 'result_archive' ]) return results_dir / raw_path . name get_zip_metadata ( zip_file ) \u00b6 Returns the contents of the zip's metadata.json, if it has one. Parameters: Name Type Description Default zip_file Path The part to the zip we're opening. required Source code in sym_cps/evaluation/tools.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def get_zip_metadata ( zip_file : Path ) -> Optional [ object ]: \"\"\" Returns the contents of the zip's metadata.json, if it has one. Arguments: zip_file: The part to the zip we're opening. \"\"\" # Open Zip file with zipfile . ZipFile ( zip_file ) as zip : meta_file = zipfile . Path ( zip ) / 'metadata.json' # Check if `metadata.json` exists if not meta_file . exists () and meta_file . is_file (): print ( f \"Zip ' { str ( zip_file ) } ' has no metadata.json\" ) return None # If yes, decode its contents with meta_file . open ( 'r' ) as meta : return json . load ( meta ) load_design ( design_file ) \u00b6 Loads a design from file. Parameters: Name Type Description Default design_file Path Path to the design file required Source code in sym_cps/evaluation/tools.py 17 18 19 20 21 22 23 24 25 def load_design ( design_file : Path ) -> object : \"\"\" Loads a design from file. Arguments: design_file: Path to the design file \"\"\" with Path ( design_file ) . open ( 'r' ) as fp : return json . load ( fp ) load_metadata ( metadata_file ) \u00b6 Loads metadata from file. This can be any arbitrary dictionary and its contents will appear in the result archive's metadata.json. Useful for keeping track of where each call comes from in a larger optimization process. Parameters: Name Type Description Default metadata_file Union [ Path , str , None] Path to the metadata file required Source code in sym_cps/evaluation/tools.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def load_metadata ( metadata_file : Union [ Path , str , None ]) -> dict : \"\"\" Loads metadata from file. This can be any arbitrary dictionary and its contents will appear in the result archive's metadata.json. Useful for keeping track of where each call comes from in a larger optimization process. Arguments: metadata_file: Path to the metadata file \"\"\" if not metadata_file : return dict () if isinstance ( metadata_file , dict ): return metadata_file with Path ( metadata_file ) . open ( 'r' ) as fp : meta = json . load ( fp ) if not isinstance ( meta , dict ): raise RuntimeError ( \"Metadata must be JSON serializable dictionary.\" ) return meta match_msg_to_zip ( msg , zip_file ) \u00b6 Checks whether the given message produced the given zip archive. Parameters: Name Type Description Default msg dramatiq . Message The dramatiq message we're checking against required zip_file Path The path to the zip we're verifying required Source code in sym_cps/evaluation/tools.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 def match_msg_to_zip ( msg : dramatiq . Message , zip_file : Path ) -> bool : \"\"\" Checks whether the given message produced the given zip archive. Arguments: msg: The dramatiq message we're checking against zip_file: The path to the zip we're verifying \"\"\" msg_id = msg . message_id metadata = get_zip_metadata ( zip_file ) return metadata and ( 'message_info' in metadata ) and msg_id == metadata [ 'message_info' ][ 'message_id' ] wait_on_result ( msg , interval = 10 , timeout = 600 ) \u00b6 Uses the dramatiq backend mechanism to wait on a result from a worker. EXAMPLE ONLY: DO NOT USE IN PRODUCTION Parameters: Name Type Description Default msg dramatiq . Message The message from the dramatiq send call. required interval int The time, in seconds, to wait between each check of the backend. 10 timeout int The total time, in seconds, to wait for a result before giving up. 600 Source code in sym_cps/evaluation/tools.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def wait_on_result ( msg : dramatiq . Message , interval : int = 10 , timeout : int = 600 ) -> object : \"\"\" Uses the dramatiq backend mechanism to wait on a result from a worker. EXAMPLE ONLY: DO NOT USE IN PRODUCTION Arguments: msg: The message from the dramatiq send call. interval: The time, in seconds, to wait between each check of the backend. timeout: The total time, in seconds, to wait for a result before giving up. \"\"\" elapsed = 0 result = None # Loop until result found while not result : # Try to get Result try : print ( f \"Checking for result @ { elapsed } s\" ) result = msg . get_result ( block = False ) # If no result yet except dramatiq . results . ResultMissing as err : # Check if we're timed out if elapsed >= timeout : raise RuntimeError ( f \"No result found by { elapsed } s\" ) # Else wait another interval elapsed += interval time . sleep ( interval ) return result watch_results_dir ( msg , results_dir , interval = 10 , timeout = 600 ) \u00b6 Checks directory every interval to see if any of the zip files match the provided message. EXAMPLE ONLY: DO NOT USE IN PRODUCTION Parameters: Name Type Description Default msg dramatiq . Message The message we sent to the broker required results_dir Path dir to look for results archive in required interval int delay between each check of the results_dir 10 timeout int time to search for archive before giving up 600 Source code in sym_cps/evaluation/tools.py 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 def watch_results_dir ( msg : dramatiq . Message , results_dir : Path , interval : int = 10 , timeout : int = 600 ) -> Path : \"\"\" Checks directory every interval to see if any of the zip files match the provided message. EXAMPLE ONLY: DO NOT USE IN PRODUCTION Arguments: msg: The message we sent to the broker results_dir: dir to look for results archive in interval: delay between each check of the results_dir timeout: time to search for archive before giving up \"\"\" elapsed = 0 seen = dict () # Wait till we're out of time or have a result while elapsed <= timeout : print ( f \"Checking for result @ { elapsed } s\" ) for zip_file in results_dir . iterdir (): # Check if file is a valid zip valid_zip = zip_file . is_file () valid_zip = valid_zip and '.zip' == zip_file . suffix valid_zip = valid_zip and zip_file not in seen # Skip further checks if not zip if not valid_zip : continue # return file if match found, else mark as seen. print ( f \"Checking zip file: { str ( zip_file ) } \" ) if match_msg_to_zip ( msg , zip_file ): return zip_file else : seen [ zip_file ] = True # Using seen as set # Wait for next interval elapsed += interval time . sleep ( interval ) raise RuntimeError ( f \"No result found by { elapsed } s\" )","title":"tools"},{"location":"reference/sym_cps/evaluation/tools/#sym_cps.evaluation.tools.get_result_archive_path","text":"Get the name of the specific result archive from the backend produced result. Parameters: Name Type Description Default result object The result object returned by wait_on_result required results_dir Path The directory in which all the results will appear. required Source code in sym_cps/evaluation/tools.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def get_result_archive_path ( result : object , results_dir : Path ) -> Path : \"\"\" Get the name of the specific result archive from the backend produced result. Arguments: result: The result object returned by `wait_on_result` results_dir: The directory in which all the results will appear. \"\"\" raw_path = Path ( result [ 'result_archive' ]) return results_dir / raw_path . name","title":"get_result_archive_path()"},{"location":"reference/sym_cps/evaluation/tools/#sym_cps.evaluation.tools.get_zip_metadata","text":"Returns the contents of the zip's metadata.json, if it has one. Parameters: Name Type Description Default zip_file Path The part to the zip we're opening. required Source code in sym_cps/evaluation/tools.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def get_zip_metadata ( zip_file : Path ) -> Optional [ object ]: \"\"\" Returns the contents of the zip's metadata.json, if it has one. Arguments: zip_file: The part to the zip we're opening. \"\"\" # Open Zip file with zipfile . ZipFile ( zip_file ) as zip : meta_file = zipfile . Path ( zip ) / 'metadata.json' # Check if `metadata.json` exists if not meta_file . exists () and meta_file . is_file (): print ( f \"Zip ' { str ( zip_file ) } ' has no metadata.json\" ) return None # If yes, decode its contents with meta_file . open ( 'r' ) as meta : return json . load ( meta )","title":"get_zip_metadata()"},{"location":"reference/sym_cps/evaluation/tools/#sym_cps.evaluation.tools.load_design","text":"Loads a design from file. Parameters: Name Type Description Default design_file Path Path to the design file required Source code in sym_cps/evaluation/tools.py 17 18 19 20 21 22 23 24 25 def load_design ( design_file : Path ) -> object : \"\"\" Loads a design from file. Arguments: design_file: Path to the design file \"\"\" with Path ( design_file ) . open ( 'r' ) as fp : return json . load ( fp )","title":"load_design()"},{"location":"reference/sym_cps/evaluation/tools/#sym_cps.evaluation.tools.load_metadata","text":"Loads metadata from file. This can be any arbitrary dictionary and its contents will appear in the result archive's metadata.json. Useful for keeping track of where each call comes from in a larger optimization process. Parameters: Name Type Description Default metadata_file Union [ Path , str , None] Path to the metadata file required Source code in sym_cps/evaluation/tools.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def load_metadata ( metadata_file : Union [ Path , str , None ]) -> dict : \"\"\" Loads metadata from file. This can be any arbitrary dictionary and its contents will appear in the result archive's metadata.json. Useful for keeping track of where each call comes from in a larger optimization process. Arguments: metadata_file: Path to the metadata file \"\"\" if not metadata_file : return dict () if isinstance ( metadata_file , dict ): return metadata_file with Path ( metadata_file ) . open ( 'r' ) as fp : meta = json . load ( fp ) if not isinstance ( meta , dict ): raise RuntimeError ( \"Metadata must be JSON serializable dictionary.\" ) return meta","title":"load_metadata()"},{"location":"reference/sym_cps/evaluation/tools/#sym_cps.evaluation.tools.match_msg_to_zip","text":"Checks whether the given message produced the given zip archive. Parameters: Name Type Description Default msg dramatiq . Message The dramatiq message we're checking against required zip_file Path The path to the zip we're verifying required Source code in sym_cps/evaluation/tools.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 def match_msg_to_zip ( msg : dramatiq . Message , zip_file : Path ) -> bool : \"\"\" Checks whether the given message produced the given zip archive. Arguments: msg: The dramatiq message we're checking against zip_file: The path to the zip we're verifying \"\"\" msg_id = msg . message_id metadata = get_zip_metadata ( zip_file ) return metadata and ( 'message_info' in metadata ) and msg_id == metadata [ 'message_info' ][ 'message_id' ]","title":"match_msg_to_zip()"},{"location":"reference/sym_cps/evaluation/tools/#sym_cps.evaluation.tools.wait_on_result","text":"Uses the dramatiq backend mechanism to wait on a result from a worker. EXAMPLE ONLY: DO NOT USE IN PRODUCTION Parameters: Name Type Description Default msg dramatiq . Message The message from the dramatiq send call. required interval int The time, in seconds, to wait between each check of the backend. 10 timeout int The total time, in seconds, to wait for a result before giving up. 600 Source code in sym_cps/evaluation/tools.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def wait_on_result ( msg : dramatiq . Message , interval : int = 10 , timeout : int = 600 ) -> object : \"\"\" Uses the dramatiq backend mechanism to wait on a result from a worker. EXAMPLE ONLY: DO NOT USE IN PRODUCTION Arguments: msg: The message from the dramatiq send call. interval: The time, in seconds, to wait between each check of the backend. timeout: The total time, in seconds, to wait for a result before giving up. \"\"\" elapsed = 0 result = None # Loop until result found while not result : # Try to get Result try : print ( f \"Checking for result @ { elapsed } s\" ) result = msg . get_result ( block = False ) # If no result yet except dramatiq . results . ResultMissing as err : # Check if we're timed out if elapsed >= timeout : raise RuntimeError ( f \"No result found by { elapsed } s\" ) # Else wait another interval elapsed += interval time . sleep ( interval ) return result","title":"wait_on_result()"},{"location":"reference/sym_cps/evaluation/tools/#sym_cps.evaluation.tools.watch_results_dir","text":"Checks directory every interval to see if any of the zip files match the provided message. EXAMPLE ONLY: DO NOT USE IN PRODUCTION Parameters: Name Type Description Default msg dramatiq . Message The message we sent to the broker required results_dir Path dir to look for results archive in required interval int delay between each check of the results_dir 10 timeout int time to search for archive before giving up 600 Source code in sym_cps/evaluation/tools.py 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 def watch_results_dir ( msg : dramatiq . Message , results_dir : Path , interval : int = 10 , timeout : int = 600 ) -> Path : \"\"\" Checks directory every interval to see if any of the zip files match the provided message. EXAMPLE ONLY: DO NOT USE IN PRODUCTION Arguments: msg: The message we sent to the broker results_dir: dir to look for results archive in interval: delay between each check of the results_dir timeout: time to search for archive before giving up \"\"\" elapsed = 0 seen = dict () # Wait till we're out of time or have a result while elapsed <= timeout : print ( f \"Checking for result @ { elapsed } s\" ) for zip_file in results_dir . iterdir (): # Check if file is a valid zip valid_zip = zip_file . is_file () valid_zip = valid_zip and '.zip' == zip_file . suffix valid_zip = valid_zip and zip_file not in seen # Skip further checks if not zip if not valid_zip : continue # return file if match found, else mark as seen. print ( f \"Checking zip file: { str ( zip_file ) } \" ) if match_msg_to_zip ( msg , zip_file ): return zip_file else : seen [ zip_file ] = True # Using seen as set # Wait for next interval elapsed += interval time . sleep ( interval ) raise RuntimeError ( f \"No result found by { elapsed } s\" )","title":"watch_results_dir()"},{"location":"reference/sym_cps/examples/","text":"","title":"examples"},{"location":"reference/sym_cps/examples/design_swri/","text":"Generate design swri files for all designs in the library","title":"design_swri"},{"location":"reference/sym_cps/examples/designs/","text":"export_design_json ( design_name = 'Trowel' , designs_dat_file = 'designs.dat' ) \u00b6 Produce the json file representing the design Source code in sym_cps/examples/designs.py 12 13 14 15 16 17 18 19 20 21 22 23 def export_design_json ( design_name : str = \"Trowel\" , designs_dat_file : str = \"designs.dat\" ): \"\"\"Produce the json file representing the design\"\"\" designs : dict [ str , tuple [ DConcrete , DTopology ]] = load ( designs_dat_file ) # type: ignore d_concrete = designs [ design_name ][ 0 ] save_to_file ( str ( json . dumps ( d_concrete . to_design_swri )), file_name = f \"design_swri.json\" , absolute_folder_path = designs_folder / d_concrete . name , ) print ( f \" { design_name } exported to json\" ) load_design_json ( design_name = 'Trowel' , library_dat_file = 'library.dat' ) \u00b6 Load a design from json format Source code in sym_cps/examples/designs.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def load_design_json ( design_name : str = \"Trowel\" , library_dat_file : str = \"library.dat\" ): \"\"\"Load a design from json format\"\"\" \"\"\"BUG: FIXME: Does not work with new designs, e.g. NewAxe\"\"\" c_library : Library = load ( library_dat_file ) # type: ignore design_swri_path = designs_folder / design_name / \"design_swri.json\" d_concrete : DConcrete = parse_design_from_design_swri ( path = design_swri_path , library = c_library ) d_topology : DTopology = DTopology . from_concrete ( d_concrete ) print ( d_concrete ) print ( d_topology ) print ( f \" { design_name } imported from json\" )","title":"designs"},{"location":"reference/sym_cps/examples/designs/#sym_cps.examples.designs.export_design_json","text":"Produce the json file representing the design Source code in sym_cps/examples/designs.py 12 13 14 15 16 17 18 19 20 21 22 23 def export_design_json ( design_name : str = \"Trowel\" , designs_dat_file : str = \"designs.dat\" ): \"\"\"Produce the json file representing the design\"\"\" designs : dict [ str , tuple [ DConcrete , DTopology ]] = load ( designs_dat_file ) # type: ignore d_concrete = designs [ design_name ][ 0 ] save_to_file ( str ( json . dumps ( d_concrete . to_design_swri )), file_name = f \"design_swri.json\" , absolute_folder_path = designs_folder / d_concrete . name , ) print ( f \" { design_name } exported to json\" )","title":"export_design_json()"},{"location":"reference/sym_cps/examples/designs/#sym_cps.examples.designs.load_design_json","text":"Load a design from json format Source code in sym_cps/examples/designs.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def load_design_json ( design_name : str = \"Trowel\" , library_dat_file : str = \"library.dat\" ): \"\"\"Load a design from json format\"\"\" \"\"\"BUG: FIXME: Does not work with new designs, e.g. NewAxe\"\"\" c_library : Library = load ( library_dat_file ) # type: ignore design_swri_path = designs_folder / design_name / \"design_swri.json\" d_concrete : DConcrete = parse_design_from_design_swri ( path = design_swri_path , library = c_library ) d_topology : DTopology = DTopology . from_concrete ( d_concrete ) print ( d_concrete ) print ( d_topology ) print ( f \" { design_name } imported from json\" )","title":"load_design_json()"},{"location":"reference/sym_cps/examples/evaluation/","text":"","title":"evaluation"},{"location":"reference/sym_cps/examples/library/","text":"export_library ( library_txt_file = 'library.txt' , library_dat_file = 'library.dat' , designs_dat_file = 'designs.dat' ) \u00b6 Export library and seed designs to text files Source code in sym_cps/examples/library.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def export_library ( library_txt_file : str = \"library.txt\" , library_dat_file : str = \"library.dat\" , designs_dat_file : str = \"designs.dat\" ): \"\"\"Export library and seed designs to text files\"\"\" c_library : Library = load ( library_dat_file ) # type: ignore save_to_file ( str ( c_library ), file_name = library_txt_file , absolute_folder_path = library_folder ) \"\"\"In the following we can see some of the 'temporary objects' that have been build while building the components and designs libraries. We will save them to a text file in the output folder\"\"\" # Maps component type to all the LibraryComponent objects belonging to the type save_to_file ( repr_dictionary ( c_library . components_in_type ), \"all_components_in_type.txt\" , folder_name = \"library\" ) # Maps each component type to a set of components type which it can be connected to\"\"\" connectable_components_types : dict [ CType , set [ CType ]] = {} for ctype in c_library . component_types . values (): connectable_components_types [ ctype ] = set ( ctype . compatible_with . values ()) save_to_file ( repr_dictionary ( connectable_components_types ), \"connectable_components_types.txt\" , folder_name = \"library\" ) # Maps connector_id to its LibraryConnector object\"\"\" save_to_file ( repr_dictionary ( c_library . connectors ), \"all_connectors.txt\" , folder_name = \"library\" ) # Maps connector to a set of 'compatible' connectors it can be connected to\"\"\" connectable_connectors : dict [ CConnector , set [ CConnector ]] = {} for connector in c_library . connectors . values (): connectable_connectors [ connector ] = set ( connector . compatible_with . values ()) save_to_file ( repr_dictionary ( connectable_connectors ), \"connectable_connectors.txt\" , folder_name = \"library\" ) # all_parameters_upper_bounds: dict[str, float] = {} # Maps parameter_id to its upper bounds\"\"\" save_to_file ( repr_dictionary ( all_parameters_upper_bounds ), \"all_parameters_upper_bounds.txt\" , folder_name = \"library\" ) # all_parameters_lower_bounds: dict[str, float] = {} # Maps parameter_id to its lower bounds\"\"\" save_to_file ( repr_dictionary ( all_parameters_lower_bounds ), \"all_parameters_lower_bounds.txt\" , folder_name = \"library\" ) # all_parameters: dict[str, CParameterType] = {} # Maps parameter_id to CParameterType object\"\"\" save_to_file ( repr_dictionary ( c_library . parameters ), \"all_parameters.txt\" , folder_name = \"library\" ) # Maps parameter_id to a set of component types it belongs to\"\"\" parameter_to_components_types : dict [ str , set [ str ]] = {} for para_id , parameter in c_library . parameters . items (): if para_id not in parameter_to_components_types . keys (): parameter_to_components_types [ para_id ] = set () parameter_to_components_types [ para_id ] . add ( parameter . belongs_to ) save_to_file ( repr_dictionary ( parameter_to_components_types ), \"parameter_to_components_types.txt\" , folder_name = \"library\" ) designs : dict [ str , tuple [ DConcrete , DTopology ]] = load ( designs_dat_file ) # type: ignore for d_concrete , d_topology in designs . values (): save_to_file ( str ( d_concrete ), file_name = f \"DConcrete\" , absolute_folder_path = designs_folder / d_concrete . name , ) save_to_file ( str ( d_topology ), file_name = f \"DTopology\" , absolute_folder_path = designs_folder / d_concrete . name , ) parse_library ( library_dat_file = 'library.dat' , designs_dat_file = 'designs.dat' ) \u00b6 Loads library of components and seed designs and store them Source code in sym_cps/examples/library.py 14 15 16 17 18 19 def parse_library ( library_dat_file : str = \"library.dat\" , designs_dat_file : str = \"designs.dat\" ): \"\"\"Loads library of components and seed designs and store them\"\"\" c_library , designs = parse_library_and_seed_designs () dump ( c_library , library_dat_file ) dump ( designs , designs_dat_file )","title":"library"},{"location":"reference/sym_cps/examples/library/#sym_cps.examples.library.export_library","text":"Export library and seed designs to text files Source code in sym_cps/examples/library.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def export_library ( library_txt_file : str = \"library.txt\" , library_dat_file : str = \"library.dat\" , designs_dat_file : str = \"designs.dat\" ): \"\"\"Export library and seed designs to text files\"\"\" c_library : Library = load ( library_dat_file ) # type: ignore save_to_file ( str ( c_library ), file_name = library_txt_file , absolute_folder_path = library_folder ) \"\"\"In the following we can see some of the 'temporary objects' that have been build while building the components and designs libraries. We will save them to a text file in the output folder\"\"\" # Maps component type to all the LibraryComponent objects belonging to the type save_to_file ( repr_dictionary ( c_library . components_in_type ), \"all_components_in_type.txt\" , folder_name = \"library\" ) # Maps each component type to a set of components type which it can be connected to\"\"\" connectable_components_types : dict [ CType , set [ CType ]] = {} for ctype in c_library . component_types . values (): connectable_components_types [ ctype ] = set ( ctype . compatible_with . values ()) save_to_file ( repr_dictionary ( connectable_components_types ), \"connectable_components_types.txt\" , folder_name = \"library\" ) # Maps connector_id to its LibraryConnector object\"\"\" save_to_file ( repr_dictionary ( c_library . connectors ), \"all_connectors.txt\" , folder_name = \"library\" ) # Maps connector to a set of 'compatible' connectors it can be connected to\"\"\" connectable_connectors : dict [ CConnector , set [ CConnector ]] = {} for connector in c_library . connectors . values (): connectable_connectors [ connector ] = set ( connector . compatible_with . values ()) save_to_file ( repr_dictionary ( connectable_connectors ), \"connectable_connectors.txt\" , folder_name = \"library\" ) # all_parameters_upper_bounds: dict[str, float] = {} # Maps parameter_id to its upper bounds\"\"\" save_to_file ( repr_dictionary ( all_parameters_upper_bounds ), \"all_parameters_upper_bounds.txt\" , folder_name = \"library\" ) # all_parameters_lower_bounds: dict[str, float] = {} # Maps parameter_id to its lower bounds\"\"\" save_to_file ( repr_dictionary ( all_parameters_lower_bounds ), \"all_parameters_lower_bounds.txt\" , folder_name = \"library\" ) # all_parameters: dict[str, CParameterType] = {} # Maps parameter_id to CParameterType object\"\"\" save_to_file ( repr_dictionary ( c_library . parameters ), \"all_parameters.txt\" , folder_name = \"library\" ) # Maps parameter_id to a set of component types it belongs to\"\"\" parameter_to_components_types : dict [ str , set [ str ]] = {} for para_id , parameter in c_library . parameters . items (): if para_id not in parameter_to_components_types . keys (): parameter_to_components_types [ para_id ] = set () parameter_to_components_types [ para_id ] . add ( parameter . belongs_to ) save_to_file ( repr_dictionary ( parameter_to_components_types ), \"parameter_to_components_types.txt\" , folder_name = \"library\" ) designs : dict [ str , tuple [ DConcrete , DTopology ]] = load ( designs_dat_file ) # type: ignore for d_concrete , d_topology in designs . values (): save_to_file ( str ( d_concrete ), file_name = f \"DConcrete\" , absolute_folder_path = designs_folder / d_concrete . name , ) save_to_file ( str ( d_topology ), file_name = f \"DTopology\" , absolute_folder_path = designs_folder / d_concrete . name , )","title":"export_library()"},{"location":"reference/sym_cps/examples/library/#sym_cps.examples.library.parse_library","text":"Loads library of components and seed designs and store them Source code in sym_cps/examples/library.py 14 15 16 17 18 19 def parse_library ( library_dat_file : str = \"library.dat\" , designs_dat_file : str = \"designs.dat\" ): \"\"\"Loads library of components and seed designs and store them\"\"\" c_library , designs = parse_library_and_seed_designs () dump ( c_library , library_dat_file ) dump ( designs , designs_dat_file )","title":"parse_library()"},{"location":"reference/sym_cps/examples/topology/","text":"random_topology ( design_name = 'Trowel' , designs_dat_file = 'designs.dat' ) \u00b6 Generate Topology DTopology, random strategy Source code in sym_cps/examples/topology.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def random_topology ( design_name : str = \"Trowel\" , designs_dat_file : str = \"designs.dat\" ): \"\"\"Generate Topology DTopology, random strategy\"\"\" d_topology : DTopology = topo_opt . generate_topology ( name = \"RandomDesign\" , strategy = TopologyStrategy . random_strategy ) print ( \"****D_TOPOLOGY****\" ) print ( d_topology ) d_topology . export ( ExportType . TXT ) d_topology . export ( ExportType . DOT ) \"\"\"Refine DTopology to DConcrete, random strategy\"\"\" d_concrete : DConcrete = concr_opt . concretize_topology ( d_topology = d_topology , strategy = ConcreteStrategy . random_strategy ) print ( \" \\n ****D_CONCRETE****\" ) print ( d_concrete ) d_concrete . export ( ExportType . TXT ) d_concrete . export ( ExportType . DOT ) d_concrete . export ( ExportType . JSON ) d_concrete . export ( ExportType . PDF )","title":"topology"},{"location":"reference/sym_cps/examples/topology/#sym_cps.examples.topology.random_topology","text":"Generate Topology DTopology, random strategy Source code in sym_cps/examples/topology.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def random_topology ( design_name : str = \"Trowel\" , designs_dat_file : str = \"designs.dat\" ): \"\"\"Generate Topology DTopology, random strategy\"\"\" d_topology : DTopology = topo_opt . generate_topology ( name = \"RandomDesign\" , strategy = TopologyStrategy . random_strategy ) print ( \"****D_TOPOLOGY****\" ) print ( d_topology ) d_topology . export ( ExportType . TXT ) d_topology . export ( ExportType . DOT ) \"\"\"Refine DTopology to DConcrete, random strategy\"\"\" d_concrete : DConcrete = concr_opt . concretize_topology ( d_topology = d_topology , strategy = ConcreteStrategy . random_strategy ) print ( \" \\n ****D_CONCRETE****\" ) print ( d_concrete ) d_concrete . export ( ExportType . TXT ) d_concrete . export ( ExportType . DOT ) d_concrete . export ( ExportType . JSON ) d_concrete . export ( ExportType . PDF )","title":"random_topology()"},{"location":"reference/sym_cps/grammar/","text":"","title":"grammar"},{"location":"reference/sym_cps/hci/","text":"","title":"hci"},{"location":"reference/sym_cps/optimizers/","text":"","title":"optimizers"},{"location":"reference/sym_cps/optimizers/concrete_opt/","text":"Test ConcreteStrategy \u00b6 Bases: Enum Test Class Source code in sym_cps/optimizers/concrete_opt/__init__.py 16 17 18 19 20 class ConcreteStrategy ( Enum ): \"\"\" Test Class \"\"\" random_strategy = auto ()","title":"concrete_opt"},{"location":"reference/sym_cps/optimizers/concrete_opt/#sym_cps.optimizers.concrete_opt.ConcreteStrategy","text":"Bases: Enum Test Class Source code in sym_cps/optimizers/concrete_opt/__init__.py 16 17 18 19 20 class ConcreteStrategy ( Enum ): \"\"\" Test Class \"\"\" random_strategy = auto ()","title":"ConcreteStrategy"},{"location":"reference/sym_cps/optimizers/params_opt/","text":"","title":"params_opt"},{"location":"reference/sym_cps/optimizers/topo_opt/","text":"","title":"topo_opt"},{"location":"reference/sym_cps/representation/","text":"","title":"representation"},{"location":"reference/sym_cps/representation/design/","text":"","title":"design"},{"location":"reference/sym_cps/representation/design/concrete/","text":"Test Documentation DConcrete dataclass \u00b6 A class representing a Concrete Design ... Attributes \u00b6 str name of the design dict[str, DesignParameter] design parameters Source code in sym_cps/representation/design/concrete/__init__.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 @dataclass class DConcrete : \"\"\" A class representing a Concrete Design ... Attributes ---------- name : str name of the design design_parameters : dict[str, DesignParameter] design parameters \"\"\" name : str design_parameters : dict [ str , DesignParameter ] = field ( default_factory = dict ) def __post_init__ ( self ): self . _graph = Graph () @property def graph ( self ) -> Graph : return self . _graph @property def nodes ( self ) -> list [ igraph . Vertex ]: return list ( self . graph . vs ) @property def edges ( self ) -> list [ igraph . Edge ]: return list ( self . graph . es ) def get_vertex_by_id ( self , vid : int ) -> igraph . Vertex : return self . graph . vs [ vid ] @property def n_nodes ( self ) -> int : return len ( self . graph . vs ) @property def n_edges ( self ) -> int : return len ( self . graph . es ) def add_node ( self , component : Component ) -> igraph . Vertex : return self . graph . add_vertex ( instance = component . id , library_component = component . library_component , c_type = component . c_type , component = component , ) def remove_node ( self ): \"\"\"TODO\"\"\" raise NotImplementedError def add_edge ( self , node_id_a : int , node_id_b : int , connection : Connection ): self . graph . add_edge ( source = node_id_a , target = node_id_b , connection = connection ) def connect ( self , connection : Connection ): a = self . get_node_by_instance ( connection . component_a . id ) . index b = self . get_node_by_instance ( connection . component_b . id ) . index self . add_edge ( a , b , connection ) def remove_edge ( self ): \"\"\"TODO. Tip: self.graph.delete_edges\"\"\" raise NotImplementedError def disconnect ( self , connection : Connection ): \"\"\"TODO. Might want to remove a Connection, retrieve the node_id from the Connection\"\"\" raise NotImplementedError @property def components ( self ) -> set [ Component | None ]: if self . n_nodes > 0 : return set ( self . graph . vs ()[ \"component\" ]) return set () @property def connections ( self ) -> set [ Connection | None ]: if self . n_nodes > 0 : if self . n_edges > 0 : return set ( self . graph . es ()[ \"connection\" ]) return set () def get_node_by_instance ( self , instance : str ) -> igraph . Vertex | None : if self . n_nodes > 0 : nodes = self . graph . vs . select ( instance = instance ) if len ( nodes ) == 1 : return nodes [ 0 ] return None def get_instance ( self , instance : str ) -> Component | None : if self . n_nodes > 0 : nodes = self . graph . vs . select ( instance = instance ) if len ( nodes ) == 1 : return nodes [ \"component\" ][ 0 ] return None def select ( self , library_component : LibraryComponent | None = None , component_type : CType | None = None , ) -> set [ Component ]: components = set () if library_component is not None : return set ( self . graph . vs . select ( library_component = library_component )[ \"component\" ] ) if component_type is not None : return set ( self . graph . vs . select ( component_type = component_type )[ \"component\" ]) return components @property def all_library_components_component_class ( self , ) -> dict [ CType , set [ LibraryComponent ]]: \"\"\"Returns all LibraryComponent for each Component class in the design\"\"\" comp_types_n : dict [ CType , set [ LibraryComponent ]] = {} for component in self . components : if component . c_type in comp_types_n . keys (): comp_types_n [ component . c_type ] . add ( component . library_component ) else : comp_types_n [ component . c_type ] = { component . library_component } return comp_types_n @property def all_components_by_library_components ( self , ) -> dict [ LibraryComponent , set [ Component ]]: \"\"\"Returns all Components for each LibraryComponent in the design\"\"\" comp_types_n : dict [ LibraryComponent , set [ Component ]] = {} for component in self . components : if component . library_component in comp_types_n . keys (): comp_types_n [ component . library_component ] . add ( component ) else : comp_types_n [ component . library_component ] = { component } return comp_types_n def validate ( self ): \"\"\"Validates the Parameters of the Design\"\"\" raise NotImplementedError def evaluate ( self ): \"\"\"Sends the Design for evaluation\"\"\" raise NotImplementedError def evaluation ( self , evaluation_results_json : str ): \"\"\"Parse and update the evaluation of the Design\"\"\" raise NotImplementedError def export_to_cad ( self ): \"\"\"Generates a CAD representation of the Design\"\"\" raise NotImplementedError @property def to_design_swri ( self ) -> dict [ str , str ]: \"\"\"Generate design_swri.json format file from a concrete design design: the concrete design exporting to design_swri.json file output_path: file path for the export file. \"\"\" design_swri_data = {} \"\"\" Storing the design name\"\"\" design_swri_data [ \"name\" ] = self . name \"\"\"Storing parameters\"\"\" data_parameters : list = [] for component in self . components : for parameter_id , parameter in component . parameters . items (): data_parameters . append ( { \"parameter_name\" : f \" { component . id } _ { parameter . c_parameter . name } \" , \"value\" : str ( int ( parameter . value )), \"component_properties\" : [ { \"component_name\" : component . id , \"component_property\" : parameter . c_parameter . name , } ], } ) design_swri_data [ \"parameters\" ] = data_parameters \"\"\"Storing components\"\"\" data_components : list [ dict [ str , str ]] = [] for component in self . components : data_components . append ( { \"component_instance\" : component . id , \"component_type\" : component . c_type . id , \"component_choice\" : component . model , } ) design_swri_data [ \"components\" ] = data_components \"\"\"Storing connections\"\"\" data_connections : list [ dict [ str , str ]] = [] for connection in self . connections : data_connections . append ( { \"from_ci\" : connection . component_a . id , \"from_conn\" : connection . connector_a . name , \"to_ci\" : connection . component_b . id , \"to_conn\" : connection . connector_b . name , } ) data_connections . append ( { \"from_ci\" : connection . component_b . id , \"from_conn\" : connection . connector_b . name , \"to_ci\" : connection . component_a . id , \"to_conn\" : connection . connector_a . name , } ) design_swri_data [ \"connections\" ] = data_connections return design_swri_data def export ( self , file_type : ExportType ): absolute_folder = designs_folder / self . name if file_type == ExportType . TXT : save_to_file ( str ( self ), file_name = f \"DTopology\" , absolute_folder_path = absolute_folder , ) elif file_type == ExportType . JSON : save_to_file ( str ( json . dumps ( self . to_design_swri )), file_name = f \"design_swri.json\" , absolute_folder_path = absolute_folder , ) elif file_type == ExportType . DOT : self . graph . write_dot ( f = str ( absolute_folder / \"concrete_graph.dot\" )) elif file_type == ExportType . PDF : if self . n_nodes > 0 : layout = self . graph . layout ( \"kk\" ) \"\"\"Adding labels to nodes\"\"\" self . graph . vs [ \"label\" ] = self . graph . vs [ \"c_type\" ] fig , ax = plt . subplots () plot ( self . graph , layout = layout , target = ax ) plt . savefig ( absolute_folder / \"concrete_graph.pdf\" ) else : raise Exception ( \"File type not supported\" ) print ( f \" { file_type } file saved in { absolute_folder } \" ) def draw ( self , name ): if self . n_nodes > 0 : layout = self . graph . layout ( \"kk\" ) fig , ax = plt . subplots () plot ( self . graph , layout = layout , target = ax ) file_name_path = output_folder / \"graphs\" / name plt . savefig ( f \" { file_name_path } .pdf\" ) def __eq__ ( self , other : object ): pass def __ne__ ( self , other : object ): if not isinstance ( other , DConcrete ): return NotImplementedError return not self . __eq__ ( other ) def __str__ ( self ): n_library_component_by_class = [] for k , v in self . all_library_components_component_class . items (): n_library_component_by_class . append ( f \" \\t { k } : { len ( v ) } \" ) n_library_component_by_class_str = \" \\n \" . join ( n_library_component_by_class ) components_list = [] for ( components_class , library_components , ) in self . all_library_components_component_class . items (): components_list . append ( tab ( f \"COMPONENT type: { components_class } \" )) for library_component in library_components : components_list . append ( tab ( tab ( f \"LIBRARY COMPONENT: { library_component . id } \" )) ) components = self . select ( library_component = library_component ) for component in components : components_list . append ( tab ( tab ( tab ( f \"COMPONENT: { component . id } \" )))) components_list . append ( tab ( tab ( tab ( component )))) components_list . append ( \" \\n\\t +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\" ) components_str = \" \\n \" . join ( components_list ) s1 = ( f \"name: { self . name } \\n \" f \"#_components: { len ( self . components ) } \\n \" f \"#_connections: { len ( self . connections ) } \\n \" f \"#_component_classes: \\n { n_library_component_by_class_str } \\n \" f \"components: \\n { components_str } \\n \" ) return s1 all_components_by_library_components () property \u00b6 Returns all Components for each LibraryComponent in the design Source code in sym_cps/representation/design/concrete/__init__.py 148 149 150 151 152 153 154 155 156 157 158 159 @property def all_components_by_library_components ( self , ) -> dict [ LibraryComponent , set [ Component ]]: \"\"\"Returns all Components for each LibraryComponent in the design\"\"\" comp_types_n : dict [ LibraryComponent , set [ Component ]] = {} for component in self . components : if component . library_component in comp_types_n . keys (): comp_types_n [ component . library_component ] . add ( component ) else : comp_types_n [ component . library_component ] = { component } return comp_types_n all_library_components_component_class () property \u00b6 Returns all LibraryComponent for each Component class in the design Source code in sym_cps/representation/design/concrete/__init__.py 135 136 137 138 139 140 141 142 143 144 145 146 @property def all_library_components_component_class ( self , ) -> dict [ CType , set [ LibraryComponent ]]: \"\"\"Returns all LibraryComponent for each Component class in the design\"\"\" comp_types_n : dict [ CType , set [ LibraryComponent ]] = {} for component in self . components : if component . c_type in comp_types_n . keys (): comp_types_n [ component . c_type ] . add ( component . library_component ) else : comp_types_n [ component . c_type ] = { component . library_component } return comp_types_n disconnect ( connection ) \u00b6 TODO. Might want to remove a Connection, retrieve the node_id from the Connection Source code in sym_cps/representation/design/concrete/__init__.py 90 91 92 def disconnect ( self , connection : Connection ): \"\"\"TODO. Might want to remove a Connection, retrieve the node_id from the Connection\"\"\" raise NotImplementedError evaluate () \u00b6 Sends the Design for evaluation Source code in sym_cps/representation/design/concrete/__init__.py 165 166 167 def evaluate ( self ): \"\"\"Sends the Design for evaluation\"\"\" raise NotImplementedError evaluation ( evaluation_results_json ) \u00b6 Parse and update the evaluation of the Design Source code in sym_cps/representation/design/concrete/__init__.py 169 170 171 def evaluation ( self , evaluation_results_json : str ): \"\"\"Parse and update the evaluation of the Design\"\"\" raise NotImplementedError export_to_cad () \u00b6 Generates a CAD representation of the Design Source code in sym_cps/representation/design/concrete/__init__.py 173 174 175 def export_to_cad ( self ): \"\"\"Generates a CAD representation of the Design\"\"\" raise NotImplementedError remove_edge () \u00b6 TODO. Tip: self.graph.delete_edges Source code in sym_cps/representation/design/concrete/__init__.py 86 87 88 def remove_edge ( self ): \"\"\"TODO. Tip: self.graph.delete_edges\"\"\" raise NotImplementedError remove_node () \u00b6 TODO Source code in sym_cps/representation/design/concrete/__init__.py 74 75 76 def remove_node ( self ): \"\"\"TODO\"\"\" raise NotImplementedError to_design_swri () property \u00b6 Generate design_swri.json format file from a concrete design design: the concrete design exporting to design_swri.json file output_path: file path for the export file. Source code in sym_cps/representation/design/concrete/__init__.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 @property def to_design_swri ( self ) -> dict [ str , str ]: \"\"\"Generate design_swri.json format file from a concrete design design: the concrete design exporting to design_swri.json file output_path: file path for the export file. \"\"\" design_swri_data = {} \"\"\" Storing the design name\"\"\" design_swri_data [ \"name\" ] = self . name \"\"\"Storing parameters\"\"\" data_parameters : list = [] for component in self . components : for parameter_id , parameter in component . parameters . items (): data_parameters . append ( { \"parameter_name\" : f \" { component . id } _ { parameter . c_parameter . name } \" , \"value\" : str ( int ( parameter . value )), \"component_properties\" : [ { \"component_name\" : component . id , \"component_property\" : parameter . c_parameter . name , } ], } ) design_swri_data [ \"parameters\" ] = data_parameters \"\"\"Storing components\"\"\" data_components : list [ dict [ str , str ]] = [] for component in self . components : data_components . append ( { \"component_instance\" : component . id , \"component_type\" : component . c_type . id , \"component_choice\" : component . model , } ) design_swri_data [ \"components\" ] = data_components \"\"\"Storing connections\"\"\" data_connections : list [ dict [ str , str ]] = [] for connection in self . connections : data_connections . append ( { \"from_ci\" : connection . component_a . id , \"from_conn\" : connection . connector_a . name , \"to_ci\" : connection . component_b . id , \"to_conn\" : connection . connector_b . name , } ) data_connections . append ( { \"from_ci\" : connection . component_b . id , \"from_conn\" : connection . connector_b . name , \"to_ci\" : connection . component_a . id , \"to_conn\" : connection . connector_a . name , } ) design_swri_data [ \"connections\" ] = data_connections return design_swri_data validate () \u00b6 Validates the Parameters of the Design Source code in sym_cps/representation/design/concrete/__init__.py 161 162 163 def validate ( self ): \"\"\"Validates the Parameters of the Design\"\"\" raise NotImplementedError","title":"concrete"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete","text":"A class representing a Concrete Design ...","title":"DConcrete"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete--attributes","text":"str name of the design dict[str, DesignParameter] design parameters Source code in sym_cps/representation/design/concrete/__init__.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 @dataclass class DConcrete : \"\"\" A class representing a Concrete Design ... Attributes ---------- name : str name of the design design_parameters : dict[str, DesignParameter] design parameters \"\"\" name : str design_parameters : dict [ str , DesignParameter ] = field ( default_factory = dict ) def __post_init__ ( self ): self . _graph = Graph () @property def graph ( self ) -> Graph : return self . _graph @property def nodes ( self ) -> list [ igraph . Vertex ]: return list ( self . graph . vs ) @property def edges ( self ) -> list [ igraph . Edge ]: return list ( self . graph . es ) def get_vertex_by_id ( self , vid : int ) -> igraph . Vertex : return self . graph . vs [ vid ] @property def n_nodes ( self ) -> int : return len ( self . graph . vs ) @property def n_edges ( self ) -> int : return len ( self . graph . es ) def add_node ( self , component : Component ) -> igraph . Vertex : return self . graph . add_vertex ( instance = component . id , library_component = component . library_component , c_type = component . c_type , component = component , ) def remove_node ( self ): \"\"\"TODO\"\"\" raise NotImplementedError def add_edge ( self , node_id_a : int , node_id_b : int , connection : Connection ): self . graph . add_edge ( source = node_id_a , target = node_id_b , connection = connection ) def connect ( self , connection : Connection ): a = self . get_node_by_instance ( connection . component_a . id ) . index b = self . get_node_by_instance ( connection . component_b . id ) . index self . add_edge ( a , b , connection ) def remove_edge ( self ): \"\"\"TODO. Tip: self.graph.delete_edges\"\"\" raise NotImplementedError def disconnect ( self , connection : Connection ): \"\"\"TODO. Might want to remove a Connection, retrieve the node_id from the Connection\"\"\" raise NotImplementedError @property def components ( self ) -> set [ Component | None ]: if self . n_nodes > 0 : return set ( self . graph . vs ()[ \"component\" ]) return set () @property def connections ( self ) -> set [ Connection | None ]: if self . n_nodes > 0 : if self . n_edges > 0 : return set ( self . graph . es ()[ \"connection\" ]) return set () def get_node_by_instance ( self , instance : str ) -> igraph . Vertex | None : if self . n_nodes > 0 : nodes = self . graph . vs . select ( instance = instance ) if len ( nodes ) == 1 : return nodes [ 0 ] return None def get_instance ( self , instance : str ) -> Component | None : if self . n_nodes > 0 : nodes = self . graph . vs . select ( instance = instance ) if len ( nodes ) == 1 : return nodes [ \"component\" ][ 0 ] return None def select ( self , library_component : LibraryComponent | None = None , component_type : CType | None = None , ) -> set [ Component ]: components = set () if library_component is not None : return set ( self . graph . vs . select ( library_component = library_component )[ \"component\" ] ) if component_type is not None : return set ( self . graph . vs . select ( component_type = component_type )[ \"component\" ]) return components @property def all_library_components_component_class ( self , ) -> dict [ CType , set [ LibraryComponent ]]: \"\"\"Returns all LibraryComponent for each Component class in the design\"\"\" comp_types_n : dict [ CType , set [ LibraryComponent ]] = {} for component in self . components : if component . c_type in comp_types_n . keys (): comp_types_n [ component . c_type ] . add ( component . library_component ) else : comp_types_n [ component . c_type ] = { component . library_component } return comp_types_n @property def all_components_by_library_components ( self , ) -> dict [ LibraryComponent , set [ Component ]]: \"\"\"Returns all Components for each LibraryComponent in the design\"\"\" comp_types_n : dict [ LibraryComponent , set [ Component ]] = {} for component in self . components : if component . library_component in comp_types_n . keys (): comp_types_n [ component . library_component ] . add ( component ) else : comp_types_n [ component . library_component ] = { component } return comp_types_n def validate ( self ): \"\"\"Validates the Parameters of the Design\"\"\" raise NotImplementedError def evaluate ( self ): \"\"\"Sends the Design for evaluation\"\"\" raise NotImplementedError def evaluation ( self , evaluation_results_json : str ): \"\"\"Parse and update the evaluation of the Design\"\"\" raise NotImplementedError def export_to_cad ( self ): \"\"\"Generates a CAD representation of the Design\"\"\" raise NotImplementedError @property def to_design_swri ( self ) -> dict [ str , str ]: \"\"\"Generate design_swri.json format file from a concrete design design: the concrete design exporting to design_swri.json file output_path: file path for the export file. \"\"\" design_swri_data = {} \"\"\" Storing the design name\"\"\" design_swri_data [ \"name\" ] = self . name \"\"\"Storing parameters\"\"\" data_parameters : list = [] for component in self . components : for parameter_id , parameter in component . parameters . items (): data_parameters . append ( { \"parameter_name\" : f \" { component . id } _ { parameter . c_parameter . name } \" , \"value\" : str ( int ( parameter . value )), \"component_properties\" : [ { \"component_name\" : component . id , \"component_property\" : parameter . c_parameter . name , } ], } ) design_swri_data [ \"parameters\" ] = data_parameters \"\"\"Storing components\"\"\" data_components : list [ dict [ str , str ]] = [] for component in self . components : data_components . append ( { \"component_instance\" : component . id , \"component_type\" : component . c_type . id , \"component_choice\" : component . model , } ) design_swri_data [ \"components\" ] = data_components \"\"\"Storing connections\"\"\" data_connections : list [ dict [ str , str ]] = [] for connection in self . connections : data_connections . append ( { \"from_ci\" : connection . component_a . id , \"from_conn\" : connection . connector_a . name , \"to_ci\" : connection . component_b . id , \"to_conn\" : connection . connector_b . name , } ) data_connections . append ( { \"from_ci\" : connection . component_b . id , \"from_conn\" : connection . connector_b . name , \"to_ci\" : connection . component_a . id , \"to_conn\" : connection . connector_a . name , } ) design_swri_data [ \"connections\" ] = data_connections return design_swri_data def export ( self , file_type : ExportType ): absolute_folder = designs_folder / self . name if file_type == ExportType . TXT : save_to_file ( str ( self ), file_name = f \"DTopology\" , absolute_folder_path = absolute_folder , ) elif file_type == ExportType . JSON : save_to_file ( str ( json . dumps ( self . to_design_swri )), file_name = f \"design_swri.json\" , absolute_folder_path = absolute_folder , ) elif file_type == ExportType . DOT : self . graph . write_dot ( f = str ( absolute_folder / \"concrete_graph.dot\" )) elif file_type == ExportType . PDF : if self . n_nodes > 0 : layout = self . graph . layout ( \"kk\" ) \"\"\"Adding labels to nodes\"\"\" self . graph . vs [ \"label\" ] = self . graph . vs [ \"c_type\" ] fig , ax = plt . subplots () plot ( self . graph , layout = layout , target = ax ) plt . savefig ( absolute_folder / \"concrete_graph.pdf\" ) else : raise Exception ( \"File type not supported\" ) print ( f \" { file_type } file saved in { absolute_folder } \" ) def draw ( self , name ): if self . n_nodes > 0 : layout = self . graph . layout ( \"kk\" ) fig , ax = plt . subplots () plot ( self . graph , layout = layout , target = ax ) file_name_path = output_folder / \"graphs\" / name plt . savefig ( f \" { file_name_path } .pdf\" ) def __eq__ ( self , other : object ): pass def __ne__ ( self , other : object ): if not isinstance ( other , DConcrete ): return NotImplementedError return not self . __eq__ ( other ) def __str__ ( self ): n_library_component_by_class = [] for k , v in self . all_library_components_component_class . items (): n_library_component_by_class . append ( f \" \\t { k } : { len ( v ) } \" ) n_library_component_by_class_str = \" \\n \" . join ( n_library_component_by_class ) components_list = [] for ( components_class , library_components , ) in self . all_library_components_component_class . items (): components_list . append ( tab ( f \"COMPONENT type: { components_class } \" )) for library_component in library_components : components_list . append ( tab ( tab ( f \"LIBRARY COMPONENT: { library_component . id } \" )) ) components = self . select ( library_component = library_component ) for component in components : components_list . append ( tab ( tab ( tab ( f \"COMPONENT: { component . id } \" )))) components_list . append ( tab ( tab ( tab ( component )))) components_list . append ( \" \\n\\t +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\" ) components_str = \" \\n \" . join ( components_list ) s1 = ( f \"name: { self . name } \\n \" f \"#_components: { len ( self . components ) } \\n \" f \"#_connections: { len ( self . connections ) } \\n \" f \"#_component_classes: \\n { n_library_component_by_class_str } \\n \" f \"components: \\n { components_str } \\n \" ) return s1","title":"Attributes"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.all_components_by_library_components","text":"Returns all Components for each LibraryComponent in the design Source code in sym_cps/representation/design/concrete/__init__.py 148 149 150 151 152 153 154 155 156 157 158 159 @property def all_components_by_library_components ( self , ) -> dict [ LibraryComponent , set [ Component ]]: \"\"\"Returns all Components for each LibraryComponent in the design\"\"\" comp_types_n : dict [ LibraryComponent , set [ Component ]] = {} for component in self . components : if component . library_component in comp_types_n . keys (): comp_types_n [ component . library_component ] . add ( component ) else : comp_types_n [ component . library_component ] = { component } return comp_types_n","title":"all_components_by_library_components()"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.all_library_components_component_class","text":"Returns all LibraryComponent for each Component class in the design Source code in sym_cps/representation/design/concrete/__init__.py 135 136 137 138 139 140 141 142 143 144 145 146 @property def all_library_components_component_class ( self , ) -> dict [ CType , set [ LibraryComponent ]]: \"\"\"Returns all LibraryComponent for each Component class in the design\"\"\" comp_types_n : dict [ CType , set [ LibraryComponent ]] = {} for component in self . components : if component . c_type in comp_types_n . keys (): comp_types_n [ component . c_type ] . add ( component . library_component ) else : comp_types_n [ component . c_type ] = { component . library_component } return comp_types_n","title":"all_library_components_component_class()"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.disconnect","text":"TODO. Might want to remove a Connection, retrieve the node_id from the Connection Source code in sym_cps/representation/design/concrete/__init__.py 90 91 92 def disconnect ( self , connection : Connection ): \"\"\"TODO. Might want to remove a Connection, retrieve the node_id from the Connection\"\"\" raise NotImplementedError","title":"disconnect()"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.evaluate","text":"Sends the Design for evaluation Source code in sym_cps/representation/design/concrete/__init__.py 165 166 167 def evaluate ( self ): \"\"\"Sends the Design for evaluation\"\"\" raise NotImplementedError","title":"evaluate()"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.evaluation","text":"Parse and update the evaluation of the Design Source code in sym_cps/representation/design/concrete/__init__.py 169 170 171 def evaluation ( self , evaluation_results_json : str ): \"\"\"Parse and update the evaluation of the Design\"\"\" raise NotImplementedError","title":"evaluation()"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.export_to_cad","text":"Generates a CAD representation of the Design Source code in sym_cps/representation/design/concrete/__init__.py 173 174 175 def export_to_cad ( self ): \"\"\"Generates a CAD representation of the Design\"\"\" raise NotImplementedError","title":"export_to_cad()"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.remove_edge","text":"TODO. Tip: self.graph.delete_edges Source code in sym_cps/representation/design/concrete/__init__.py 86 87 88 def remove_edge ( self ): \"\"\"TODO. Tip: self.graph.delete_edges\"\"\" raise NotImplementedError","title":"remove_edge()"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.remove_node","text":"TODO Source code in sym_cps/representation/design/concrete/__init__.py 74 75 76 def remove_node ( self ): \"\"\"TODO\"\"\" raise NotImplementedError","title":"remove_node()"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.to_design_swri","text":"Generate design_swri.json format file from a concrete design design: the concrete design exporting to design_swri.json file output_path: file path for the export file. Source code in sym_cps/representation/design/concrete/__init__.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 @property def to_design_swri ( self ) -> dict [ str , str ]: \"\"\"Generate design_swri.json format file from a concrete design design: the concrete design exporting to design_swri.json file output_path: file path for the export file. \"\"\" design_swri_data = {} \"\"\" Storing the design name\"\"\" design_swri_data [ \"name\" ] = self . name \"\"\"Storing parameters\"\"\" data_parameters : list = [] for component in self . components : for parameter_id , parameter in component . parameters . items (): data_parameters . append ( { \"parameter_name\" : f \" { component . id } _ { parameter . c_parameter . name } \" , \"value\" : str ( int ( parameter . value )), \"component_properties\" : [ { \"component_name\" : component . id , \"component_property\" : parameter . c_parameter . name , } ], } ) design_swri_data [ \"parameters\" ] = data_parameters \"\"\"Storing components\"\"\" data_components : list [ dict [ str , str ]] = [] for component in self . components : data_components . append ( { \"component_instance\" : component . id , \"component_type\" : component . c_type . id , \"component_choice\" : component . model , } ) design_swri_data [ \"components\" ] = data_components \"\"\"Storing connections\"\"\" data_connections : list [ dict [ str , str ]] = [] for connection in self . connections : data_connections . append ( { \"from_ci\" : connection . component_a . id , \"from_conn\" : connection . connector_a . name , \"to_ci\" : connection . component_b . id , \"to_conn\" : connection . connector_b . name , } ) data_connections . append ( { \"from_ci\" : connection . component_b . id , \"from_conn\" : connection . connector_b . name , \"to_ci\" : connection . component_a . id , \"to_conn\" : connection . connector_a . name , } ) design_swri_data [ \"connections\" ] = data_connections return design_swri_data","title":"to_design_swri()"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.validate","text":"Validates the Parameters of the Design Source code in sym_cps/representation/design/concrete/__init__.py 161 162 163 def validate ( self ): \"\"\"Validates the Parameters of the Design\"\"\" raise NotImplementedError","title":"validate()"},{"location":"reference/sym_cps/representation/design/concrete/elements/","text":"","title":"elements"},{"location":"reference/sym_cps/representation/design/concrete/elements/component/","text":"Component dataclass \u00b6 Source code in sym_cps/representation/design/concrete/elements/component.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 @dataclass ( frozen = True ) class Component : id : str library_component : LibraryComponent parameters : dict [ str , Parameter ] = field ( default_factory = dict ) def __post_init__ ( self ): \"\"\"Fill up all the parameters with the assigned_value, or default_value\"\"\" for parameter_accepted in self . configurable_parameters : if parameter_accepted . id not in self . parameters . keys (): if \"assigned_val\" in parameter_accepted . values . keys (): new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"assigned_val\" ]), c_parameter = parameter_accepted , component = self , ) elif \"default_val\" in parameter_accepted . values . keys (): new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"default_val\" ]), c_parameter = parameter_accepted , component = self , ) else : # raise Exception( # f\"Parameter {parameter_accepted.id} does not have assigned_val nor default_val\" # ) new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"min_val\" ]), c_parameter = parameter_accepted , component = self , ) self . parameters [ parameter_accepted . id ] = new_parameter for parameter in self . parameters . values (): parameter . component = self @property def model ( self ) -> str : return self . library_component . id @property def c_type ( self ) -> CType : return self . library_component . comp_type @property def properties ( self ) -> dict [ str , CProperty ]: return self . library_component . properties @property def configurable_parameters ( self ) -> set [ CParameter ]: \"\"\"Returns the set of all ParameterType that can be configured in the Component\"\"\" return set ( self . library_component . parameters . values ()) @property def params_props_values ( self ) -> dict [ str , float | str ]: \"\"\"Returns dictionary: with the values of each parameter and property of the component\"\"\" params_props_values : dict [ str , float | str ] = {} for param_id , parameter in self . parameters . items (): params_props_values [ param_id ] = parameter . value for property_id , property in self . properties . items (): params_props_values [ property_id ] = property . value return params_props_values def _edit_field ( self , name , value ): object . __setattr__ ( self , name , value ) def _update_field ( self , name , value ): attr = object . __getattribute__ ( self , name ) attr . update ( value ) object . __setattr__ ( self , name , attr ) def __eq__ ( self , other : object ): if not isinstance ( other , Component ): return NotImplemented if self . library_component != other . library_component : return False if self . params_props_values != self . params_props_values : return False return True def __ne__ ( self , other : object ): if not isinstance ( other , Component ): return NotImplemented return not self . __eq__ ( other ) def __hash__ ( self ): return abs ( hash ( self . id )) def __str__ ( self ): s1 = f \"name: { self . model } \\n \" f \"type: { self . c_type } \\n \" parameters_str = [] for k , v in self . parameters . items (): parameters_str . append ( f \" \\t { k } : { v } \" ) parameters = \" \\n \" . join ( parameters_str ) if len ( parameters_str ) != 0 : s2 = f \"parameters: \\n { parameters } \\n \" else : s2 = \"\" return s1 + s2 __post_init__ () \u00b6 Fill up all the parameters with the assigned_value, or default_value Source code in sym_cps/representation/design/concrete/elements/component.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def __post_init__ ( self ): \"\"\"Fill up all the parameters with the assigned_value, or default_value\"\"\" for parameter_accepted in self . configurable_parameters : if parameter_accepted . id not in self . parameters . keys (): if \"assigned_val\" in parameter_accepted . values . keys (): new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"assigned_val\" ]), c_parameter = parameter_accepted , component = self , ) elif \"default_val\" in parameter_accepted . values . keys (): new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"default_val\" ]), c_parameter = parameter_accepted , component = self , ) else : # raise Exception( # f\"Parameter {parameter_accepted.id} does not have assigned_val nor default_val\" # ) new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"min_val\" ]), c_parameter = parameter_accepted , component = self , ) self . parameters [ parameter_accepted . id ] = new_parameter for parameter in self . parameters . values (): parameter . component = self configurable_parameters () property \u00b6 Returns the set of all ParameterType that can be configured in the Component Source code in sym_cps/representation/design/concrete/elements/component.py 61 62 63 64 @property def configurable_parameters ( self ) -> set [ CParameter ]: \"\"\"Returns the set of all ParameterType that can be configured in the Component\"\"\" return set ( self . library_component . parameters . values ()) params_props_values () property \u00b6 Returns dictionary: with the values of each parameter and property of the component Source code in sym_cps/representation/design/concrete/elements/component.py 66 67 68 69 70 71 72 73 74 75 76 @property def params_props_values ( self ) -> dict [ str , float | str ]: \"\"\"Returns dictionary: with the values of each parameter and property of the component\"\"\" params_props_values : dict [ str , float | str ] = {} for param_id , parameter in self . parameters . items (): params_props_values [ param_id ] = parameter . value for property_id , property in self . properties . items (): params_props_values [ property_id ] = property . value return params_props_values","title":"component"},{"location":"reference/sym_cps/representation/design/concrete/elements/component/#sym_cps.representation.design.concrete.elements.component.Component","text":"Source code in sym_cps/representation/design/concrete/elements/component.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 @dataclass ( frozen = True ) class Component : id : str library_component : LibraryComponent parameters : dict [ str , Parameter ] = field ( default_factory = dict ) def __post_init__ ( self ): \"\"\"Fill up all the parameters with the assigned_value, or default_value\"\"\" for parameter_accepted in self . configurable_parameters : if parameter_accepted . id not in self . parameters . keys (): if \"assigned_val\" in parameter_accepted . values . keys (): new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"assigned_val\" ]), c_parameter = parameter_accepted , component = self , ) elif \"default_val\" in parameter_accepted . values . keys (): new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"default_val\" ]), c_parameter = parameter_accepted , component = self , ) else : # raise Exception( # f\"Parameter {parameter_accepted.id} does not have assigned_val nor default_val\" # ) new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"min_val\" ]), c_parameter = parameter_accepted , component = self , ) self . parameters [ parameter_accepted . id ] = new_parameter for parameter in self . parameters . values (): parameter . component = self @property def model ( self ) -> str : return self . library_component . id @property def c_type ( self ) -> CType : return self . library_component . comp_type @property def properties ( self ) -> dict [ str , CProperty ]: return self . library_component . properties @property def configurable_parameters ( self ) -> set [ CParameter ]: \"\"\"Returns the set of all ParameterType that can be configured in the Component\"\"\" return set ( self . library_component . parameters . values ()) @property def params_props_values ( self ) -> dict [ str , float | str ]: \"\"\"Returns dictionary: with the values of each parameter and property of the component\"\"\" params_props_values : dict [ str , float | str ] = {} for param_id , parameter in self . parameters . items (): params_props_values [ param_id ] = parameter . value for property_id , property in self . properties . items (): params_props_values [ property_id ] = property . value return params_props_values def _edit_field ( self , name , value ): object . __setattr__ ( self , name , value ) def _update_field ( self , name , value ): attr = object . __getattribute__ ( self , name ) attr . update ( value ) object . __setattr__ ( self , name , attr ) def __eq__ ( self , other : object ): if not isinstance ( other , Component ): return NotImplemented if self . library_component != other . library_component : return False if self . params_props_values != self . params_props_values : return False return True def __ne__ ( self , other : object ): if not isinstance ( other , Component ): return NotImplemented return not self . __eq__ ( other ) def __hash__ ( self ): return abs ( hash ( self . id )) def __str__ ( self ): s1 = f \"name: { self . model } \\n \" f \"type: { self . c_type } \\n \" parameters_str = [] for k , v in self . parameters . items (): parameters_str . append ( f \" \\t { k } : { v } \" ) parameters = \" \\n \" . join ( parameters_str ) if len ( parameters_str ) != 0 : s2 = f \"parameters: \\n { parameters } \\n \" else : s2 = \"\" return s1 + s2","title":"Component"},{"location":"reference/sym_cps/representation/design/concrete/elements/component/#sym_cps.representation.design.concrete.elements.component.Component.__post_init__","text":"Fill up all the parameters with the assigned_value, or default_value Source code in sym_cps/representation/design/concrete/elements/component.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def __post_init__ ( self ): \"\"\"Fill up all the parameters with the assigned_value, or default_value\"\"\" for parameter_accepted in self . configurable_parameters : if parameter_accepted . id not in self . parameters . keys (): if \"assigned_val\" in parameter_accepted . values . keys (): new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"assigned_val\" ]), c_parameter = parameter_accepted , component = self , ) elif \"default_val\" in parameter_accepted . values . keys (): new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"default_val\" ]), c_parameter = parameter_accepted , component = self , ) else : # raise Exception( # f\"Parameter {parameter_accepted.id} does not have assigned_val nor default_val\" # ) new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"min_val\" ]), c_parameter = parameter_accepted , component = self , ) self . parameters [ parameter_accepted . id ] = new_parameter for parameter in self . parameters . values (): parameter . component = self","title":"__post_init__()"},{"location":"reference/sym_cps/representation/design/concrete/elements/component/#sym_cps.representation.design.concrete.elements.component.Component.configurable_parameters","text":"Returns the set of all ParameterType that can be configured in the Component Source code in sym_cps/representation/design/concrete/elements/component.py 61 62 63 64 @property def configurable_parameters ( self ) -> set [ CParameter ]: \"\"\"Returns the set of all ParameterType that can be configured in the Component\"\"\" return set ( self . library_component . parameters . values ())","title":"configurable_parameters()"},{"location":"reference/sym_cps/representation/design/concrete/elements/component/#sym_cps.representation.design.concrete.elements.component.Component.params_props_values","text":"Returns dictionary: with the values of each parameter and property of the component Source code in sym_cps/representation/design/concrete/elements/component.py 66 67 68 69 70 71 72 73 74 75 76 @property def params_props_values ( self ) -> dict [ str , float | str ]: \"\"\"Returns dictionary: with the values of each parameter and property of the component\"\"\" params_props_values : dict [ str , float | str ] = {} for param_id , parameter in self . parameters . items (): params_props_values [ param_id ] = parameter . value for property_id , property in self . properties . items (): params_props_values [ property_id ] = property . value return params_props_values","title":"params_props_values()"},{"location":"reference/sym_cps/representation/design/concrete/elements/connection/","text":"Connection dataclass \u00b6 Models the connection between two 'Component'. Each Connection is symmetric, i.e. Connection(A,B) = Connection(B,A) Source code in sym_cps/representation/design/concrete/elements/connection.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 @dataclass ( frozen = True ) class Connection : \"\"\"Models the connection between two 'Component'. Each Connection is symmetric, i.e. Connection(A,B) = Connection(B,A)\"\"\" component_a : Component connector_a : CConnector component_b : Component connector_b : CConnector def __post_init__ ( self ): \"\"\"TODO: is connection legal?\"\"\" @property def components_and_connectors ( self ) -> set [ tuple [ Component , CConnector ]]: \"\"\"Returns a set of two tuples, where each tuple is formed by a Component and a CConnector\"\"\" connections = set () connections . add (( self . component_a , self . connector_a )) connections . add (( self . component_b , self . connector_b )) return connections @property def components ( self ) -> tuple [ Component , Component ]: \"\"\"Returns the two components connected\"\"\" return self . component_a , self . component_b @property def key ( self ) -> str : a1 = self . component_a . id a2 = self . connector_a . id b1 = self . component_b . id b2 = self . connector_b . id if ( a1 + a2 ) >= ( b1 + b2 ): return f \" { a1 } - { a2 } - { b1 } - { b2 } \" return f \" { b1 } - { b2 } - { a1 } - { a2 } \" def __eq__ ( self , other : object ): if not isinstance ( other , Connection ): return NotImplementedError return self . key == other . key def __ne__ ( self , other : object ): if not isinstance ( other , Connection ): return NotImplementedError return not self . __eq__ ( other ) def __hash__ ( self ): return abs ( hash ( self . key )) __post_init__ () \u00b6 Todo is connection legal? Source code in sym_cps/representation/design/concrete/elements/connection.py 21 22 def __post_init__ ( self ): \"\"\"TODO: is connection legal?\"\"\" components () property \u00b6 Returns the two components connected Source code in sym_cps/representation/design/concrete/elements/connection.py 33 34 35 36 37 @property def components ( self ) -> tuple [ Component , Component ]: \"\"\"Returns the two components connected\"\"\" return self . component_a , self . component_b components_and_connectors () property \u00b6 Returns a set of two tuples, where each tuple is formed by a Component and a CConnector Source code in sym_cps/representation/design/concrete/elements/connection.py 24 25 26 27 28 29 30 31 @property def components_and_connectors ( self ) -> set [ tuple [ Component , CConnector ]]: \"\"\"Returns a set of two tuples, where each tuple is formed by a Component and a CConnector\"\"\" connections = set () connections . add (( self . component_a , self . connector_a )) connections . add (( self . component_b , self . connector_b )) return connections","title":"connection"},{"location":"reference/sym_cps/representation/design/concrete/elements/connection/#sym_cps.representation.design.concrete.elements.connection.Connection","text":"Models the connection between two 'Component'. Each Connection is symmetric, i.e. Connection(A,B) = Connection(B,A) Source code in sym_cps/representation/design/concrete/elements/connection.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 @dataclass ( frozen = True ) class Connection : \"\"\"Models the connection between two 'Component'. Each Connection is symmetric, i.e. Connection(A,B) = Connection(B,A)\"\"\" component_a : Component connector_a : CConnector component_b : Component connector_b : CConnector def __post_init__ ( self ): \"\"\"TODO: is connection legal?\"\"\" @property def components_and_connectors ( self ) -> set [ tuple [ Component , CConnector ]]: \"\"\"Returns a set of two tuples, where each tuple is formed by a Component and a CConnector\"\"\" connections = set () connections . add (( self . component_a , self . connector_a )) connections . add (( self . component_b , self . connector_b )) return connections @property def components ( self ) -> tuple [ Component , Component ]: \"\"\"Returns the two components connected\"\"\" return self . component_a , self . component_b @property def key ( self ) -> str : a1 = self . component_a . id a2 = self . connector_a . id b1 = self . component_b . id b2 = self . connector_b . id if ( a1 + a2 ) >= ( b1 + b2 ): return f \" { a1 } - { a2 } - { b1 } - { b2 } \" return f \" { b1 } - { b2 } - { a1 } - { a2 } \" def __eq__ ( self , other : object ): if not isinstance ( other , Connection ): return NotImplementedError return self . key == other . key def __ne__ ( self , other : object ): if not isinstance ( other , Connection ): return NotImplementedError return not self . __eq__ ( other ) def __hash__ ( self ): return abs ( hash ( self . key ))","title":"Connection"},{"location":"reference/sym_cps/representation/design/concrete/elements/connection/#sym_cps.representation.design.concrete.elements.connection.Connection.__post_init__","text":"Todo is connection legal? Source code in sym_cps/representation/design/concrete/elements/connection.py 21 22 def __post_init__ ( self ): \"\"\"TODO: is connection legal?\"\"\"","title":"__post_init__()"},{"location":"reference/sym_cps/representation/design/concrete/elements/connection/#sym_cps.representation.design.concrete.elements.connection.Connection.components","text":"Returns the two components connected Source code in sym_cps/representation/design/concrete/elements/connection.py 33 34 35 36 37 @property def components ( self ) -> tuple [ Component , Component ]: \"\"\"Returns the two components connected\"\"\" return self . component_a , self . component_b","title":"components()"},{"location":"reference/sym_cps/representation/design/concrete/elements/connection/#sym_cps.representation.design.concrete.elements.connection.Connection.components_and_connectors","text":"Returns a set of two tuples, where each tuple is formed by a Component and a CConnector Source code in sym_cps/representation/design/concrete/elements/connection.py 24 25 26 27 28 29 30 31 @property def components_and_connectors ( self ) -> set [ tuple [ Component , CConnector ]]: \"\"\"Returns a set of two tuples, where each tuple is formed by a Component and a CConnector\"\"\" connections = set () connections . add (( self . component_a , self . connector_a )) connections . add (( self . component_b , self . connector_b )) return connections","title":"components_and_connectors()"},{"location":"reference/sym_cps/representation/design/concrete/elements/design_parameters/","text":"","title":"design_parameters"},{"location":"reference/sym_cps/representation/design/concrete/elements/parameter/","text":"","title":"parameter"},{"location":"reference/sym_cps/representation/design/topology/","text":"DTopology dataclass \u00b6 Source code in sym_cps/representation/design/topology/__init__.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 @dataclass class DTopology : name : str def __post_init__ ( self ): self . _graph = Graph () @property def graph ( self ) -> Graph : return self . _graph @classmethod def from_concrete ( cls , d_concrete : DConcrete ) -> DTopology : # Create all the vertexes with the same id in d_concrete: d_topology = cls ( name = d_concrete . name ) for i in range ( d_concrete . n_nodes ): vertex = d_concrete . get_vertex_by_id ( i ) component : Component = vertex [ \"component\" ] d_topology . add_node ( c_type = component . library_component . comp_type ) # print(f\"{vertex.index} - {new_vertex.index}\") for edge in d_concrete . edges : d_topology . add_edge ( edge . source , edge . target ) return d_topology @property def nodes ( self ) -> list [ igraph . Vertex ]: return list ( self . graph . vs ) def get_vertex_by_id ( self , vid : int ) -> igraph . Vertex : return self . graph . vs [ vid ] @property def edges ( self ) -> list [ igraph . Edge ]: return list ( self . graph . es ) @property def n_nodes ( self ) -> int : return len ( self . graph . vs ) def add_node ( self , c_type : CType ) -> igraph . Vertex : return self . graph . add_vertex ( c_type = c_type , label = c_type . id ) def remove_node ( self ): \"\"\"TODO\"\"\" raise NotImplementedError def add_edge ( self , node_id_a : int , node_id_b : int ): self . graph . add_edge ( source = node_id_a , target = node_id_b ) def remove_edge ( self ): \"\"\"TODO. Tip: self.graph.delete_edges\"\"\" raise NotImplementedError @property def components ( self ) -> set [ CType ]: if self . n_nodes > 0 : return set ( self . graph . vs ()[ \"c_type\" ]) return set () @property def edges ( self ) -> list [ igraph . Edge ]: return list ( self . graph . es ) def draw_random_node ( self ) -> igraph . Vertex | None : if self . n_nodes == 0 : return None return choice ( self . nodes ) def export ( self , file_type : ExportType ): absolute_folder = designs_folder / self . name if file_type == ExportType . TXT : save_to_file ( str ( self ), file_name = f \"DTopology\" , absolute_folder_path = absolute_folder , ) elif file_type == ExportType . JSON : raise Exception ( \"Can't create JSON from DTopology. It must be from DConcrete.\" ) elif file_type == ExportType . DOT : self . graph . write_dot ( f = str ( absolute_folder / \"topo_graph.dot\" )) else : raise Exception ( \"File type not supported\" ) print ( f \" { file_type } file saved in { absolute_folder } \" ) def __str__ ( self ): ret = str ( self . graph ) ret += \" \\n \" for node in self . nodes : ret += f \" { node . index } : { node [ 'c_type' ] } \\n \" return ret remove_edge () \u00b6 TODO. Tip: self.graph.delete_edges Source code in sym_cps/representation/design/topology/__init__.py 68 69 70 def remove_edge ( self ): \"\"\"TODO. Tip: self.graph.delete_edges\"\"\" raise NotImplementedError remove_node () \u00b6 TODO Source code in sym_cps/representation/design/topology/__init__.py 61 62 63 def remove_node ( self ): \"\"\"TODO\"\"\" raise NotImplementedError","title":"topology"},{"location":"reference/sym_cps/representation/design/topology/#sym_cps.representation.design.topology.DTopology","text":"Source code in sym_cps/representation/design/topology/__init__.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 @dataclass class DTopology : name : str def __post_init__ ( self ): self . _graph = Graph () @property def graph ( self ) -> Graph : return self . _graph @classmethod def from_concrete ( cls , d_concrete : DConcrete ) -> DTopology : # Create all the vertexes with the same id in d_concrete: d_topology = cls ( name = d_concrete . name ) for i in range ( d_concrete . n_nodes ): vertex = d_concrete . get_vertex_by_id ( i ) component : Component = vertex [ \"component\" ] d_topology . add_node ( c_type = component . library_component . comp_type ) # print(f\"{vertex.index} - {new_vertex.index}\") for edge in d_concrete . edges : d_topology . add_edge ( edge . source , edge . target ) return d_topology @property def nodes ( self ) -> list [ igraph . Vertex ]: return list ( self . graph . vs ) def get_vertex_by_id ( self , vid : int ) -> igraph . Vertex : return self . graph . vs [ vid ] @property def edges ( self ) -> list [ igraph . Edge ]: return list ( self . graph . es ) @property def n_nodes ( self ) -> int : return len ( self . graph . vs ) def add_node ( self , c_type : CType ) -> igraph . Vertex : return self . graph . add_vertex ( c_type = c_type , label = c_type . id ) def remove_node ( self ): \"\"\"TODO\"\"\" raise NotImplementedError def add_edge ( self , node_id_a : int , node_id_b : int ): self . graph . add_edge ( source = node_id_a , target = node_id_b ) def remove_edge ( self ): \"\"\"TODO. Tip: self.graph.delete_edges\"\"\" raise NotImplementedError @property def components ( self ) -> set [ CType ]: if self . n_nodes > 0 : return set ( self . graph . vs ()[ \"c_type\" ]) return set () @property def edges ( self ) -> list [ igraph . Edge ]: return list ( self . graph . es ) def draw_random_node ( self ) -> igraph . Vertex | None : if self . n_nodes == 0 : return None return choice ( self . nodes ) def export ( self , file_type : ExportType ): absolute_folder = designs_folder / self . name if file_type == ExportType . TXT : save_to_file ( str ( self ), file_name = f \"DTopology\" , absolute_folder_path = absolute_folder , ) elif file_type == ExportType . JSON : raise Exception ( \"Can't create JSON from DTopology. It must be from DConcrete.\" ) elif file_type == ExportType . DOT : self . graph . write_dot ( f = str ( absolute_folder / \"topo_graph.dot\" )) else : raise Exception ( \"File type not supported\" ) print ( f \" { file_type } file saved in { absolute_folder } \" ) def __str__ ( self ): ret = str ( self . graph ) ret += \" \\n \" for node in self . nodes : ret += f \" { node . index } : { node [ 'c_type' ] } \\n \" return ret","title":"DTopology"},{"location":"reference/sym_cps/representation/design/topology/#sym_cps.representation.design.topology.DTopology.remove_edge","text":"TODO. Tip: self.graph.delete_edges Source code in sym_cps/representation/design/topology/__init__.py 68 69 70 def remove_edge ( self ): \"\"\"TODO. Tip: self.graph.delete_edges\"\"\" raise NotImplementedError","title":"remove_edge()"},{"location":"reference/sym_cps/representation/design/topology/#sym_cps.representation.design.topology.DTopology.remove_node","text":"TODO Source code in sym_cps/representation/design/topology/__init__.py 61 62 63 def remove_node ( self ): \"\"\"TODO\"\"\" raise NotImplementedError","title":"remove_node()"},{"location":"reference/sym_cps/representation/library/","text":"","title":"library"},{"location":"reference/sym_cps/representation/library/elements/","text":"","title":"elements"},{"location":"reference/sym_cps/representation/library/elements/c_connector/","text":"","title":"c_connector"},{"location":"reference/sym_cps/representation/library/elements/c_parameter/","text":"CParameter dataclass \u00b6 Indicates the possible values and type of a component parameter. Parameters are associated to component classes. Source code in sym_cps/representation/library/elements/c_parameter.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 @dataclass ( frozen = True ) class CParameter : \"\"\"Indicates the possible values and type of a component parameter. Parameters are associated to component classes. \"\"\" name : str belongs_to : CType = field ( init = False ) _values : dict = field ( init = False , default_factory = dict ) def _edit_field ( self , name , value ): object . __setattr__ ( self , name , value ) def _update_field ( self , name , value ): attr = object . __getattribute__ ( self , name ) attr . update ( value ) object . __setattr__ ( self , name , attr ) def __post_init__ ( self ): vals : dict [ str , float | None ] = { \"min_val\" : None , \"max_val\" : None , \"default_val\" : None , \"assigned_val\" : None , } self . _edit_field ( \"_values\" , vals ) @property def values ( self ) -> dict [ str , float ]: \"\"\"Filters out None component\"\"\" return { key : value for key , value in self . _values . items () if value is not None } def _edit_values ( self , values : dict ): for key in values . keys (): if key in self . _values . keys (): if values [ key ] != \"\" : self . _values [ key ] = float ( values [ key ]) @property def id ( self ) -> str : \"\"\"Internal ID\"\"\" return parameter_id ( self . name , str ( self . belongs_to )) def __str__ ( self ): values = \", \" . join ([ f \" { k } : { v } \" for k , v in self . values . items ()]) return f \" { self . name } \\t { values } \" def __hash__ ( self ): return abs ( hash ( self . id )) id () property \u00b6 Internal ID Source code in sym_cps/representation/library/elements/c_parameter.py 52 53 54 55 @property def id ( self ) -> str : \"\"\"Internal ID\"\"\" return parameter_id ( self . name , str ( self . belongs_to )) values () property \u00b6 Filters out None component Source code in sym_cps/representation/library/elements/c_parameter.py 41 42 43 44 @property def values ( self ) -> dict [ str , float ]: \"\"\"Filters out None component\"\"\" return { key : value for key , value in self . _values . items () if value is not None }","title":"c_parameter"},{"location":"reference/sym_cps/representation/library/elements/c_parameter/#sym_cps.representation.library.elements.c_parameter.CParameter","text":"Indicates the possible values and type of a component parameter. Parameters are associated to component classes. Source code in sym_cps/representation/library/elements/c_parameter.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 @dataclass ( frozen = True ) class CParameter : \"\"\"Indicates the possible values and type of a component parameter. Parameters are associated to component classes. \"\"\" name : str belongs_to : CType = field ( init = False ) _values : dict = field ( init = False , default_factory = dict ) def _edit_field ( self , name , value ): object . __setattr__ ( self , name , value ) def _update_field ( self , name , value ): attr = object . __getattribute__ ( self , name ) attr . update ( value ) object . __setattr__ ( self , name , attr ) def __post_init__ ( self ): vals : dict [ str , float | None ] = { \"min_val\" : None , \"max_val\" : None , \"default_val\" : None , \"assigned_val\" : None , } self . _edit_field ( \"_values\" , vals ) @property def values ( self ) -> dict [ str , float ]: \"\"\"Filters out None component\"\"\" return { key : value for key , value in self . _values . items () if value is not None } def _edit_values ( self , values : dict ): for key in values . keys (): if key in self . _values . keys (): if values [ key ] != \"\" : self . _values [ key ] = float ( values [ key ]) @property def id ( self ) -> str : \"\"\"Internal ID\"\"\" return parameter_id ( self . name , str ( self . belongs_to )) def __str__ ( self ): values = \", \" . join ([ f \" { k } : { v } \" for k , v in self . values . items ()]) return f \" { self . name } \\t { values } \" def __hash__ ( self ): return abs ( hash ( self . id ))","title":"CParameter"},{"location":"reference/sym_cps/representation/library/elements/c_parameter/#sym_cps.representation.library.elements.c_parameter.CParameter.id","text":"Internal ID Source code in sym_cps/representation/library/elements/c_parameter.py 52 53 54 55 @property def id ( self ) -> str : \"\"\"Internal ID\"\"\" return parameter_id ( self . name , str ( self . belongs_to ))","title":"id()"},{"location":"reference/sym_cps/representation/library/elements/c_parameter/#sym_cps.representation.library.elements.c_parameter.CParameter.values","text":"Filters out None component Source code in sym_cps/representation/library/elements/c_parameter.py 41 42 43 44 @property def values ( self ) -> dict [ str , float ]: \"\"\"Filters out None component\"\"\" return { key : value for key , value in self . _values . items () if value is not None }","title":"values()"},{"location":"reference/sym_cps/representation/library/elements/c_property/","text":"","title":"c_property"},{"location":"reference/sym_cps/representation/library/elements/c_type/","text":"CType dataclass \u00b6 Source code in sym_cps/representation/library/elements/c_type.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 @dataclass ( frozen = True ) class CType : id : str \"\"\"Configurable parameters\"\"\" parameters : dict [ str , CParameter ] = field ( init = False , default_factory = dict ) \"\"\"Accepted connectors\"\"\" connectors : dict [ str , CConnector ] = field ( init = False , default_factory = dict ) \"\"\"Compatible CType to be connected to\"\"\" compatible_with : dict [ str , CType ] = field ( init = False , default_factory = dict ) \"\"\"Library components of CType\"\"\" belongs_to : dict [ str , LibraryComponent ] = field ( init = False , default_factory = dict ) def _edit_field ( self , name , value ): object . __setattr__ ( self , name , value ) def _update_field ( self , name , value ): attr = object . __getattribute__ ( self , name ) if len ( attr ) == 0 : object . __setattr__ ( self , name , value ) return attr . update ( value ) object . __setattr__ ( self , name , attr ) def _remove_from_field ( self , name , value ): if value not in self . belongs_to . keys (): return attr = object . __getattribute__ ( self , name ) if len ( attr ) == 0 : return del attr [ value ] object . __setattr__ ( self , name , attr ) def __str__ ( self ) -> str : return self . id def __hash__ ( self ) -> int : return hash ( self . id ) compatible_with : dict [ str , CType ] = field ( init = False , default_factory = dict ) class-attribute \u00b6 Library components of CType connectors : dict [ str , CConnector ] = field ( init = False , default_factory = dict ) class-attribute \u00b6 Compatible CType to be connected to id : str class-attribute \u00b6 Configurable parameters parameters : dict [ str , CParameter ] = field ( init = False , default_factory = dict ) class-attribute \u00b6 Accepted connectors","title":"c_type"},{"location":"reference/sym_cps/representation/library/elements/c_type/#sym_cps.representation.library.elements.c_type.CType","text":"Source code in sym_cps/representation/library/elements/c_type.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 @dataclass ( frozen = True ) class CType : id : str \"\"\"Configurable parameters\"\"\" parameters : dict [ str , CParameter ] = field ( init = False , default_factory = dict ) \"\"\"Accepted connectors\"\"\" connectors : dict [ str , CConnector ] = field ( init = False , default_factory = dict ) \"\"\"Compatible CType to be connected to\"\"\" compatible_with : dict [ str , CType ] = field ( init = False , default_factory = dict ) \"\"\"Library components of CType\"\"\" belongs_to : dict [ str , LibraryComponent ] = field ( init = False , default_factory = dict ) def _edit_field ( self , name , value ): object . __setattr__ ( self , name , value ) def _update_field ( self , name , value ): attr = object . __getattribute__ ( self , name ) if len ( attr ) == 0 : object . __setattr__ ( self , name , value ) return attr . update ( value ) object . __setattr__ ( self , name , attr ) def _remove_from_field ( self , name , value ): if value not in self . belongs_to . keys (): return attr = object . __getattribute__ ( self , name ) if len ( attr ) == 0 : return del attr [ value ] object . __setattr__ ( self , name , attr ) def __str__ ( self ) -> str : return self . id def __hash__ ( self ) -> int : return hash ( self . id )","title":"CType"},{"location":"reference/sym_cps/representation/library/elements/c_type/#sym_cps.representation.library.elements.c_type.CType.compatible_with","text":"Library components of CType","title":"compatible_with"},{"location":"reference/sym_cps/representation/library/elements/c_type/#sym_cps.representation.library.elements.c_type.CType.connectors","text":"Compatible CType to be connected to","title":"connectors"},{"location":"reference/sym_cps/representation/library/elements/c_type/#sym_cps.representation.library.elements.c_type.CType.id","text":"Configurable parameters","title":"id"},{"location":"reference/sym_cps/representation/library/elements/c_type/#sym_cps.representation.library.elements.c_type.CType.parameters","text":"Accepted connectors","title":"parameters"},{"location":"reference/sym_cps/representation/library/elements/library_component/","text":"LibraryComponent dataclass \u00b6 Represent and model of component in the components_library. It has fixed properties and can have parameters and connectors. Source code in sym_cps/representation/library/elements/library_component.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 @dataclass ( frozen = True ) class LibraryComponent : \"\"\"Represent and model of component in the components_library. It has fixed properties and can have parameters and connectors.\"\"\" \"\"\"Component Model Name\"\"\" id : str comp_type : CType properties : dict [ str , CProperty ] = field ( init = False , default_factory = dict ) @property def parameters ( self ) -> dict [ str , CParameter ]: return self . comp_type . parameters @property def connectors ( self ) -> dict [ str , CConnector ]: return self . comp_type . connectors def _edit_field ( self , name , value ): object . __setattr__ ( self , name , value ) def _update_field ( self , name , value ): attr = object . __getattribute__ ( self , name ) attr . update ( value ) object . __setattr__ ( self , name , attr ) def __hash__ ( self ): return hash ( str ( self . id )) def __str__ ( self ) -> str : s1 = f \"name: { self . id } \\n \" f \"type: { str ( self . comp_type ) } \\n \" properties_str = [] for e in list ( self . properties . values ()): properties_str . append ( tab ( e )) properties = \" \\n \" . join ( properties_str ) parameters_str = [] for e in list ( self . parameters . values ()): parameters_str . append ( tab ( e )) parameters = \" \\n \" . join ( parameters_str ) connectors_str = [] for e in list ( self . connectors . values ()): connectors_str . append ( tab ( e )) connectors = \" \\n \" . join ( connectors_str ) s2 = f \"properties: \\n { properties } \\n \" s3 = f \"connectors: \\n { connectors } \\n \" s4 = f \"parameters: \\n { parameters } \\n \" return s1 + s2 + s3 + s4","title":"library_component"},{"location":"reference/sym_cps/representation/library/elements/library_component/#sym_cps.representation.library.elements.library_component.LibraryComponent","text":"Represent and model of component in the components_library. It has fixed properties and can have parameters and connectors. Source code in sym_cps/representation/library/elements/library_component.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 @dataclass ( frozen = True ) class LibraryComponent : \"\"\"Represent and model of component in the components_library. It has fixed properties and can have parameters and connectors.\"\"\" \"\"\"Component Model Name\"\"\" id : str comp_type : CType properties : dict [ str , CProperty ] = field ( init = False , default_factory = dict ) @property def parameters ( self ) -> dict [ str , CParameter ]: return self . comp_type . parameters @property def connectors ( self ) -> dict [ str , CConnector ]: return self . comp_type . connectors def _edit_field ( self , name , value ): object . __setattr__ ( self , name , value ) def _update_field ( self , name , value ): attr = object . __getattribute__ ( self , name ) attr . update ( value ) object . __setattr__ ( self , name , attr ) def __hash__ ( self ): return hash ( str ( self . id )) def __str__ ( self ) -> str : s1 = f \"name: { self . id } \\n \" f \"type: { str ( self . comp_type ) } \\n \" properties_str = [] for e in list ( self . properties . values ()): properties_str . append ( tab ( e )) properties = \" \\n \" . join ( properties_str ) parameters_str = [] for e in list ( self . parameters . values ()): parameters_str . append ( tab ( e )) parameters = \" \\n \" . join ( parameters_str ) connectors_str = [] for e in list ( self . connectors . values ()): connectors_str . append ( tab ( e )) connectors = \" \\n \" . join ( connectors_str ) s2 = f \"properties: \\n { properties } \\n \" s3 = f \"connectors: \\n { connectors } \\n \" s4 = f \"parameters: \\n { parameters } \\n \" return s1 + s2 + s3 + s4","title":"LibraryComponent"},{"location":"reference/sym_cps/representation/tools/","text":"","title":"tools"},{"location":"reference/sym_cps/representation/tools/analyze/","text":"","title":"analyze"},{"location":"reference/sym_cps/representation/tools/connectors/","text":"","title":"connectors"},{"location":"reference/sym_cps/representation/tools/ids/","text":"","title":"ids"},{"location":"reference/sym_cps/representation/tools/export/","text":"","title":"export"},{"location":"reference/sym_cps/representation/tools/export/design_swri/","text":"","title":"design_swri"},{"location":"reference/sym_cps/representation/tools/parsers/","text":"","title":"parsers"},{"location":"reference/sym_cps/representation/tools/parsers/learn_from_designs/","text":"","title":"learn_from_designs"},{"location":"reference/sym_cps/representation/tools/parsers/parse/","text":"parse_library_and_seed_designs () \u00b6 Generates a Components Library Source code in sym_cps/representation/tools/parsers/parse.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def parse_library_and_seed_designs () -> tuple [ Library , dict [ str , tuple [ DConcrete , DTopology ]] ]: \"\"\"Generates a Components Library\"\"\" c_library : Library = Library () . from_folder ( path = component_library_root_path_default ) \"\"\"Learn information form existing designs\"\"\" ( connectable_connectors , connectable_components_types , design_parameters , ) = parse_connections_and_parameters_from_designs ( design_library_root_path_default , library = c_library ) \"\"\"Update information to the library\"\"\" c_library . update_information ( connectable_connectors , connectable_components_types , design_parameters ) \"\"\"Load Seed Designs\"\"\" designs = parse_designs_from_folder ( design_library_root_path_default , library = c_library ) return c_library , designs","title":"parse"},{"location":"reference/sym_cps/representation/tools/parsers/parse/#sym_cps.representation.tools.parsers.parse.parse_library_and_seed_designs","text":"Generates a Components Library Source code in sym_cps/representation/tools/parsers/parse.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def parse_library_and_seed_designs () -> tuple [ Library , dict [ str , tuple [ DConcrete , DTopology ]] ]: \"\"\"Generates a Components Library\"\"\" c_library : Library = Library () . from_folder ( path = component_library_root_path_default ) \"\"\"Learn information form existing designs\"\"\" ( connectable_connectors , connectable_components_types , design_parameters , ) = parse_connections_and_parameters_from_designs ( design_library_root_path_default , library = c_library ) \"\"\"Update information to the library\"\"\" c_library . update_information ( connectable_connectors , connectable_components_types , design_parameters ) \"\"\"Load Seed Designs\"\"\" designs = parse_designs_from_folder ( design_library_root_path_default , library = c_library ) return c_library , designs","title":"parse_library_and_seed_designs()"},{"location":"reference/sym_cps/representation/tools/parsers/parsing_designs/","text":"parse_design_from_design_swri ( path , library ) \u00b6 Initialize a DConcrete from a design_swri file data Source code in sym_cps/representation/tools/parsers/parsing_designs.py 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 def parse_design_from_design_swri ( path : Path , library : Library ) -> DConcrete : \"\"\"Initialize a DConcrete from a design_swri file data\"\"\" \"\"\"Read design_swri file\"\"\" with open ( path , \"r\" ) as design_swri_file : design_swri_data = json . load ( design_swri_file ) \"\"\"Read the design name\"\"\" design_name = design_swri_data [ \"name\" ] new_design = DConcrete ( name = design_name ) \"\"\"Read the components and parameters\"\"\" # maps component instance name to library component component_map : dict [ str , tuple [ str , dict [ str , Parameter ]]] = {} for component_data in design_swri_data [ \"components\" ]: component_instance_str = component_data [ \"component_instance\" ] library_component_str = component_data [ \"component_choice\" ] component_map [ component_instance_str ] = ( library_component_str , {}) for parameter_data in design_swri_data [ \"parameters\" ]: parameter_name = parameter_data [ \"parameter_name\" ] parameter_value = parameter_data [ \"value\" ] component_properties = parameter_data [ \"component_properties\" ] parameters : dict [ str , Parameter ] = {} for prop in component_properties : component_name = prop [ \"component_name\" ] component_property = prop [ \"component_property\" ] library_component_str = component_map [ component_name ][ 0 ] param_id = parameter_id ( component_property , library . components [ library_component_str ] . comp_type . id ) for p , para in library . parameters . items (): print ( p ) try : param_type = library . parameters [ param_id ] except : print ( \"wasda\" ) param_type = library . parameters [ param_id ] parameter = Parameter ( parameter_value , param_type ) parameters [ param_id ] = parameter component_map [ component_name ][ 1 ][ param_id ] = parameter for p in parameters . values (): if isinstance ( p . component , str ): print ( \"ERRORRRR\" ) new_design . design_parameters [ parameter_name ] = DesignParameter ( id = parameter_name , parameters = set ( parameters . values ()) ) for component_name , ( library_component_str , parameters ) in component_map . items (): new_component = Component ( id = component_name , library_component = library . components [ library_component_str ], parameters = parameters , ) new_design . add_node ( new_component ) \"\"\"Read the connection\"\"\" for connection_data in design_swri_data [ \"connections\" ]: instance_s = connection_data [ \"from_ci\" ] instance_t = connection_data [ \"to_ci\" ] component_choice_s = component_map [ instance_s ][ 0 ] component_choice_t = component_map [ instance_t ][ 0 ] connector_id_s = connector_id ( name = connection_data [ \"from_conn\" ], component_type = str ( library . components [ component_choice_s ] . comp_type ), ) connector_id_t = connector_id ( name = connection_data [ \"to_conn\" ], component_type = str ( library . components [ component_choice_t ] . comp_type ), ) connection = Connection ( component_a = new_design . get_instance ( instance_s ), connector_a = library . connectors [ connector_id_s ], component_b = new_design . get_instance ( instance_t ), connector_b = library . connectors [ connector_id_t ], ) try : new_design . connect ( connection ) except : pass # d_concrete = new_design # d_topology = DTopology.from_concrete(new_design) \"\"\"TODO: Update connectable connectors\"\"\" # for key, value in connectable_connectors.items(): # for output_connector in value: # type: ignore # # print(f\"{key} -> {output_connector}\") # all_connectors[key]._update_field(\"compatible_with\", {all_connectors[output_connector].id: all_connectors[output_connector]}) return new_design","title":"parsing_designs"},{"location":"reference/sym_cps/representation/tools/parsers/parsing_designs/#sym_cps.representation.tools.parsers.parsing_designs.parse_design_from_design_swri","text":"Initialize a DConcrete from a design_swri file data Source code in sym_cps/representation/tools/parsers/parsing_designs.py 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 def parse_design_from_design_swri ( path : Path , library : Library ) -> DConcrete : \"\"\"Initialize a DConcrete from a design_swri file data\"\"\" \"\"\"Read design_swri file\"\"\" with open ( path , \"r\" ) as design_swri_file : design_swri_data = json . load ( design_swri_file ) \"\"\"Read the design name\"\"\" design_name = design_swri_data [ \"name\" ] new_design = DConcrete ( name = design_name ) \"\"\"Read the components and parameters\"\"\" # maps component instance name to library component component_map : dict [ str , tuple [ str , dict [ str , Parameter ]]] = {} for component_data in design_swri_data [ \"components\" ]: component_instance_str = component_data [ \"component_instance\" ] library_component_str = component_data [ \"component_choice\" ] component_map [ component_instance_str ] = ( library_component_str , {}) for parameter_data in design_swri_data [ \"parameters\" ]: parameter_name = parameter_data [ \"parameter_name\" ] parameter_value = parameter_data [ \"value\" ] component_properties = parameter_data [ \"component_properties\" ] parameters : dict [ str , Parameter ] = {} for prop in component_properties : component_name = prop [ \"component_name\" ] component_property = prop [ \"component_property\" ] library_component_str = component_map [ component_name ][ 0 ] param_id = parameter_id ( component_property , library . components [ library_component_str ] . comp_type . id ) for p , para in library . parameters . items (): print ( p ) try : param_type = library . parameters [ param_id ] except : print ( \"wasda\" ) param_type = library . parameters [ param_id ] parameter = Parameter ( parameter_value , param_type ) parameters [ param_id ] = parameter component_map [ component_name ][ 1 ][ param_id ] = parameter for p in parameters . values (): if isinstance ( p . component , str ): print ( \"ERRORRRR\" ) new_design . design_parameters [ parameter_name ] = DesignParameter ( id = parameter_name , parameters = set ( parameters . values ()) ) for component_name , ( library_component_str , parameters ) in component_map . items (): new_component = Component ( id = component_name , library_component = library . components [ library_component_str ], parameters = parameters , ) new_design . add_node ( new_component ) \"\"\"Read the connection\"\"\" for connection_data in design_swri_data [ \"connections\" ]: instance_s = connection_data [ \"from_ci\" ] instance_t = connection_data [ \"to_ci\" ] component_choice_s = component_map [ instance_s ][ 0 ] component_choice_t = component_map [ instance_t ][ 0 ] connector_id_s = connector_id ( name = connection_data [ \"from_conn\" ], component_type = str ( library . components [ component_choice_s ] . comp_type ), ) connector_id_t = connector_id ( name = connection_data [ \"to_conn\" ], component_type = str ( library . components [ component_choice_t ] . comp_type ), ) connection = Connection ( component_a = new_design . get_instance ( instance_s ), connector_a = library . connectors [ connector_id_s ], component_b = new_design . get_instance ( instance_t ), connector_b = library . connectors [ connector_id_t ], ) try : new_design . connect ( connection ) except : pass # d_concrete = new_design # d_topology = DTopology.from_concrete(new_design) \"\"\"TODO: Update connectable connectors\"\"\" # for key, value in connectable_connectors.items(): # for output_connector in value: # type: ignore # # print(f\"{key} -> {output_connector}\") # all_connectors[key]._update_field(\"compatible_with\", {all_connectors[output_connector].id: all_connectors[output_connector]}) return new_design","title":"parse_design_from_design_swri()"},{"location":"reference/sym_cps/representation/tools/parsers/parsing_library/","text":"parse_parameter_bounds () \u00b6 Parse design expert parameter bounds from 'lower_bound_file' 'lower_bound_file' Source code in sym_cps/representation/tools/parsers/parsing_library.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def parse_parameter_bounds () -> None : \"\"\"Parse design expert parameter bounds from 'lower_bound_file' 'lower_bound_file'\"\"\" if len ( all_parameters_lower_bounds ) == 0 : file = open ( lower_bound_file , \"r\" ) for line in file : k , v = line . strip () . split ( \":\" ) all_parameters_lower_bounds [ k . strip ()] = float ( v . strip ()) if len ( all_parameters_upper_bounds ) == 0 : file = open ( upper_bound_file , \"r\" ) for line in file : k , v = line . strip () . split ( \":\" ) all_parameters_upper_bounds [ k . strip ()] = float ( v . strip ())","title":"parsing_library"},{"location":"reference/sym_cps/representation/tools/parsers/parsing_library/#sym_cps.representation.tools.parsers.parsing_library.parse_parameter_bounds","text":"Parse design expert parameter bounds from 'lower_bound_file' 'lower_bound_file' Source code in sym_cps/representation/tools/parsers/parsing_library.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def parse_parameter_bounds () -> None : \"\"\"Parse design expert parameter bounds from 'lower_bound_file' 'lower_bound_file'\"\"\" if len ( all_parameters_lower_bounds ) == 0 : file = open ( lower_bound_file , \"r\" ) for line in file : k , v = line . strip () . split ( \":\" ) all_parameters_lower_bounds [ k . strip ()] = float ( v . strip ()) if len ( all_parameters_upper_bounds ) == 0 : file = open ( upper_bound_file , \"r\" ) for line in file : k , v = line . strip () . split ( \":\" ) all_parameters_upper_bounds [ k . strip ()] = float ( v . strip ())","title":"parse_parameter_bounds()"},{"location":"reference/sym_cps/representation/tools/parsers/temp_objects/","text":"","title":"temp_objects"},{"location":"reference/sym_cps/shared/","text":"","title":"shared"},{"location":"reference/sym_cps/shared/paths/","text":"","title":"paths"},{"location":"reference/sym_cps/tools/","text":"","title":"tools"},{"location":"reference/sym_cps/tools/io/","text":"","title":"io"},{"location":"reference/sym_cps/tools/persistance/","text":"","title":"persistance"},{"location":"reference/sym_cps/tools/strings/","text":"","title":"strings"},{"location":"coverage/","text":".md-content { max-width: none !important; } article h1, article > a { display: none; } var coviframe = document.getElementById(\"coviframe\"); function resizeIframe() { coviframe.style.height = coviframe.contentWindow.document.documentElement.offsetHeight + 'px'; } coviframe.contentWindow.document.body.onclick = function() { coviframe.contentWindow.location.reload(); }","title":"Coverage report"}]}